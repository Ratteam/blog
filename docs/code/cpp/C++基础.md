# C++基础

## 一、编程开发环境搭建

1、工欲善其事，必先利其器，不管做什么都得有个得心应手的工具！

我们课程使用的编程环境：
操作系统：Microsoft Windows 7 Ultimate Sp1 x64
编译工具：Microsoft Visual Studio 2013 Professional 中文版（其实 VS2010、VS2012、VS2013、VS2015、VS2017 都可以的，操作基本相同）

什么是编译器？微软的 Visual Studio 到底是个什么东西？
话说人有人言，兽有兽语，想让计算机听你的指挥，你就得说他能听得懂的语言，计算机能听懂的语言就是二进制的 0,1 之类的机器语言，这些语言计算机能听懂，但是人类看起来比较费劲，也不易于阅读，代码量大的话有问题了也不好维护。于是有计算机的大牛就发明了相对来说人类能比较好学，听的懂的语言，这就是高级语言，比如：Pascal、C、C++、Java 或汇编语言 等等。这些语言人来学起来会方便很多，相对来说也比较灵活，但是计算机听不懂，于是就得有个中间的软件，能把人类看得懂的高级语言转换成计算机能读懂的低级语言的软件。这实际上就是编译器的一个最基本的功能用途。

编译器的主要工作流程：源代码(source code)->预处理器(preprocessor)->编译器(compiler)->目标代码(object code)->链接器(Linker)->可执行程序(executables)

2、C/C++编译器的选择：
在 Windows 系统上有很多款支持 C/C++ 的编译器工具，这里给大家介绍几款典型的：

Turbo C/C++
DOS时代的C/C++编译器，启蒙先驱，也算是一款非常经典的编译器了，我上大学的时候（2003年）学的C语言就是用Turbo C/C++来编译代码；

Visual C++
微软出产的编译器产品。Windows下可以说最流行的C/C++编译器。6.0版本一代经典，至今仍然老而不死。最新版是2017。现在已经有功能相当完整的免费社区版供使用。

Borland C++
一代传奇宝蓝公司的作品，Turbo C/C++的进化版，可惜掩盖在自家王牌Delphi和外敌Visual C++的光芒之下，远没有这两者的历史地位高。

LCC-Win32
当年偶然发现的小品C编译器，编译速度很不错。不过并未进入过主流。

gcc/g++
GNU社区的神作，各大*NIX平台上的编译器的事实标准。直到近年来clang的兴起才开始受到挑战。

clang
最年轻的成员之一，BSD社区的倚天神剑，开发迅速，对标准的支持也相当好，大有挑翻gcc/g++的势头。FreeBSD已经将其列为默认编译器。

Intel C++
号称生成的代码质量最高，优化最到位的C++编译器。但是对AMD的CPU支持的不是很好。

相关各种C/C++编译器的历史课后大家可以看看这两篇文章：
https://yq.aliyun.com/articles/47476
https://www.zhihu.com/question/39661628

在Windows平台下，时下最火的C/C++编译开发工具可以说是微软的 Visual C++了。它是 Visual Studio 可视化开发工具集合的一个子集。Visual Studio 包括 Visual C++、Visual Basic、Visual F#、Visual C# 等等。

3、Visual C++ 版本的选择：

Visual C++ 6.0：推出年代是1998年，那时候C++的标准尚未完善，STL的标准也还没出，所以有了MFC CArray、CList、CMap 等容器。
功能在当时那个年代来说确实很强大，VC6.0也是非常经典的一个版本。可现如今 Visual C++ 6.0 确实有点太老了，距离发布年代已经过了将近20年，系统也从WIN95升级到了现在的Windows7，Windows10 ，VC6.0最后支持的系统是Windows2003，对于以后系统的一些新特性、新功能API函数等 VC6.0 是不支持的。另外它对C++11/C++14/C++17的新标准、新语法更是不可能支持了。所以这里建议大家不要死揪着不放，不要在一棵树上吊死，VC6.0确实经典，但实在是太老了。易用性来说也赶不上现在的VS2013等高版本，所以不建议大家再使用VC6.0了。

Visual C++ 2013：是 Visual Studio 2013 的一部分，全面支持 C++11，STL 等标准库，使用起来也很方便。而且都2017年了，更新下开发工具吧，不要再用上个世纪的 VC6.0 了。
有人说新版本不好用，或者用不习惯，那是你用的时间还少，我本身也是从VC6.0的阶段过来的，如果你用习惯了Visual Studio系列，你会爱上他的。早把VC6抛弃了。再说不是还有我来教大家吗？

很多Linux下的C/C++开发人员在写代码的时候，都是用Visual Studio的Visual C++来编译调试代码，功能写的差不多了，没问题了，再到Linux系统上面用 GCC 或者其他的编译器来编译下代码，本身C++就是跨平台的。之后就可以直接发布了。我在公司中就经常这么做。因为 Visual C++ 的编辑调试代码什么的确实很方便，自动提示什么的也很智能。

从微软的VS2003开始，之后的VS系列编译器的操作界面，以及使用角度来说都差别不是很大（跟老版的VC6.0差别就大多了），所以，虽然我们的教程所选择的编译器版本是VS2013，但是大家使用vs2005/vs2008/vs2010/vs2012/vs2013/vs2015/vs2017 等等都是没问题的。不用非得和教程使用的VS版本一致。

建议：10年以前的电脑使用VS2008，稍微不错的就可以直接上VS2013了。

4、安装 Visual Studio 2013 开发工具：
下载地址（MSDN我告诉你）：https://msdn.itellyou.cn/
若想从微软官方下载，详见：https://www.cctry.com/thread-276152-1-1.html
备注：具体安装过程见视频教程

5、安装MFC多字节补丁（以后会用到）：
Multibyte MFC Library for Visual Studio 2013
https://www.microsoft.com/zh-cn/download/details.aspx?id=40770
https://download.microsoft.com/d ... 2703/vc_mbcsmfc.exe
备注：具体安装过程见视频教程

6、Visual Studio 2013 的破解激活：
Visual Studio Ultimate 2013 KEY（密钥）：BWG7X-J98B3-W34RT-33B3R-JVYW9
Visual Studio Premium 2013 KEY（密钥）：FBJVC-3CMTX-D8DVP-RTQCT-92494
Visual Studio Professional 2013  KEY（密钥）： XDM3T-W3T3V-MGJWK-8BFVD-GVPKY
Team Foundation Server 2013 KEY（密钥）：MHG9J-HHHX9-WWPQP-D8T7H-7KCQG
备注：具体破解过程见视频教程

7、安装 Visual Assist X 插件，如虎添翼，加快开发效率：
Visual Assist X 是一款非常好用的 Visual Studio 插件，支持VC6.0以及 Visual Studio 2003-2017，C/C++，C#，ASP，VisualBasic，Java和HTML等语言，能自动识别各种关键字、系统函数、成员变量、自动给出输入提示、自动更正大小写错误、自动标示错误等。使用Visual Assist X有助于提高开发过程的自动化和开发效率。所以是非常值得安装的。
备注：具体安装过程见视频教程

8、Visual Studio 2013 的相关配置：
设置字体、文字颜色、添加工具栏编译按钮、回滚设置、导航栏设置 等等，课后大家可以自己摸索着试试。

## 二、C++语言概述


1、从C到C++
计算机诞生初期，用机器语言或汇编语言编写程序；
第一种高级语言FORTRAN诞生于1954年；
BASIC语言(1964)是由FORTRAN语言的简化而成的是为初学者设计的小型高级语言；
C语言是1972年由美国贝尔实验室的 D.M.Ritchie 研制成功的。它是为计算机专业人员设计的；
大多数系统软件和许多应用软件都是用C语言编写的。随着软件规模的增大，用C语言编写程序渐渐吃力了，于是便创造出了C++语言。

2、C++的特点
C++是由 AT&T Bell实验室 于20世纪80年代初在C语言的基础上成功开发出来的。C++保留了C语言原有的所有优点，并增加了面向对象的机制。
C++是由C语言发展而来的，与C兼容。用C语言写的程序基本上可以不加修改地用于C++。从C++的名字可以看出它是C的超集。C++既可用于面向过程的程序设计，又可用于面向对象的程序设计，是一种功能强大的混合型程序设计语言。
备注：C++不是纯面向对象语言。

3、C++是对C语言的“增强”
(1) 在原来面向过程机制的基础上，对C语言的功能做了很多扩充。
(2) 增加了面向对象的机制。
面向对象程序设计，是针对开发较大规模的程序而提出来的，目的是提高软件开发的效率。不要把面向对象和面向过程对立起来，面向对象和面向过程不是矛盾的，而是各有用途互为补充的。

所以，通俗来讲，大家在学习的过程中不要把C语言和C++做为两门独立或者对立的语言来学习，本身他们就可以看成是一门语言，任何一款支持C++的编译工具都支持C语言。C++就是C语言的超集，包括了所有C语言的特性，所以你把C++学会了，C语言自然也就会了。如果你之前学过C语言，那么再学习下C++的面向对象思想，那么两者你也就都会了。

给大家举个例子：
学习编程的人针对谭浩强这个名字应该几乎都听过。谭浩强老师的C语言/C++语言的编程书籍可以说是国内很多大学的标杆教材了。我读大学时候的C语言教材就是谭浩强老师的。
他有一本《C语言程序设计》专门讲解C语言的，还有一本《C++程序设计》专门讲解C++的，书挺厚的，包括了C语言的部分。还有一本是《C++面向对象程序设计》是专门讲解C++的，所以可以这么说：《C语言程序设计》+《C++面向对象程序设计》=《C++程序设计》，这也充分体现了C语言和C++的关系。

说到谭浩强老师我这里要说一说了。国内很多读者对谭浩强老师褒贬不一。但我个人确实是比较推崇谭浩强老师的书，大学时候就是用他的书籍入门的。有很多人说他的书籍有错误，讲解的不好。我要说这个错误不怪他，《C语言程序设计》第一版刚出来的时候，系统还是Win98，16位的，所以相关一些类型占用的字节数等等，跟我们现在使用的x86或者x64根本不一样，所以才出现了网友口 错误。不过《C语言程序设计》、《C++程序设计》 等谭浩强老师的书籍后续都有新版本，所以大家也不要总拿第一版或者老版本来说事儿。

4、用途：C语言和C++都能做什么呢？
C语言：操作系统底层、系统驱动、单片机、嵌入式方面 等等；
C++：网络游戏开发、音视频技术、Socket网络通信，另外，苹果/谷歌/微软 等大型软硬件公司的系统或者软件上面都支持C/C++语言的集成开发。

你常用的软件大多数都是C++写的，例如：Office软件：MS Office，WPS Office，OpenOffice/LibreOffice，你所用的Windows也用了大量的C++，你说你在用C#和SQL，那我告诉你你用的 VS IDE 核心部分是C++写的，你用的C#，C# 的.Net执行框架也是C++写的，你用的Sql数据库，是Sql Server吧？很不幸，Sql Server也是cpp写的、你上网页在用浏览器吗？很不幸，浏览器内核都是C++写的，界面大多数浏览器界面也是C++写的，你聊天用的 QQ、YY、Skype 等也是C++写的。这些都是你绝对有在用的，至于其他，还有很多，杀毒软件、PhotoShop、Maya，N多行业软件，几乎所有的端游 等等，都是C++写的。你问我C++能做什么实际的东西，我告诉你什么也做不了，你信吗？哈哈

C++ 的几个常见的发展方向：客户端，游戏，服务端，嵌入式，移动端（移动只要是跨平台的移动端用C++写通用部分，GUI可以用平台特性，也可以用C++的跨平台框架）
针对界面UI方面C++的选择也是很多的，其实C++还是擅长“内功”的方面。如果你想带个GUI界面的话，也有很多类似Qt之类的框架和界面库可以使用，网上有很多，而且很多都跨平台，还开源，不管是 Windows，还是Mac，还是Linux，还是移动端平台，通吃的。本身C/C++就是跨平台的。

另外，说点大家感兴趣的，什么远程控制软件，什么木马，什么外挂等等，可以说95%以上都是用C/C++来写的。

难道这么多的用途还不值得大家来好好学学C/C++吗？

另外，闻道有先后、术业有专攻，C++虽然功能很强大，几乎什么都能做，但有的地方也是不适合，不是不能做而是不适合。比如网页开发，C++也能做，但是还是建议使用Java-Web或者PHP之类的语言来做，毕竟他们就是为了Web开发而生的。

5、C/C++ 同其他语言的区别：
一、编译型语言
定义：需通过编译器（compiler）将源代码编译成机器码，之后才能执行的语言。一般需经过编译（compile）、链接（linker）这两个步骤。编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。
优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。
缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。
代表语言：C、C++、Pascal、Object-C 以及最近很火的苹果新语言Swift

二、解释型语言
定义：指用专门解释器对源程序逐行解释成特定平台的机器码并立即执行的语言，相当于把编译型语言的编译链接过程混到一起同时完成的。
解释型语言执行效率较低，且不能脱离解释器运行，但它的跨平台型比较容易，只需提供特定解释器即可。
代表语言：Python（同时是脚本语言）与 Ruby、PHP 等。

三、脚本语言
定义：为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。
它的特点是：程序代码即是最终的执行文件，只是这个过程需要解释器的参与，所以说脚本语言与解释型语言有很大的联系。脚本语言通常是被解释执行的，而且程序是文本文件。
代表语言：JavaScript，Python、Perl 等。

四、混合型语言
既然编译型和解释型各有缺点就会有人想到把两种类型整合起来，取其精华去其糟粕。就出现了半编译型语言。比如 C#，C#在编译的时候不是直接编译成机器码而是中间码，.NET平台提供了中间语言运行库运行中间码，中间语言运行库类似于Java虚拟机。.Net在编译成IL代码后，保存在DLL中，首次运行时由JIT在编译成机器码缓存在内存中，下次直接执行。严格来说混合型语言属于解释型语言。C#更接近编译型语言。
代表语言：C#、Java

6、第1个C++程序：Hello World！
```cpp
#include <iostream>
int main(int argc, char* argv[])
{
    cout<<"Hello World!"<<endl;
    return 0;
}
```
## 三、VS2013的基本使用
1、自定义起始页：
VS2013启动之后，有各种各样的启动页面，有的是空白页面，有的是启动首页，有的是直接打开上一次的工程，有的是打开工程创建向导，那么这些是如何设置的呢？接下来教大家来设置一下，大家可以根据自己的偏爱喜好设置成自己的启动页面！

2、常用的VC++新建工程类型讲解：
ATL项目、CLR项目、MFC项目、Win32项目，每种项目都是做什么用的？生成的都是什么类型的文件？是我们常用的EXE，还是DLL，还是其他的呢？听我一一道来！

ATL项目，主要是跟COM相关的，COM插件等等，比如给OFFICE的Word写插件，给Excel写插件，等等。生成的文件是DLL，比如：VC驿站编程助手，或者比较有名的大漠插件等等一般都是用这种类型的工程创建的；
CLR项目，这种类型使用的不是很多，起码我使用的不是很多，他是调用微软的 .Net Framework 库来解析执行代码的项目类型，类似JAVA虚拟机。既然选择了编译类型的语言C++作为开发，所以就没必要在使用CLR了，如果要使用微软的 .Net Framework 库来开发程序，还不如直接选择 C# 或者 VB.NET 更方便了。
MFC项目，这个可能大家都听过，微软的VC++中很早就有了，是对微软API的封装，简化开发流程，可以做出带界面的程序。生成的文件可以是EXE的，也可以是DLL的。其中DLL包括普通的DLL，也可以是 ActiveX 的组件式DLL，比如可以给微软的 IE 写个插件啊。咱们VC驿站之前的很多教程都用到了MFC，以后会给到大家详细介绍讲解的。
Win32项目，主要就是调用微软的API函数进行程序开发，可以开发出EXE程序，也可以开发出DLL程序。其中EXE的程序可以带窗口的，也可以是不带窗口的，也可以是基于命令行模式的环境运行，等等。

备注：大家现在都是初学者，上面说的一些工程类型大家可能听的不是很懂，不过没关系，以后会慢慢接触到，大家现在只要有个大概的了解，知道每种类型的工程是干嘛的，能开发出什么东西就行。

3、VS2013界面内各个子窗口的作用：
新建/打开一个Win32控制台类型的工程，可以打开上节课咱们新建的 HelloWorld 工程，之后，具体来看看每个子窗口都是干嘛的，有什么作用呢？

VS2013有很多子窗口，常用的子窗口有以下这些：
左侧：解决方案资源管理器、类视图、资源视图、VA View、VA Outline（大纲）
右侧：属性、工具箱
上面：主要是工具栏上面的按钮：新建、保存、撤销、重做、启动、Debug、Release、Win32、生成、向后导航、向前导航、文件中查找、注释、取消注释
工具栏如何添加自定义按钮呢？

下面：输出、查找结果、断点

备注：
在调试模式下，还有一些额外的窗口，等到讲解到调试程序的时候再给大家详细介绍；
VA助手插件的使用以后再给介绍，不然现在就讲解的比较细致新手恐怕会比较懵懂。

4、误操作，部分子窗口关掉之后如何调出来，如何改变位置？
每个人都有误操作，默认的一些窗口误操作关闭之后如何调出来呢？其实各个窗口都在【视图(V)】菜单下有具体的菜单项，关闭了之后再从菜单中点出来就可以了。但是如何把他们以标签Tab的形式合成到一起，这个就涉及到子窗口的拖拽合成了，文字不太好表达，具体看视频演示吧。

5、工程关掉之后，如何再次重新打开？ -- SLN

6、小作业：
◆ 如何让代码左侧显示行号？
◆ 默认安装完VA小助手插件之后生成了一个代码区域的导航栏，比VS2013自带的方便很多，那么如何去掉VS2013自带的导航栏呢？
## 四、玩转 hello world
1、基本hello world 代码讲解：

#include "stdafx.h"        //包含自己的头文件
#include <iostream>        //包含系统的头文件
using namespace std;        //命名空间

int _tmain(int argc, _tchar* argv[])        //入口点函数
{
        cout << "hello world!" << endl;                //输出内容并换行
        return 0;                                                //返回
}

什么是自己的头文件，什么是系统的头文件，#include "" 和 #include <> 有什么区别？
自己的头文件是在当前工程目录下有的头文件，系统的一般是编译器提供的。

命名空间又是什么呢？
防止重复名字的发生，比如系统提供了一个变量或者函数的名字叫做 abc，你自己也定义了一个变量或者函数的名字叫 abc，这时候编译器就不知道该调用哪个？名字有冲突了，这个时候为了防止冲突就引入了命名空间的概念。
打个比喻：在1年6班有个叫张三的同学，在1年7班也有一个叫张三的同学，我直接喊张三谁知道叫的是哪个张三？所以这个时候就要限定一个前缀，到底是6班的张三还是7班的张三呢？
再如果在1年6班有2个叫张三的同学，那么这个时候就要指定是个儿高的张三还是个儿矮的张三，是胖的张三还是瘦的张三呢？这个高矮胖瘦就是命名空间的作用了！

2、简化代码：
有的网友会说我用vc6.0建立的工程跟一般的c++书中讲解的很一致，main 函数类似下面这样：

#include <iostream>
using namespace std;

int main()
{
        cout << "hello world!" << endl;
        return 0;
}

vs2013建立的工程怎么这么多代码，怎么这么多文件，还有什么 stdafx.h，另外，main 也变成了 _tmain，还有 argc，grgv 这些参数，代表什么意思呢？这么复杂？我们可不可以不要这些。答案是肯定的，可以！
下面就教大家如何来操作！

◆ 精简现有 hello world 代码；
◆ 从头做起，新建空白工程，添加代码。

备注：具体操作详见视频教程！

所以说：vc6.0能做的vs2013一定能做，vs2013能做的vc6.0不一定能做。大家就不要纠结于vc6啦，赶紧升级到 visual studio 吧！

3、简单案例：实现两个数相加，输出结果！
#include <iostream>
using namespace std;

int main()
{
        cout << "hello world!" << endl;
        cout << "2 + 3 = " << 2 + 3 << endl;
        return 0;
}

4、简单案例：实现 1~100 所有数相加，输出结果！
有的网友会说，你用代码实现个 2 + 3 这不脱裤子放屁，费那个二遍事嘛，这么简单还用代码来算吗？张嘴就来了。我要说我实现个 258 + 963 呢？有的网友又会说我直接拿计算器就行了，也比写代码快啊。那么我要问你了，我要实现 1~100 之间所有数的累加和呢？你还用脑袋算吗？你还用计算器算吗？我用几行代码轻松搞定了！

#include <iostream>
using namespace std;

int main()
{
        cout << "hello world!" << endl;
        cout << "2 + 3 = " << 2 + 3 << endl;

        int sum = 0;
        for (int i = 1; i <= 100; i++)
        {
                sum += i;
        }
    
        cout << "1+2+3+...+100 = " << sum << endl;
    
        return 0;
}

## 五、c++的数据类型与常量
1、c++的各种数据类型：


有的网友会问，为什么有这么多的数据类型，烦不烦啊？那我要问你了，你家做饭就用一个盆吗？
是不是有个大盆，中盘，小盆？勺子呢？有大勺，中勺，小勺，露眼勺 等等，刀呢，是不是有切肉的，还有切菜的，还有切水果的？
数据类型也是一样，不同的数据类型有不同的作用。

整型呢，一般用来表示整数，没有小数点的，浮点型一般用来表示有多位小数点的数，字符型呢，一般表示一个一个的字符，比如字母 a，b，c 之类的。
有的网友会问，简单来说，整型和浮点型能不能统一都用浮点型，比如：5.0 就表示整数5，也是可以的。他们占用的空间不一样，那我问你，你在家用饭盆吃饭么？能不能吃，肯定能吃，但是太大了，不方便啊，你喝水呢，用水桶喝水吗？能不能喝，能喝，但是不方便。所以，还是本着什么东西该用到什么地方就用到什么地方，不能乱用，不然不是这不合适，就是那不合适。

类型呢，又可分为 有符号的 和 无符号的，有符号的可以表示负数，无符号的只能表示正数。但是无符号的最大正数会比有符号的最大正数大很多。


2、各种类型所占用的空间大小：即，桶的大小
必须得知道各个“桶”的大小之后，才能决定用哪个来“喝水”，对吧？不然太大浪费，太小了又不够用。


举个栗子：比如说中国有13亿人口，用来表示人口数的变量类型你怎么选？用 short 或者 unsigned short 可以吗？其最大表示的正整数才是65535，也就是 6万 多人，跟13亿差太远了。。。如果用 unsigned int 呢，其最大值是 4294967295，也就是 42亿多，用来表示中国 13 亿人口足够了。但是全球的世界人口呢？

在人口统计学中，世界人口是目前全球的总人数。 世界人口估计在2017年4月24日16时21分（UTC）达到75亿人。 联合国估计，在2100年将进一步增加到112亿。
75亿，112亿，那么现有的 unsigned int 类型又表示不下了，unsigned int 类型占用 4个 字节，所以得找能占用 8个字节的整型才行。上面的那个表没有，再给大家看一个表：


用什么类型啊？unsigned long long 占用8个字节，这回足够用了，其最大值是：18446744073709551615，这个数确实是太大了。。。184万万亿！这回表示全球人口够用了吧！可如果你用 unsigned long long 来表示一个班级中所有学生的数目，那就有点太浪费了。一个班级中所有学生的数量不会超过几百人吧，用个 unsigned short 足够用了，还节省空间。所以说大家以后做编码开发的时候要根据自己的实际情况来选择。

3、空间大小的衡量标准：
我上面说的类型占用几个字节啊什么的，大家可能没个标准也不太好衡量。下面我给大家介绍一个单位：
就目前来说大家可能比较熟悉的单位就是：MB、GB、TB 可能大家比较熟悉了。说今天我买了一块 2TB 的硬盘。昨天我买了一块240G的固态硬盘，我电脑的内存是8G，等等。
存储单位主要有以下这么多：B，KB，MB，GB，TB，EB，ZB，YB，BB
他们之间都是1024倍的关系：
1B   = 8bit（比特）
1KB = 1024B（字节）
1MB = 1024KB
1GB = 1024MB
1TB = 1024GB

有个了这个比较，大家大体上应该知道字节单位的大小了吧！一首MP3音乐文件的大小大概在 3~4MB的样子，一个普通的高清电影一般在1~2GB的样子。

使用重点：要兼顾扩展性与占用空间两方面的需求。小了不够用，容易溢出越界，大了呢既占用空间，又不利于网络传输！
举个例子：有符号的 char 能表示的范围是：-128~+127，你说这个体积小，就占用一个字节，我就用它来表示人的年龄吧，127，但是你不感觉这个数字有点悬吗？真就有某位长寿星，年龄超过127也不是不可能啊，所以一味的为了节省空间，而选择占用小的类型也不是明智之举，容易越界溢出。所以用个 short 来表示还是比较不错的，取值范围既够用，占用空间也才 2 个字节。另外，年龄不可能是负数，所以直接用 unsigned short 就可以了。

4、C++ 常量：
常量的分类：
①、数值常量：整型、浮点型；
整型：5,6 之类的；
浮点型：1.3, 2.6 等等，就是带小数点的；

②、字符常量：普通字符常量、转义字符常量、字符串常量；
普通字符常量：'a'，'d'等
转义字符常量：


字符串常量："zhangsan"

③、符号常量：宏定义：#define PRICE 30

5、常量示例代码：
#include <iostream>
using namespace std;

//苹果的价格是5块钱一斤

#include <iostream>
using namespace std;

#define Apple_Price 5

int main()
{
        cout << "Hello World." << endl;
        cout << "张三 要去买苹果啦..." << endl;

        int num = 10; //10斤
        int total_money = num * Apple_Price;
        cout << "张三要买 " << num << " 斤苹果，每斤 " << Apple_Price << " 块钱，总共要付：\n" << total_money << " 元" << endl;
    
        return 0;
}
复制代码


6、小作业：
自己编写代码实现输出单引号和双引号！

## 六、C++ 变量

1、什么是变量？
变量，顾名思义，就是在程序的运行过程中值是可以改变的。
上一节课给大家讲解了常量的知识点，在实际编程的过程中会涉及到各种各样的变量，毕竟常量是不可改变的。在实际的软件开发过程中，由于要经过很多的计算工作，所以单纯常量是满足不了的，必须使用很多的变量。
一个变量包括变量的类型、名字和变量的值。

2、变量名字的命名规则：
C++规定变量的名字只能由数字、字母、下划线这么三种字符组成。而且第一个字符不能是数字，必须是字母或者下划线。
举几个例子：
Sum, add, total, helloWorld, user1, _Pass, my_num_1 等等，但是 3gx 这种是错误的，不能是数字开头。
注意：大小写是区分的，Sum 和 sum 以及 SUM、suM 都认为是不同的变量。

备注：命名建议：
①、最好以变量的用途来命名：
例如：
求和：sum
学生：student
苹果：apple

另外，大家也可以百度一下 “匈牙利命名法”，在变量前面加一个字母来表示变量的类型：
iSum，cSex 等等，i 表示 整型的 int，c 表示字符型的 char 等等。

这样程序更易于维护，如果代码量比较大的话时间久了就容易忘了，如果变量的名字起的让人一看就知道是干嘛用的，这不是能节省很多时间么。而且以后来说可能代码不是你一个人看，还有别的人看呢！

②、最好不要用中文来命名，如果你英文不是很好的话，用拼音也比用中文专业。

③、命名长度：C++中没有强制规定命名标识符的长度，但各个具体的编译器厂商一般都有限制。有的不能超过32个字符等等。反正也没必要那么长，尽量能标识该变量的用途就可以了。

3、变量的定义：
定义格式：数据类型 变量名表列;
例如：
int num;
char ch;
float a, b, c;

必须先定义，后使用，不然肯定报错，编译都过不去。大家可以看看咱们前几节课给大家写的那些简单的代码，里面就有变量的定义。
变量定义完了之后，系统就开始为该变量分配内存空间，具体分配多少由变量的类型决定，例如：int 是 4个字节，char 是1个字节 等等。

4、变量的初始化赋值：
变量在定义的时候就可以为其赋初始值，称为变量的初始化：例如：
int num = 5;
char ch = 'a';
float a = 1.2, b = 2.6, c;

其实：int num = 5; 和
int num;
num = 5;
是一个作用，上面的是1条语句，下面的是2条语句。

5、何为 常变量？
常量，就是值不能改变，变量，就是值可以改变，那么常变量又是个什么东西呢，常量和变量结合一起的产物是什么呢？
总结一句话就是变量在赋初值之后就不能改变了，即要求定义的时候必须赋值。
那么如何来区别呢，那就是在变量定义的前面加上 const 关键字，例如：
const int sum = 100;
这样 sum 这个变量在定义的时候就初始化了，不过在以后的代码中，如果你尝试去修改 sum 的值肯定会报错的。大家不妨在VS2013中试试！

有细心的网友可能会注意到，常变量的用途跟上节课讲解的符号常量：宏定义：#define PRICE 30 有点类似。这里跟大家说一下，其实宏定义#define 是属于C语言的东西，C++为了兼容C语言，所以保留了下来，不过在C++中更建议使用常变量来定义。就好像C语言中使用 printf 来输出打印字符串，在C++中建议使用 cout 一样。不过C++中都是支持的。

6、小作业：
请大家课后查找const常变量和#define宏定义有什么区别呢？

## 七、C++ 运算符
1、C++中提供了很多种运算符：

■ 算术运算符：
+（加）、-（减）、*（乘）、/（除）、%（整除求余）、++（自加）、--（自减）

■ 关系运算符：
>（大于）、<（小于）、==（等于）、>=（大于或等于）、<=（小于或等于）、!=（不等于）

■ 逻辑运算符：
&&（逻辑与）、||（逻辑或）、!（逻辑非）

■ 位运算符：
<<（按位左移）、>>（按位右移）、&（按位与）、|（按位或）、^（按位异或）、~（按位取反）

■ 赋值运算符：（=号及其扩展赋值运算符）
■ 条件运算符：（?:）
■ 逗号运算符：（,）
■ 指针运算符：（*）
■ 引用运算符和地址运算符：（&）
■ 求字节数运算符：（sizeof）
■ 强制类型转换运算符：（(类型) 或 类型()）
■ 成员运算符：（.）
■ 指向成员的运算符：（->）
■ 下标运算符：（[]）
■ 其他运算符：（如函数调用运算符()）

C++中提供了如此之多的运算符，大家刚开始学，也不用都记住，以后会慢慢用到慢慢讲解到的，大家先混个脸熟，大概知道有这么个东西就行。

2、基本的算术运算符：

基本的算术运算符无外乎就是加减乘除，但是这里面也有些门道，且听我细细道来！
+：加法运算符或正值运算符：2+3，+3；
-：减法运算符或负值运算符：5-2，-3；
*：乘法运算符：3 * 5；
/：除法运算符：5/3；
%：求余运算符：5%3，要求两侧均为整数。

加、减、乘 这几个没什么好说的，跟我们现实生活 运算基本一致。这里我重点说一下除法和求余运算符，跟我们平时见过的有点不一样！
5/3 大家知道结果是多少吗？猜一猜，这里不说5/3了，简单点，就说5/2，很多学员肯定马上就回答了：2.5，到底结果是不是 2.5 呢，我们到VS2013中来测试一下。详情见视频语音讲解。
int x = 5, y = 2;
cout << "5 / 2 = " << x / y << endl;

所以，这里面的 / 是求商的意思。5除以2，商=2，余数是1，这个大家小学的时候应该学过。同理，5/3=1，商是1，余数2；
4/2=2，商是2，余数是0；那我要问了，3/5呢？3/5=0，余数是3；

% 就是求余的功能，我们不妨来试一下，详情见视频教程！~

那么有的会员会问了，我想正确的得到 5除以2等于2.5，怎么办呢？别着急，不是还有浮点类型的数嘛！

float x = 5.0, y = 2.0;
cout << "x / y = " << x / y << endl;

再问大家一个问题：
float x = 5.0;
int y = 2;
cout << "x / y = " << x / y << endl;
这个结果是什么呢？大家可以自己动手试试！答案是：2.5

3、混合类型运算规则：
在表达式遇到不同数据类型的混合运算时，要求不同类型的数据要先转换成同一类型然后才能进行运算。默认编译器会有个规则进行自动转换：
自动转换遵循以下规则：
       
1) 若参与运算的两个参数类型不同，则先转换成同一类型，然后再进行运算；
2) 按照数据长度增加的方向进行（即：由 少字节类型 向 多字节类型 转换），以保证精度不丢失；
3) 所有的浮点运算都是以双精度进行的，即使仅含 float 单精度量运算的表达式，也要先转换成 double 类型，再作运算；
4) char 类型 和 short 类型参与运算时，必须先转换成 int 类型，也就是说最小的运算整形单位是 int；
5) 在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型（右随左变）。如果右边的数据类型的长度比左边长时，将丢失一部分数据，这样会降低精度，例如：int x = 2.5;

下图表示了类型自动转换的规则：


例如：2.5+3，这里面两个数，第一个是浮点类型，我们可以认为是float，第二个是整形，我们可以认为是int，这里如果将两个数都转换成int整形，那么float类型的2.5肯定表示不了，整形没有小数点，所以如果这样转的话就会丢数据，2.5变成2了，所以不可取。那么就得按照float来转，将3转换成float类型的3.0，所以结果就是double类型的3.5了，大家明白了吗？

★注意：无论是 自动转换 还是 强制转换 ，都只是为了本次运算的需要而对变量的数据长度进行的临时性转换，不会改变数据说明时对该变量定义的类型。

4、强制类型转换运算符：
有时候我们不想要编译器默认的自动转换，我们要手动进行强制类型转换，例如：大家到超时买东西，最后所有东西的价格是：36.08元，对于结尾的8分钱一般都是直接省略掉了，所以就取整36，等等。这时候就需要强制类型转换。
另外，大家打车的时候是不是也不找零，都是四舍五入，例如：21.4，那么师傅就收21，如果是21.8，那么师傅就收22，也是一样的道理。现实生活中会有很多种这样的情况。

强制类型转换有两种表达形式，下面举例说明：
int x = 2;
float y = 3.6;
x = (int)y;
y = float(x);

大家说说强制类型转换之后 x 和 y 的值是多少呢？

5、自增++和自减--运算符：
这个++和--也是我当初学习C语言的时候总搞糊涂的一个东西，对于新手来说很绕。下面用通俗的话给大家讲解下，例如：x++ 等于 x = x+1
int x = 2;
int y = x++;
int z = ++y;
这几条语句之后，x，y，z 的值分别为多少呢？
给大家说下，x++ 不要当做一条语句来看，同样，++x 也不要当做一条语句来看。他的作用不仅仅是对变量 x 进行+1操作，他本身还是个表达式；
不管是 x++ 还是 ++x 执行完之后，x变量自己的值都进行了+1，但是针对整个 x++或者++x的值就不一样了。x++执行之后，这个表达式的值还是x+1之前的值，++x执行之后，这个表达式的值是x+1之后的值。
所以：int y = x++; 执行之后，x的值为3，y的值为2；int z = ++y; 执行完之后，y的值是3，z的值也是3，大家明白了吗？

## 八、赋值运算符和赋值表达式 


1、赋值运算符：
总结一个原则：多的给少的会丢失，少的给多的没事儿。
例如：int x = 3.5; 赋值完了之后 3.5 这个浮点类型的值肯定丢失小数点部分，变成了整形的3；
float y = 2; 赋值完了之后 2 的值不会有任何丢失，不过变成了浮点类型的数：2.0；

另外，不仅仅有小数点部分的丢失，取值范围有可能越界，例如：
short 能表示的范围是：-32768~+32767，最大值也才3万多，那我要是这样赋值呢？
short q = 50000; 大家可以把这句话放到 vs2013 中实践一下，发现复制完成后，q的值变负数了，说白了也就是越界了。为什么会变成负数呢，这里涉及到补码的东西，以后会给大家讲解。
一个水桶容量就2升，你非要装4升，那桶还不撑坏了呀？

另外，把一个负数赋值给一个无符号的数也会发生问题的，例如：
unsigned int x = -2; 这样的问题也不应该发生。

总结：赋值运算的时候要注意的两点：精度的丢失，取值范围的越界。

2、复合赋值运算符：
上节课给大家讲解了：
int x = 0；
x = x + 1; //可以替换为 x++; 既简单又方便
那我要问：x = x + 8 呢？有什么简单的写法吗？单纯 x++ 或者 ++x 都不行啊。
这里给大家一种新的简便写法：x += 8; 就可以啦。同理，其他的还有很多，例如：
int x = 10;
x -= 2; //x的值为8

下面我把支持这类操作的运算符都给大家列出来：
+=, -=, *=, /=, %=, <<=, >>=, &=, ^=, |=

3、逗号表达式：
逗号表达式在以后的编程中也会经常遇到，其规则是：所有以逗号间隔的表达式都进行计算，各个表达式的计算顺序按照从左往右。整个表达式的值是最后一个逗号表达式的值。例如：
int x = 0;
int y = 0;
x +=2, y+= 3;
int q = ((x++), (++y));
我要问问大家了，q的值是多少呢？

4、小作业：
①、
int x = 2;
x = 3 *5, x*4;
经过计算之后，变量 x 的值是多少呢？

②、自学运算符的优先级：


具体大家听我视频讲解吧，语音的形式比文字更好表达一些，这样大家能听的更明白一些。

## 九、C++的语句与输入输出
1、语句：
C++程序设计中有很多种语句，经常听有的人说：“这几条语句怎么怎么样之类的”。。。在编写C++代码的过程中我们无时无刻不在书写着语句，例如：
int a, b; 这是变量的声明语句；以后还会给大家讲解到 if-else 条件选择语句，for、while、do-while 循环语句，continue 结束本次循环语句，break 中止执行 switch 或 循环语句，还有 goto，return 等语句，以后都会讲解的。
一般语句以半角的分号 ; 结尾，例如：int x = a + b; 或者 x + y; 也是一条语句，虽然没有什么实际意义，但是不可否认他是一条语句。还有更为不可思议的单独一个半角分号 ; 他也是一条语句，只不过是一条空语句。例如：
int x = 5;;;

复合语句：把多条语句合成在一起，就是复合语句。那么如何来合成多条语句呢？可以用一对大括号 {} 来包装。例如：
{
    int x = 2;
    ++x;
}

2、输入与输出：
咱们之前的课程中给大家进行了相关变量值的输出，使用的是 cout，那么在C++中进行打印输出一般是用输入与输出流库  cin 和 cout 来实现的。
cin 和 cout 的定义是在 iostream 中，命名空间为 std，所以如果我们的程序中要使用 cin 和 cout 就必须要加上以下两条语句：
#include <iostream>
using namespace std;

在进行输入和输出的时候，我们经常使用 << 和 >> 符号。例如：cout << “ x+y = ” << 5 << endl;
<< 是流插入运算符；
>> 是流提取运算符；
所以，cout << “ x+y = ” << 5 << endl; 这句话的意思是将字符串 "x+y = " 先传递给 cout，即：流插入，之后再把 常量 5 插入到 cout，之后 endl 结束。大家可以把 << 和 >> 看成是流的方向，看往哪个方向流，这样能更好理解一些。
如果你要输出，那么肯定是要把字符串或者变量什么的传递给 cout 所以箭头要指向 cout，如果你要进行输入，那么就要从 cin 提取内容赋值给变量：例如：
int x = 0;
cin >> x;
从标准设备输入一个整形的值给变量 x，这个标准输入设备一般指键盘。执行到这句 cin >> x; 的时候程序会卡住，等待用户的输入，输入完成后继续往下走。cin 和 cout 的 >> 和 << 会智能的判断参数的类型，不管是整形还是字符型或者是字符串型，他都可以智能识别并进行输入与输出操作。

另外，注意，不管是 cin 也好，cout 也好，<< 和 >> 一次性只能输出或者输入一个，例如以下的写法是错误的：
cout << a, b, c;
cin >> a, b, c;

cin 的分隔符一般用回车(Enter)，下面演示给大家看！

备注：一般 C++   cin 和 cout 是适用于我们当前使用的控制台类型的工程，这样才能看到输入与输出的结果。以后大家接触到带界面的程序了，cin 和 cout 也就用不上了。

3、兼容C语言的输入与输出：
之前跟大家说过，C++ 本身兼容 C语言，所以C语言 输入与输出函数在C++仍然可以使用。例如：
getchar：字符输入函数
putchar：字符输出函数
scanf：输入
printf：输出

其中，scanf 和 printf 跟 C++   cin 和 cout 功能很类似，但是没有 cin 和 cout 智能。例如我用 printf 输出多个值，要这么写：
int x = 2;
int y = 3;
printf("%d + %d = %d", x, y, x+y);

printf  输出参数中要明确指定每个变量要输出的类型，%d 代表整形，%s 代表字符串，%c 代表字符型。而 cout 就不用，全部智能识别了。

可以这么说，本身大家以后编写控制台类型的程序就不多，另外，对于输入和输出这块也不用掌握的非常深入，所以C语言的 getchar、putchar、scanf、printf 之类的大家有时间就学学，没时间就先放弃也行。把 cin 和 cout 的一些基本的使用弄明白了就可以了。以后真要是有用到的地方再去现查就来得及。不用一开始就细致入微，本身刚开始接触编程有很多东西就不是很懂所以不要求深扣某个细节，可以先大体上把知识点过一遍，之后从头再过一遍，每一遍都比前一遍要细致一些要深入一些，每一遍都可以学到不同的东西。

附录：标准输入输出流控制符

## 十、if 语句实现关系运算
1、if 语句概述：

实际上 if 语句主要是判断参数给定的条件是否满足，满足执行语句1，不满足执行语句2。用我们现实 大白话来说就是：
如果。。。就。。。否则。。。一个程序不可能一条路走到底，肯定会遇到各种各样的问题。人做事儿也是一样，你今天去上班，如果等公交车等不到，那你可能就要打车了。
如果今天下雨了那么你就要带伞，如果没下雨就不用带。如果这家饭店人多我可以到别的饭店吃饭。各种判断在现实生活中也是比比皆是。

如果 张三的年龄超过18岁，那么张三就是成年人，否则张三就不是成年人。大概就是这么个意思。
转换成代码如下：
int zhangsan_age = 0;
cin >> zhangsan_age;
if (zhangsan_age >= 18)
    cout << "张三是成年人" << endl;
else
    cout << "张三不是成年人" << endl;
复制代码


2、if 语句的几种表现形式：

直接举例+语音说明：
①、
int zhangsan_age = 10;
if (zhangsan_age > 18)
{
        cout << "张三是成年人" << endl;
}
复制代码


如果只有一条语句，那么上面的代码也可以写成这样：
int zhangsan_age = 10;
if (zhangsan_age > 18) cout << "张三是成年人" << endl;
复制代码


花括号{}是用来把多条语句组合在一起的。

②、

int zhangsan_age = 10;
if (zhangsan_age > 18)
{
        cout << "张三是成年人" << endl;
}
else
{
        cout << "张三不是成年人" << endl;
}
复制代码

如果只有一条语句，那么上面的代码也可以写成这样：
int zhangsan_age = 10;
if (zhangsan_age > 18)
        cout << "张三是成年人" << endl;
else
        cout << "张三不是成年人" << endl;
复制代码


备注：为了防止不必要的错误出现，也为了便于阅读，建议大家即使有一条语句的话，也应该放到花括号 {} 中，这是一种良好的编程习惯。不然一不小心就容易犯错误。

③、
int zhangsan_age = 0;
cin >> zhangsan_age;

if (zhangsan_age < 1)
{
        cout << "张三是个婴儿" << endl;
}
else if (zhangsan_age < 3)
{
        cout << "张三是个幼儿" << endl;
}
else if (zhangsan_age < 5)
{
        cout << "张三是个儿童" << endl;
}
else if (zhangsan_age < 9)
{
        cout << "张三是个少年" << endl;
}
else if (zhangsan_age < 18)
{
        cout << "张三是个青年" << endl;
}
else if (zhangsan_age < 40)
{
        cout << "张三是个壮年" << endl;
}
else if (zhangsan_age < 55)
{
        cout << "张三是个中年人" << endl;
}
else
{
        cout << "张三是个老年人" << endl;
}
复制代码


3、if 语句的嵌套：

什么叫嵌套？嵌套就是一层套一层，举个例子：
int zhangsan_age = 0, zhangsan_sex = 0;
cin >> zhangsan_age >> zhangsan_sex;

if (zhangsan_age < 18)
{
        if (zhangsan_sex == 1)
        {
                cout << "张三是个男孩" << endl;
        }
        else if (zhangsan_sex == 2)
        {
                cout << "张三是个女孩" << endl;
        }
}
else if (zhangsan_age >= 18)
        if (zhangsan_sex == 1)
                cout << "张三是个男青年" << endl;
        else if (zhangsan_sex == 2)
                cout << "张三是个女青年" << endl;
复制代码


详情听语音讲解！

另外，上面的写法不建议，更建议使用下面的嵌套写法：
int zhangsan_age = 0, zhangsan_sex = 0;
cin >> zhangsan_age >> zhangsan_sex;

if (zhangsan_age < 18)
{
        if (zhangsan_sex == 1)
        {
                cout << "张三是个男孩" << endl;
        }
        else if (zhangsan_sex == 2)
        {
                cout << "张三是个女孩" << endl;
        }
}
else if (zhangsan_age >= 18)
{
        if (zhangsan_sex == 1)
        {
                cout << "张三是个男青年" << endl;
        }
        else if (zhangsan_sex == 2)
        {
                cout << "张三是个女青年" << endl;
        }
}
复制代码

都用花括号/大括号给封起来。

4、关系运算符：

实际上面在讲解 if 语句的时候已经把关系运算符给大家讲解完了。C++的关系运算符有：
①、< （小于）
②、<=（小于或等于）
③、> （大于）
④、>=（大于或等于）
⑤、==（等于）
⑥、!=（不等于）

备注：前四种关系运算符的优先级相等并且高于后两种，后两种的优先级也相等。
if (zhangsan_age == 18)
{
        cout << "张三今年正好18岁啦，是成年人啦！" << endl;
}
复制代码


备注：这个判断相不相等关系运算符是两个等于号 ==，很多新手经常会范错误，用一个等于号，大概是这样的：
if (zhangsan_age = 18)
{
        cout << "张三今年正好18岁啦，是成年人啦！" << endl;
}
复制代码


咱们演示一下看看这个 if 语句的执行结果是多少呢？

if (zhangsan_age != 18)
{
        cout << "张三今年不是18岁，多少岁呢？打印出来看看吧：" << zhangsan_age << endl;
}
复制代码


5、小作业：根据用户输入的数字：1-7，输出今天是星期几？输入1输出星期一，输入2输出星期二，以此类推。

## 十一、if 语句实现逻辑运算与冒号表达式 
1、逻辑运算概述：
为什么会有逻辑运算呢？举个例子，上节课的一段小代码：
int zhangsan_age = 0, zhangsan_sex = 0;
cin >> zhangsan_age >> zhangsan_sex;

if (zhangsan_age < 18)
{
        if (zhangsan_sex == 1)
        {
                cout << "张三是个男孩" << endl;
        }
}

即：要求年龄在 18 岁以下，性别是男性，两个条件都满足的前提下，才进行打印：张三是个男孩
又或者，我让你用 if 进行这个判断，判断 zhangsan_age 年龄在 1-18岁之间，看是否满足条件？怎么判断呢？
可以这样：
if (zhangsan_age >= 1)
{
        if (zhangsan_sex <= 18)
        {
                cout << "张三是个男孩" << endl;
        }
}

这样写很是麻烦，而且会嵌套了好几层，有没有更简便的写法呢？当然有了，就是使用逻辑运算符：
if (zhangsan_age >= 1 && zhangsan_sex <= 18)
{
        cout << "张三是个男孩" << endl;
}

简单吧？一个 if 就搞定了。

2、C++中提供了三种逻辑运算符：
①、&& 逻辑与 相当于其他语言  AND
②、||  逻辑或 相当于其他语言  OR
③、!   逻辑非 相当于其他语言  NOT

3、逻辑运算符的运算规则：a 和 b 是表达式
a && b 若 a 和 b 同时为真，a && b 的结果为真，只要有一个为假，则 a && b 的结果为假
a || b  若 a 或 b 其一为真，a || b 的结果为真，若 a 和 b 同时为假，则 a || b 的结果为假
!a       若 a 为真，则 !a 为假，若 a 为假，则 !a 的结果为真

int zhangsan_age = 0;
cin >> zhangsan_age;

if (zhangsan_age < 14 || zhangsan_age > 60)
{
        cout << "张三是个小孩或者老人，不能欺负他" << endl;
}

备注：咱们上面说了这么多真和假，一般逻辑表达式的值是一个逻辑的量 “真” 或 “假”。那么反应到我们程序代码中得到运算结果时，以数值 1 代表 “真”，数值 0 代表 “假”。一般更宽泛的做法是：数值 0 代表 “假”，非0都代表 “真”。

举几个例子：
若 int x = 5; 则 !x 的值就是0，因为 x 的值是5，非0，所以是真，!x 就是假了，也就是0了；
若 int x = 5, y = 4; 那么 x && y 的结果就是真，int z = x && y; 你会发现 z 的值是1；
若 int x = 5, y = 4; 那么 !x || y 的结果是多少呢？到底是先算逻辑非，还是先算逻辑或呢？这就涉及到他们的运算符优先级了。大家可以找下《实用C++》第8课的课程说明文档，我当时给大家打包了一个运算符优先级的图标，大家可以查一下C++ 三个逻辑运算符的优先级是怎么样的顺序呢？https://www.cctry.com/thread-278817-1-1.html

4、逻辑运算符的优先级：算是本节课的小作业，大家课后完成！

5、冒号表达式：
冒号表达式又叫条件表达式，是唯一一个三目运算符，就是需要三个参数的运算符。先举个 if 语句的例子，求出 变量 x 和 y 的最大值，并打印出来：
int max = 0;
int x = 0, y = 0;
cin >> x >> y;
if (x > y)
{
        max = x;
}
else
{
        max = y;
}

cout << "最大数是：" << max << endl;

求 x 和 y  较大数，我用了一个 if-else，那么有没有简单一点的方法呢？答案是当然有，就是要讲解的这个冒号表达式：
max = x > y ? x : y;
就这么一句话，就可以将 x 和 y 中较大的数的值赋值给 max 变量，怎么样，方便吧？

6、冒号表达式的规则：
表达式1 ? 表达式2 : 表达式3
若表达式1为真，则返回表达式2的值，若表达式1为假，则返回表达式3的值。如此而已！

## 十二、用switch语句实现多分支选择结构


1、为什么会有switch语句？
if-else语句只有两个分支，如果条件比较少的情况下可以使用if-else，可如果条件比较多，就会出现很多个 if-else if-else if-else-if 等。
这样会导致代码冗余，不易于阅读，同时如果条件很多的情况下效率也不高，因为系统要计算每一个if 表达式去进行比较。所以在条件比较多的情况下建议使用switch语句来解决。

2、switch语句的格式：
switch(表达式)
{
    case 常量表达式1:语句1
    break;
    case 常量表达式2:语句2
    break;
    case 常量表达式3:语句3
    break;
    ...
    case 常量表达式n:语句n
    break;
    default:语句n+1;
    break;
}

格式说明：
①、switch后面括号内的表达式必须是数值类型（包括字符类型）的数据，不能使用字符串；
②、如果switch表达式的值与某一个case子句 常量表达式的值匹配时，就执行此case子句 内嵌语句，如果所有的case常量表达式都不匹配，那么就执行default子句的内嵌语句；
③、每个case标签的常量表达式的值必须不能相同，否则会出现错误的情况，而且以当前vs2013的编译器来说编译也会不通过的；
④、每个case语句，包括default语句的顺序不影响结果，可以任意放置，比如把default放在上面也是一样的；
⑤、switch语句也是本着从上往下的顺序执行，可这个从上往下是以第一个case匹配到的常量表达式开始，往下执行。如果执行完一个case语句之后不想继续执行其他case语句可以使用break关键字跳出switch结构即可；

备注：详细的详解请下载视频教程观看！

3、switch语句的case标签中定义变量的问题：
不能直接在 case/default 的内嵌语句中定义局部变量，会报错的，大家不妨试试。如果真的需要定义的话，可以加上一对大括号，如下：
char ch = 'A';
switch(表达式)
{
    case 'A':cout << "case A reach." << endl;
    break;
    case 'B':
    {
        int a = 6;
        ++a;
    }
    break;
    default:
    break;
}

4、实例题目：
键盘输入0-6之间的整数，分别打印出代表每周的星期日、星期一、…、星期六，请使用switch语句来实现。同时，如果是周六和周日的话要打印出“今天是周末”的字符串。
#include <iostream>
using namespace std;

int main()
{
        cout << "请输入一个数字：" << endl;

        int num = 0;
        cin >> num;
    
        switch (num)
        {
        case 1:
                cout << "今天是星期一" << endl;
                break;
        case 2:
                cout << "今天是星期二" << endl;
                break;
        case 3:
                cout << "今天是星期三" << endl;
                break;
        case 4:
                cout << "今天是星期四" << endl;
                break;
        case 5:
                cout << "今天是星期五" << endl;
                break;
        default:
                cout << "今天是周末" << endl;
                break;
        }
        return 0;
}

## 十三、while 循环语句
1、为什么会有循环语句？
在现实的生活中有很多东西都需要反反复复的去做，比如流水线上的工人们做的工作，或者各种计算工作，比如计算 1~1000 之间的数的和，等等。本身编程就是为了更好更快的解决现实生活 问题，所以既然现实生活中有反反复复的工作，那么编程语言中也肯定要有能做反复循环的工作的语句才行。

顺序结构、选择结构、循环结构是结构化程序设计的三种最基本的结构。而且循环这个东西也是大家以后编程过程中经常会遇到的，所以循环这块也得好好学，多思考，多练习才行。

2、while 循环语句的格式：
while(表达式A)
语句B

其执行流程是：当表达式A的值为真（非0）时，执行下面的语句B（即循环体），否则不执行语句B。也就是先判断表达式A，后执行语句B。

备注：
①、语句B不限于一条语句，可以用 {} 括起来的多条语句，否则while语句循环体的范围只到while后面的第一个分号处结束；
②、在循环体的语句B中应有使循环趋于结束的语句，一定避免死循环现象的发生，这是个低级错误。

3、while 循环举例：
实现1~100之间数的累加，打印出结果：
#include <iostream>
using namespace std;

int main()
{
        int x = 1, sum = 0;
        while (x <= 100)
        {
                sum += x;
                ++x;
        }

        cout << "1~100的累加和 = " << sum << endl;
        return 0;
}
复制代码


4、举例分析死循环的情况：
当 while 循环体  ++x 语句不存在的情况下，会有什么问题发生呢？咱们具体来看视频演示吧！

5、do-while 循环语句的格式：
do
语句B
while(表达式A)

跟 while 循环的格式也是大同小异。但是跟 while 有个很重要的区别：先执行循环体语句B，之后再判断表达式A
所以，do-while 循环至少会执行一次循环体语句B，而 while 循环则可能一次都不执行循环体语句B，因为条件不满足。大家明白了吗？

6、do-while 循环举例：
用 do-while 循环同样实现1~100之间数的累加，打印出结果：
#include <iostream>
using namespace std;

int main()
{
        int x = 1, sum = 0;
        do
        {
                sum += x;
                ++x;
        } while (x <= 100);

        cout << "1~100的累加和 = " << sum << endl;
        return 0;
}
复制代码


7、小作业：
将两条循环体语句：
sum += x;
++x;
复制代码

改写成一条语句来实现 1~100之间数的累加，大家试试看看能做到吗？

## 十四、for循环语句及break和continue的作用
1、for循环语句概述：
C++中可以说最灵活的一个循环语句就是for了，跟while循环语句相比，for循环更加灵活方便。所以在程序开发的过程中大家以后会经常用到for循环。

2、for循环语句的格式：
for(表达式A; 表达式B; 表达式C)
语句X

注意：表达式A、B、C 之间的分割是分号; 不是逗号啊，不要犯错！

for循环语句的执行过程如下：
①、先求解表达式A；
②、求解表达式B，同时判断表达式B的结果，如果为假则直接跳出for循环，如果为真则执行循环体语句X；
③、求解表达式C；
④、再次执行步骤②；
⑤、再次执行步骤③；
⑥、以此类推。。。

备注：
表达式A只执行了一次，所以表达式A又叫做循环变量赋初值的初始化表达式；
表达式B即作为循环条件，或者说循环中止的条件表达式；
表达式C一般用作循环变量的增值或者累加的表达式；
循环体语句X可以是一条普通的语句，也可以是多条语句，这种时候就得用一对{}括起来。

3、for循环举例：
用for循环实现1~100之间数的累加，打印出结果：
#include <iostream>
using namespace std;

int main()
{
        int x = 1, sum = 0;
        for (int x = 1; x <= 100; ++x)
        {
                sum += x;
        }

        cout << "1~100的累加和 = " << sum << endl;
        return 0;
}

4、for语句的灵活所在：省略各个表达式
for语句之所以灵活，是因为他有三个表达式灵活存在。同时呢，这三个表达式又可以根据实际需要进行省略处理，不过分号不能省略啊！
①、省略初始化表达式A，那么就要求循环的控制变量在别的地方初始化：
int x = 1, sum = 0;
for (; x <= 100; ++x)
{
        sum += x;
}

②、省略循环变量的自增表达式C，那么就要求在别的地方对循环变量进行相关操作：
int x = 1, sum = 0;
for (; x <= 100; )
{
        sum += x;
        ++x;
}

③、表达式A和C都可以省略掉，那么作为循环条件的表达式B能否也省略呢？答案是可以的！
int x = 1, sum = 0;
for (; ;)
{
        sum += x;
        ++x;
        if(x > 100) break;
}

5、用 break 语句提前结束循环过程并跳出：
之前给大家讲解 switch-case语句的时候，跟大家说过，break可以跳出当前的switch-case语句结构。同理break语句也可以使用在循环语句中，使用之后直接提前跳出当前的循环过程。

6、用 continue 语句提前结束本次循环：
continue 语句一般用于循环语句中，作用是提前结束本次循环，即跳过循环体语句中X中尚未执行的语句，直接进行下一次的循环。

7、举例实现求出100~200之间的素数并打印出来：
#include <iostream>
using namespace std;

int main()
{
        cout << "100~200之间的素数如下：" << endl;

        int x = 0;
        for (x = 100; x <= 200; ++x)
        {
                int y = 2;
                for (y = 2; y < x / 2; ++y)
                {
                        if (x % y == 0)
                        {
                                break;
                        }
                }
    
                if (y < x / 2) continue;
    
                cout << x << endl;
        }
    
        cout << endl;
        return 0;
}

## 十五、期中知识总结
1、为什么有总结？
之前给大家也算讲解了不少知识点了，包括：
数据类型、常量、变量、表达式、关系运算、逻辑运算、if条件判断、switich-catch多分支选择、以及 while、do-while、for 等循环语句。学了这么多不知道大家掌握的怎么样，有没有在课后进行相关的代码编写联系。编程这个东西光听懂了不行，还得进行非常多的动手实践才行，不然当时觉得听懂了，过段时间就忘了，想要写代码的时候还是不知道怎么写，这就是很明显的眼高手低现象。所以大家课后一定要多动手联系才行。

2、给大家出两个小题目：
大家可以在课前先预习一下，看看不上网找任何资料的前提下能不能把答案写出来，一定要多动手动脑！

3、题目1：水仙花数
输出所有的“水仙花数”，什么是水仙花数呢？所谓的水仙花数就是指一个3位数，其各个位数字的立方和等于该数本身。立方大家都知道吧，比如2的立方就是 2x2x2=8。例如：153就是一个水仙花数，因为：
1的立方=1x1x1=1
5的立方=5x5x5=125
3的立方=3x3x3=27

他们的和就是：1+125+27=153
大家明白了吗？先自己动手实现一下啊！

题目1具体代码及分析过程讲解见视频教程！

4、题目2：打印星号图案
输出以下图案：
*
***
*****
*******
*****
***
*

题目2具体代码及分析过程讲解见视频教程！

5、课后作业：
题目3：有一个分数序列如下，求这个分数序列的和：
2/1,3/2,5/3,8/5,13/8,21/13,...
有什么规律呢？下一个数的分子是前一个数的分子+分母的和！

## 十六、函数简介
1、什么是函数？
咱们先看看函数的原英文意思，function，翻译过来就是功能的意思，所以函数也就是功能。也就是说一个函数肯定会实现或者完成某个功能，所以大家以后对函数起名字的时候最好起一个能表达该函数功能的名字。所以一个程序可能会包含多个函数来实现多个功能。编写程序的过程也可以简单理解为写N多个函数的过程。

2、为什么要有函数？
①、每个程序都必须至少有一个函数，咱们之前的 HelloWorld 程序就有一个主入口函数 main 对吧？大家也都看到了。
②、我们之前的代码相对来说比较简单，所以都写在了 main 函数中，如果程序的功能以后越来越多，那么就不可能把所有的代码都写到main函数中，这时候就可以按照功能来写一个一个的函数了，之后调用。
③、如果程序的功能很多，比如在公司的项目中，由多个人来共同完成一个项目，那么就可以把这个项目拆分开，每个人负责几个功能函数，写好了之后再组合到一块，方便协同开发。

等等吧，可能还有很多其他的原因。总之函数在编程开发的过程中是一定要学会的，不仅 C/C++ 语言中有，其他各种各样的语言中几乎都有函数，也都需要开发人员去编写函数。

3、函数的分类：系统函数、用户自己定义的函数
系统函数是编译器提供好的C/C++的标准库函数，例如：printf、malloc、free、sqrt 等等。
用户自己定义的函数是指在实际的软件开发过程中，用户根据自己的情况，将部分功能封装成一个函数，供其他地方调用。

4、定义函数的形式：
返回类型 函数名(形式参数表列)
{
    声明部分;
    执行语句;
}

例如：
void print_msg() //没有参数，没有返回值
{
    cout<<"hello world." << endl;
}

int add(int x, int y) //有两个参数，有返回值
{
    return x+y;
}
复制代码


5、函数的简单调用：
#include <iostream>
using namespace std;

int add(int x, int y)
{
        return x + y;
}

int main()
{
        int sum = add(2,5);
        cout << "sum = " << sum << endl;
        return 0;
}
复制代码


6、形参与实参：
在上面的例子中 add 函数的参数 int x, int y 就是形式参数，简称形参，又叫虚拟参数，因为函数调用之前他们并没有申请任何内存；
而在调用 add 函数的实际参数 2 和 5 就是实际参数；
形参大家可以理解为是一个模具，你给我传什么我就用什么。实参可以理解为往模具里面添加的真实东西；
实参可以是常量、变量，也可以表达式，例如：
int a = 5, b = 6;
int sum = add(2, a*b);
复制代码


注意①：调用函数时实参应尽量与形参的类型一致，或可进行相应的转化，如果转化不了则编译器就会报错！
例如：
int sum = add(2.5, 3.62); //是可以的
char c = 2;
int sum = add(2.2, c); //也是可以的
int sum = add(2.2, "abc"); //不可以
复制代码

编译器没办法把字符串 "abc" 转成数值类型的整型！

注意②：实参对形参的数据传递是以“值传递”的方式进行传递的。单向的，只能由实参传递给形参，不能由形参传递给形参。
举个例子：
#include <iostream>
using namespace std;

int add(int x, int y)
{
        x = 3;
        y = 8;
        return x + y;
}

int main()
{
        int a = 2, b = 5;
        int sum = add(a, b);
        cout << "sum = " << sum << endl;
        cout << "a = " << a << endl;
        cout << "b = " << b << endl;
        return 0;
}
## 十七、函数的返回值及几种调用方式
1、函数的返回值：
一般情况下，通过函数的调用，使调用函数可以获得被调用函数的函数值，这个值就叫做返回值。
注意事项：
①、有的函数有返回值，有的函数没有返回值，具体看函数的声明类型，如果返回值类型为 void 则为无返回值类型；
②、函数的返回值是通过函数  return 语句获得的。一个函数中可以有一个以上的return语句，执行到哪个return就从哪个return返回了，return语句执行完之后，他之后的代码不会被执行；
③、函数内部的return返回值类型要与函数本身定义时候的返回值类型一致，即使不一致也是可以相互转化的，最终以函数定义时候的返回值类型为主进行转化，若转化不了则编译期间就报错了；
④、原则上一个函数只能有一个返回值，若要返回多个值则可以通过参数返回或者返回结构类型等等，这个以后会具体讲解的，大家先不要着急。

2、函数的声明与定义：
①、什么是函数的声明？
函数的声明就是告诉系统，或者告诉编译器，某个函数的“样子”，这个样子就是函数的基本信息，包括：函数的名字、有几个参数，每个参数的类型，函数的返回值类型等等。目的就是为了让编译器知道函数的信息，好让编译通过。
举个例子：你要帮张三购买火车票，拿着张三的身份证到火车站去买，售票员看到张三的身份证之后就知道有张三这么个人，身份证号是多少多少，于是对张三有个大概的了解了，可以给张三订票，出票！其实这个身份证就相当于函数声明的意思，有了这个身份证就可以对张三有个大概的了解了。函数的声明形式如下：例如：
int add(int x, int y); //注意结尾的分号，不可少

②、什么是函数的定义/实现？
函数的定义就是函数真正的实现，也就是函数实现的真正代码，例如：
int add(int x, int y)
{
        return x + y;
}
复制代码


函数的定义比声明更具体，不仅仅包含了函数的名字，各个参数的类型，还包括函数的返回值，最重要的是有函数体，即函数的实现。这个是作为编译器链接用的。函数的定义才是一个完整的、独立的单位。

举个例子：
咱们之前的代码是这么写的：
#include <iostream>
using namespace std;

int add(int x, int y)
{
        return x + y;
}

int main()
{
        int a = 2, b = 5;
        int sum = add(a, b);
        cout << "sum = " << sum << endl;
        return 0;
}
复制代码


那我要是把 add 和 main 函数的位置颠倒一下呢？会有什么问题发生，下面我演示给大家看！
visual studio 2013 编译器直接报错了：error C3861: “add”:  找不到标识符

add 函数我明明写在那了为什么还告诉我找不到呢？其实这就是编译顺序的问题。且听我语音讲解细细道来！
如何解决呢？答案就是加上前置声明！

3、函数的几种调用方式：
①、普通语句调用：
②、表达式调用：
③、函数参数调用：
④、嵌套调用：
函数的嵌套调用意思就是：函数a调用了函数b，函数b又调用了函数c...就这样一层一层的调用下去！

注意：函数可以嵌套调用，但是不可以嵌套定义！
这样是不行的，编译器直接报错了，在其他类似 js 的脚本语言中可以这样，但是在 C/C++ 中不允许函数的嵌套定义，只允许嵌套调用。
备注：新版本C++已经允许了，老版本的C++语法标准还不支持哦！

⑤、递归调用：
在调用一个函数的过程中又出现或者有需要直接或间接的调用该函数本身，即自己调用自己，这样的情况称作函数的递归调用，在C/C++语言中是允许的。但要注意不能无限递归，那样的话就类似死循环了，应该竭力避免，必须要有最终能跳出递归的条件。
什么情况下需要这种函数的递归调用呢？一般是为了解决那种条件相同或类似的一环套一环的问题。举个例子：
教室里一排共计10个人，问第10个人几岁了，他说我比第9个人大两岁，问第9个人几岁了，他说我比第8个人大两岁，问第8个人几岁了，他说我比第7个人大两岁，问第7个人几岁了，他说我比第6个人大两岁，问第6个人几岁了，他说我比第5个人大两岁，问第5个人几岁了，他说我比第4个人大两岁，问第4个人几岁了，他说我比第3个人大两岁，问第3个人几岁了，他说我比第2个人大两岁，问第2个人几岁了，他说我比第1个人大两岁，问第1个人几岁了，他说我今年10岁了（这个就是最终跳出递归的条件）。问题是：问第10个人几岁了？

## 十八、局部变量和全局变量 
1、什么是局部变量，什么是全局变量？
举个例子：张三是张三村的村长，李四是李四村的村长，那么张三村的村民有什么事儿都可以去找张三村，张三也对该存有管辖权，对吧？李四呢，自然李四村的村民都能找到李四这个村长了。反过来，你让李四村的村民去找张三村的村长来解决问题那肯定是不行的，不是一个村子，自然不能相互公用了。那么这时候呢如果出来个王五镇长，那么就方便多了。张三村和李四村的村民都可以直接找王五镇长办事儿。

所以这里面的张三、张三村的村民、李四、李四村的村民都算是局部变量，只能在自己的范围内或者说作用域内活动，那么王五镇长呢，他就算是个全局变量，张三村和李四村的村民都可以访问。处在一个全局的位置。

不知道通过这个形象的比喻大家对于局部变量和全局变量的总体上是否有个大概的了解。下面具体用代码的方式来说下！

2、代码方式讲解局部变量与全局变量：
#include <iostream>
using namespace std;

int sum = 0;
int add(int a, int b)
{
        int ret = a+b;
        return ret;
}

int main()
{
        int x = 2, y = 5;
        sum = add(x, y);
        cout << "sum = " << sum << endl;
        return 0;
}

这里面的 x 和 y 是局部变量，ret 呢也是局部变量，a 和 b 也算是 局部变量。都是局部变量，那么全局变量呢？是谁？没错，相信大家都已经猜到了，就是 sum，他的定义既没有在 main 函数中，也没有在 add 函数中，处在一个全局的位置。在 add 函数中可以访问，在 main 函数中也可以访问，并且都可以改变这个全局变量 sum 的值。

注意点：
①、函数内部定义的局部变量也只能在该函数中使用，其他的函数无法调用，例如：main 函数  x 和 y 在 add 函数是无法访问的。add函数  ret 在 main 函数中也是无法访问的；
②、不同函数或者作用域内可以定义相同名字的局部变量名字，虽然名字相同，但都是不同的个体，互不影响，彼此独立；
③、一般局部变量的作用域就在他所在的一对花括号内，函数的形参作用域也在其函数的整个作用域内，也是局部变量；
int x = 2, y = 5;
sum = add(x, y);
if (sum > 5)
{
        int k = 10;
        ++k;
}
这里面的变量 k 就是一个局部变量，他的作用域也只局限于 if 的 {} 花括号内。
④、全局变量的定义要尽量靠上，不然在他上面的函数使用不了，因为本身编译器编译代码的顺序就是自上向下。

3、多文件共同访问一个全局变量：
方法（回复帖子后可见）：
①、在其中一个C/Cpp文件中定义并初始化全局变量，例如：
int sum = 0;
②、在C/Cpp文件都能访问到的一个h头文件中声明该全局变量为支持多文件访问的：
extern int sum; //此时只是声明，所以不需要初始化
③、在其他C/Cpp文件中 #include 这个头文件之后，就可以直接使用这个全局变量 sum 了。

备注：不能在 h 文件中直接定义这个全局变量 int sum = 0; 之前看到很多网友都是这么做的，这样的话如果有多个C/Cpp文件 include 包含这个头文件的时候就会提示 sum 重复定义了。所以一定要在 C/Cpp文件中定义该全局变量，之后在 h 头文件中声明该全局变量才行哦。

4、static 静态类型变量：
#include <iostream>
using namespace std;

int sum = 0;
int add(int a, int b)
{
        static int num = 1;
        int ret = a+b;
        ret += num;
        ++num;
        return ret;
}

int main()
{
        int x = 2, y = 5;
        sum = add(x, y);
        cout << "sum = " << sum << endl;

        sum = add(x, y);
        cout << "sum = " << sum << endl;
    
        sum = add(x, y);
        cout << "sum = " << sum << endl;
        return 0;
}

## 十九、数组与一维数组
1、为什么要有数组？
通俗的说数组就是同类型的一群数据，定义一个数组，就是定义一群数据。例如，某个班有60个学生，定义变量来表示每个学生的学号，第一名是101号，第二名是102号，以此类推。
如果按照之前的做法，那么恐怕就要定义60个变量了，大概如下：
int stu_1_no = 101;
int stu_2_no = 102;
int stu_3_no = 103;
...
int stu_60_no = 160;
那么如果说要表示全校1000名学生的学号呢？难道要定义1000个变量不成？肯定是不行的，太多了也没办法定义。所以在C++中提出了数组这个东西。之前说过定义一个数组，就是定义一群数据。所以大概的定义如下：
int stu_no[60];
这样一定义之后，就一下子定义了60个int类型的变量，他们统一放在一个数组里面，stu_no 就是数组的名字，访问数组里面的每个元素必须通过这个名字来访问。

2、如何定义数组？
上面已经粗略的给大家定义了一个学号的数组：int stu_no[60];
其中 int 就是这个数组中所有元素的类型，stu_no 就是数组的名字，以后访问数组中任何一个元素都得靠他，60就是这个数组中元素的个数。
所以数组的基本定义格式如下：
类型名 数组名[常量表达式];

注意，中括号内部的常量表达式用以表示数组中元素的个数，这个必须是个常量或常量表达式，不能是个变量或者一个不确定的值，不然编译阶段就直接报错了。因为定义好了之后，系统马上就根据这个个数来分配空间了。如果是个变量，系统就不知道要分配多少空间。

数组名字的命名规则跟变量是一样的，只能使用数字、字母、下划线，而且数字不能做开头。

3、如何访问数组 元素：
数组必须先定义之后再使用，需要通过下标来访问，具体的访问格式如下：
数组名[元素下标];
这个元素的下标是从0开始的，范围是0~个数-1，例如：int stu_no[60]; 那么下标就是 0~59，大家明白了吗？
备注：这个下标可以是常量也可以是变量，但必须在规定的范围内访问，不然会出现访问越界，导致程序崩溃的重大低级问题。

4、一维数组的初始化：
①、在定义数组的时候就对数组的全部元素初始化：
int stu_no[5] = {101, 102, 103, 104, 105};

②、在定义数组的时候对部分元素进行初始化：
int stu_no[5] = {101, 102};
后面未初始化的默认赋初值0

③、在定义数组的时候就对数组的全部元素初始化，可以不指定数组长度：
int stu_no[] = {101, 102, 103, 104, 105};

不管是定义的时候指定长度还是不指定长度，总结起来就一个规则，定义的时候让系统知道数组的长度就可以了，也就是定义即确定大小。

5、一维数组代码举例：
一整形数组中有10个数，分别是：5,8,9,0,2,1,4,7,6,3；
求出数组中最大和最小的数并进行输出。

6、小作业：
对第5点的数组进行排序，并输出排序后的数组内容。

## 二十、字符数组

1、什么是字符数组？
说白了，字符数组就是数组中存放的是字符，即 char 类型。例如：char szbuf[50];
因为字符串本身就是有一个一个的字符组合而成的，所以，字符数组可以理解为是一个字符串。在以后的C++编程过程中会遇到各种各样对字符串的操作。

2、字符数组的初始化：
方式①：定义之后分别对每个字符初始化；
char szbuf[10];
szbuf[0] = 'h';
szbuf[1] = 'e';
szbuf[2] = 'l';
szbuf[3] = 'l';
szbuf[4] = 'o';
复制代码

备注：未初始化的部分值随机。

方式②：定义即初始化：
char szbuf[10] = {'h', 'e', 'l', 'l', 'o'};
复制代码

或者：
char szbuf[10] = "hello";
复制代码

备注：未初始化的部分值为0.

注意：
如果初始值的个数小于数组的长度，则只将这些字符赋值给数组中前面的那些元素，其余元素自动赋值为 \0 字符，也就是0；
如果初始值的个数大于数组的长度，则直接报语法错误。

方式③、自动初始化长度：
char szbuf[] = {'h', 'e', 'l', 'l', 'o', ' ', 'f', 'r', 'i', 'e', 'n', 'd', 's', ' ', 'I', ' ', 'a', 'm', ' ', 'c', 'c', 't', 'r', 'y', '.', 'c', 'o', 'm'};
复制代码

如果字符串的长度比较长，而且要定义的数组长度就是字符串的长度，那么就可以使用此方法。

或者：
char szbuf[] = "hello friends I am cctry.com";
复制代码


3、字符数组与字符串的区别：
区别就是字符串比字符数组多了一个结束标志的字符：'\0'，这个字符的ASCII码就是0，所以作为一个字符串来说，其有效字符就是结束标志\0之前的字符。字符串的长度也是结束标志\0之前的字符，但是字符串所占用的字节数或者说字符串所占用的空间是包含字符串结束标志\0的。所以一般情况下关于一个字符串的长度不用很显示的给出或者告诉，直接对当前字符串从头往后找结束标志\0就可以了，遇到了就表示这个字符串结束了。
例如：
char szbuf[5];
szbuf[0] = 'h';
szbuf[1] = 'e';
szbuf[2] = 'l';
szbuf[3] = 'l';
szbuf[4] = 'o';
复制代码

这个就是个字符数组，不是字符串，因为结尾没有字符串结束的标志\0，但是如果我这样定义：
char szbuf[6];
szbuf[0] = 'h';
szbuf[1] = 'e';
szbuf[2] = 'l';
szbuf[3] = 'l';
szbuf[4] = 'o';
szbuf[5] = '\0';
复制代码

这个字符数组就可以看成是一个字符串，因为他满足字符串的所有条件。

再来看一个例子：定义即初始化：
char szbuf[10] = {'h', 'e', 'l', 'l', 'o'};
复制代码

因为数组的长度是10，hello5个字符的长度是5，所以之后剩下的5个未被初始化的字符会置为0，所以这种方式满足字符串的条件。
或者：
char szbuf[10] = "hello";
复制代码

这种方式使用一个字符串来初始化字符数组，因为用字符串来进行初始化，所以会把字符串结束标志\0一并初始化给字符数组szbuf的，所以这种方式也满足字符串的条件。

4、字符数组的输入与输出：
举例①：
char szbuf[50];
cin >> szbuf;
cout << szbuf << endl;
复制代码


举例②、
char szbuf[50] = {'h', 'e', 'l', 'l', 'o', '\0', ' ', 'f', 'r', 'i', 'e', 'n', 'd', 's', '.'};
cout << szbuf << endl;
复制代码

大家猜猜会输出什么内容呢？

5、小作业：
题目：字符数组定义如下：
char szbuf[100] = "hello, friends, my name is cctry.com. what is your name ?";
复制代码

遍历字符数组 szbuf，将其 字符 i 替换成 @ 符号，并统计其个数。最后将统计的个数及整个字符串的内容都输出出来？
大家试试吧！

## 二十一、使用字符串处理函数操作字符数组
1、目的：
之前也跟大家说过字符串在以后的编程过程中会非常频繁的用到，所以C/C++语言为了提升开发效率，本身提供了很多对字符串进行操作的函数，不用大家自己再实现。他们已经成为C/C++的标准，所以任何一个支持C/C++标准的编译器都支持这些函数的。他们被包含在 string.h 或 string 头文件中。所以要在代码中添加：
#include <string.h> //C语法
或者
#include <string> //C++语法

2、字符串连接函数：strcat
该函数的定义原型为：
char * strcat (char destination[], const char source[]);
相关的说明在这里：http://www.cplusplus.com/reference/cstring/strcat/
其作用就是将第二个参数的字符串连接到第一个参数的字符串结尾，所以要保证第一个参数的字符数组大小够用，能装的下第1个和第2个字符串的总长度才行，不然就会发生内存溢出啦！
返回值是第一个字符串的首地址，关于地址这个话题在下几节课会给大家讲解的。

代码举例：
char des[50] = "hello "; //保证des的空间足够大
char src[] = "cctry.com";
strcat(des, src);
cout << "des = " << des << endl;

问大家个问题，这里面des字符数组的大小最小能定义成多少？15？16？17？为什么呢？

3、字符串拷贝函数：strcpy
该函数的定义原型为：
char * strcpy( char destination[], const char source[]);
相关的说明在这里：http://www.cplusplus.com/reference/cstring/strcpy/
其作用就是将第2个参数的字符串拷贝到第一个参数的字符数组中，所以要保证第1个参数的字符数组大小够用。注意：第2个参数的结束符 '\0' 也会拷贝过去哦。
返回值是第一个字符串的首地址，关于地址这个话题在下几节课会给大家讲解的。

代码举例：
char des[50] = {0};
char src[] = "cctry.com";
strcpy(des, src);
cout << "des = " << des << endl;
问大家个问题，这里面des字符数组的大小最小能定义成多少？为什么呢？

4、字符串比较函数：strcmp
该函数的定义原型为：
int strcmp (const char str1[], const char str2[]);
相关的说明在这里：http://www.cplusplus.com/reference/cstring/strcmp/
其作用就是对比第1个和第2个参数的字符数组字符串，逐个字母比对，直到字符串结束。即比较每个字母的ASCII码值。
当第1个参数大于第2个参数，返回 > 0 的数，当第1个参数小于第2个参数，返回 < 0 的数，当第1个参数和第2个参数相等，返回0

代码举例：
char des[50] = "hello";
char src[] = "cctry.com";
int iret = strcmp(des, src);
cout << "iret = " << iret << endl;

5、字符串求长度函数：strlen
该函数的定义原型为：
size_t strlen (const char str[]);
相关说明在这里：http://www.cplusplus.com/reference/cstring/strlen/
其作用就是求得参数字符串的长度，通过返回值返回。

代码举例：
char des[50] = "hello";
int len = strlen(des);
cout << "len = " << len << endl;

这里面 len 的值是5，而不是50，为什么呢？50是des中总共能容得下的字符的个数，而不是实际字符串的长度。
所以这里面一个字符串占用的字节数和字符串的长度是两个不同的概念。

6、字符串的长度和占用字节数的区别：
char des[50] = "hello";
这个字符数组里面存的是一个字符串 hello，那么这个des字符数组所包含的字符串长度是：strlen(des)
那么，这个字符数组所占用的字节数呢？怎么求？sizeof(des)

int des[50];
sizeof(des) = ?

7、小作业：
不用系统提供的strcat函数，自己使用字符数组编写一个函数，实现两个字符串的连接功能。

## 二十二、地址与指针
1、什么是地址？
我们在程序中定义的任何变量实际上都是存在内存 ，对吧？那么既然是存在的东西就应该有装他的地方。举个例子，小明家，肯定有小明家的地址，张三家也应该有张三家的地址。再来说一个，比如说谁家都有电视机，对吧，那么我问你电视机在哪里？你肯定会说在客厅的墙上挂着，不管在哪，电视机肯定在他的位置摆放着呢，换句话说电视机也有他自己的地址。所以变量的地址也是一个意思，就是这个变量真正存在哪，在哪里！这就是变量的地址。
下面我们用代码举个例子，例如定义一个字符：
char ch = 'a';
我们用vs的监视窗口来看下字符 ch 的地址是多少呢？他在内存中又是如何来展现的呢？具体看视频教程演示！
那么在使用 cout << ch; 进行输出的时候，cout 也会去从 ch 的地址开始读取一个字符，之后打印输出出来。

好了，通过上面的讲解大家应该大概了解了什么是变量的地址。

2、什么是指针？
变量的地址一般都是比较难记的，例如：0x007f2eab 之类的，那么能不能用专门的一个东西，或者说一种特殊类型的变量来保存这个地址呢？
答案当然是可以的，这个特殊类型的变量就是指针。那么接下来就教大家如何定义指针：
例如：
char* p; //定义什么类型的指针，就在类型的后面加上一个*，代表是指针类型变量的意思。
这样就定义了一个指向char类型变量的指针，但是他没有指向任何变量的地址。接下来我们给他赋值一下：
p = &ch;
这样我们就将指针p指向了字符ch的地址。

备注：为什么指针变量的命名一般总带着一个字母p，因为指针的英文单词是pointer，所以简写就是p

那么我们换一下：
int a = 5;
int* pa = &a;
这里面我们就将一个int类型的指针pa指向了int类型变量a的地址。&符号是取地址符号，&a 就是取变量a的地址。
这么这样解释一下：
变量a的值或者说a的内容是5，变量a的地址是 &a
指针pa他也是一个变量，只不过是一个指针类型的变量，所以指针变量pa的值或者说内容就是 &a，指针变量pa的地址是 &pa
也就是说指针变量也是变量，他也有内容和地址。之前给大家讲解的其他类型变量的值或者说内容都是反应自身的。但是指针变量里面的值或者内容是反应其他变量的。

3、变量与指针：
在C/C++语言中可以通过取地址符号&得到变量的地址，例如：
int a = 5;
int* pa = &a;

那么，通过变量的地址，能否得到变量自身呢？答案是可以的！
int a = 5;
int* pa = &a;
*pa = 6;
即：在指针变量的前面加上一个*就能得到指针指向的变量自身。
所以对一个变量的修改，既可以通过该变量自身（直接修改），也可以通过指针/地址来实现修改（间接修改）。

4、指针变量的定义及初始化：
①、指针变量的定义格式如下：基类型 * 指针变量名;
②、符号* 既可以靠近基类型，也可以靠近指针变量名，例如：
int* p; 和 int *p; 都是正确的。
③、指针变量可以在定义的时候就初始化，也可以先定义后初始化，也可以在以后的任意一个时间去指向某个变量的地址：
int a = 5;
int *pa;
pa = &a;
int *pb = &a;

④、基类型就是该指针变量指向的变量的类型。例如:
int* pa; 这个指针变量的定义，就是定义了一个指向int类型的指针变量pa；你就不能把一个float类型的变量地址赋给他。例如：
int* pa;
float a = 2.6;
pa = &a;
这种写法是错误的。
⑤、指针变量可以指向同一类型的变量，例如：
int a = 5, b = 6;
int *p = &a;
p = &b;
即：指针变量p既可以指向变量a的地址，也可以指向变量b的地址。

5、定义一个函数，实现交换两个参数的值：
例如这样定义可以吗？
void swap(int a, int b)
{
    int t = a;
    a = b;
    b = t;
}
大家可以试试，看看这么写能否正常的交换参数 a 和 b 的值呢？
应该这样定义才对：
void swap(int* pa, int* pb)
{
    int t = *pa;
    *a = *b;
    *b = t;
}

6、小作业：
实现一个函数，作用是获取一个数组 最大值和最小值，函数声明如下：
void get_min_max(int src[], int* max_v, int* min_v)
{
    //函数代码写在这个下面
}

备注：关于野指针以及new申请内存的知识点，在以后的课程中会给大家讲解！

## 二十三、数组与指针
1、必要性：
指针这个东西以后真的是非常常用，所以这里再给大家讲解一下数组和指针的关系，以后也会经常用到啊，所以大家要用心学习！

2、数组元素的地址：
之前给大家讲解了每个变量都有地址，平时如果我们定义了一个变量之后可以用指针保存其地址，如下：
int a = 5;
int* pa = &a;
但如果是数组呢？大家肯定会说数组也是变量，数组 每个元素也有地址，没错，确实是这样。但是如果一个数组中有上百上千个元素，我要得到每个数组元素的地址，用指针来保存，怎么办呢？
数组中有100个元素你就要定义100个指针，数组中有1000个元素你就要定义1000个元素。不会吧，这么麻烦？有的会员比较聪明，想到了，我可不可以也定义一个指针的数组，用来保存之前那个数组的所有元素的地址呢，答案当然是可以的，如下：
int num[100] = {0};
int* p_num[100] = {0};
for(int idx = 0; idx < 100; ++idx)
{
    p_num[idx] = &num[idx];
}

以上代码行不行？肯定是可以的，但是你不感觉麻烦吗？定义一个数组就要再定义一个指针的数组，而且还要调用循环来初始化给指针赋值，太麻烦了吧，有没有简单的办法呢？

3、数组名字就是数组的首地址：
①、为了避免上面说的情况，C/C++中规定数组名字就是数组的首地址。注意，是数组的首地址，也就是数组的第0个元素的地址，即：
int num[100] = {0};
int* pnum = &num[0];
这里的 num 和 pnum 的值应该是一样的，具体在vs中给大家看下， 具体看视频教程演示！

②、C/C++中规定如果指针变量p已经指向数组 一个元素，则p+1指向同一数组 下一个元素的地址（而不是将p的值简单+1），p-1同理。
int num[100] = {0};
int* pnum_0 = &num[0];
int* pnum_1 = &num[1];
pnum_0 += 1;
执行以上代码之后，这里面pnum_0的值应该和pnum_1的值是相等的。

③、所以，根据以上，针对一个数组我们只需要用数组的名字就可以得到数组 任何一个数组元素的地址了，很方便吧？
int num[100] = {0};
那么这里面 num 就是 num[0]的地址了，即为：&num[0]，那么有的会员会说 num += 1，就应该是 num[1]元素的地址了吧。大家把这句放到代码中看看能过吗？
实际上有很多初学者都遇到这个问题了，比如有个网友这几天刚发的帖子：https://www.cctry.com/thread-289301-1-1.html
答案是不行的，数组的名字确实是数组的首地址，可以把他理解为一个指针，但是这个指针是：int * const 类型的，也就是说不能改变其指向的地址。也就是说不能动是固定的。那怎么办呢，不是白费了吗？
没关系，我们可以再定义一个指针，如下：
int num[100] = {0};
int* pnum = num;
这里的 pnum 是可以移动的，所以就可以指向数组num 任意一个元素喽！例如遍历一个数组：
int num[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int* pnum = num;
for(int idx = 0; idx < 10; ++idx)
{
    cout << *(pnum+idx) << endl;
}

④、访问数组的两种方法：
下标法：num[0];
指针法：*(pnum+idx)

4、用指针操作字符串数组：
定义两个字符数组输入如下：
char str1[50] = {0}, str2[] = "I Love cctry.com!";
用指针的方式，实现将 str2 拷贝到 str1 中。
具体代码见：视频教程！

5、小作业：
输入一个字符串，例如：
a123x456__17960?302ab5876
将其中连续的数字作为一个整数，依次存放到一个数组中a中，例如：123放在a[0]中，456放在a[1]中。统计共有多少个整数，并输出这些整数。

## 二十四、结构体类型
1、自定义数据类型：
C/C++语言本身提供了很多基本数据类型，例如：int、float、char 等供我们使用。但是程序编写的过程中问题往往比较复杂，基本的数据类型有时候不能满足我们的需求，所以C/C++语言允许开发者根据自己的需要自定义数据类型，接下来要讲解的结构体struct、联合体union、枚举类型enum，类类型class 等就是用户自定义的数据类型。这些用户自定义的数据类型跟C/C++语言提供的基本类型一样，都可以用来定义变量。只不过在这些自定义数据类型在使用之前要先由用户声明出来才行。

2、定义结构体的必要性：
之前有给大家举过学生的例子，这里接着来说下。例如一个学生的信息包括：姓名，学号，性别，年龄 等等。按照我们之前的做法，可以使用数组来定义：
string name[100]; //姓名
int num[100]; //学号
char sex[100]; //性别
int age[100]; //年龄
这样虽然也能满足需求，但是比较麻烦，如果想获得一个学生的信息需要从4个数组中分别找到该学生的所有信息，而且没有什么关联性，容易乱，能不能把一个学生的信息都统一到一起呢？把他们当做一个组合项，在一个组合项中包含若干个类型的数据项。C/C++语言允许用户自己定义这样的数据类型，这样的类型就称作结构体。
例如：
struct Student
{
    string name;
    int num;
    char sex;
    int age;
};

这样就声明了一个结构体类型 Student，struct 是结构体类型的关键字，不能省略。

3、结构体类型的声明：
struct 结构体类型名
{
    //成员表;
};

struct 是声明该类型为结构体类型的关键字，不能省略。结构体类型名就是该结构体类型的名字，以后可以直接拿这个类型名来定义变量，就跟使用int，double一样用。类型名的命名规则跟变量一样，可以是数字、字母、下划线，且数字不能开头。上面例子  Student 就是结构体的类型名。接下来的一对大括号内的成员表包含了该结构体 全部成员。上例  name、num、sex、age 都是结构体 成员。在声明一个结构体类型时必须对各成员进行类型声明，即：
类型名 成员名;
例如：int num;

备注：C语言中结构体的成员只能是数据，C++对此进行了扩充，结构体的成员既可以包含数据，也可以包含函数，其实在C++中 struct 跟 class 从使用角度来说差别不大，这个以后在讲解面向对象时候的class时再跟大家详细的讲解！

4、结构体类型变量的定义及初始化：
A、定义：
结构体类型声明完了之后就可以定义变量了，如下：
Student zhangsan, lisi;
这种是非常常用的一种定义结构体类型变量的方法。
当然也可以在声明结构体类型的时候就定义变量，当然这种是不常用的方法：
struct Student
{
    string name;
    int num;
    char sex;
    int age;
} zhangsan, lisi;

B、初始化：
Student zhangsan = {"张三", 1001, 'm', 25};
备注：初始化参数的顺序一定要和结构体类型声明的成员表顺序一致才行，不然会报错而且会错误的赋值。

5、结构体类型变量成员的访问：
结构体变量名.成员名
可以用这种方式来访问。
例如：
Student zhangsan = {"张三", 1001, 'm', 25};
zhangsan.num = 29;
int num = zhangsan.num;

## 二十五、结构体数组与指针
1、结构体类型和数组配合使用：
之前给大家介绍过数组，上节课又跟大家讲解了用户自定义的结构体类型，所以这里面将他们两个配合起来使用，再来举个之前学校学生的例子：
struct Student
{
    string name;
    int num;
    char sex;
    int age;
};

Student stu[100];
复制代码


这样就定义了100个学生的信息，很方便吧！

struct Student
{
        string name;
        int num;
        char sex;
        int age;
};

int main(int argc, char* argv[])
{
        Student stu[2];

        //输入
        for (int idx = 0; idx < 2; ++idx)
        {
                cin >> stu[idx].name;
                cin >> stu[idx].num;
                cin >> stu[idx].sex;
                cin >> stu[idx].age;
        }
    
        //输出
        for (int idx = 0; idx < 2; ++idx)
        {
                cout << stu[idx].name << " " << stu[idx].num << " " << stu[idx].sex << " " << stu[idx].age << endl;
        }
    
        return 0;
}
复制代码


2、结构体变量作为函数参数：
结构体变量跟其他类型的变量一样使用，所以也可以作为函数的参数直接传递进去。默认情况下也是以值传递的方式。例如有一个函数，功能是设置学生的学号，函数的实现如下：
struct Student
{
        string name;
        int num;
        char sex;
        int age;
};

void set_num(Student stu)
{
        static int stu_num = 101;
        stu.num = stu_num++;
}

int main(int argc, char* argv[])
{
        Student stu[2] =
        {
                { "aaa", 0, 'f', 10 },
                { "bbb", 0, 'm', 12 }
        };

        //遍历
        for (int idx = 0; idx < 2; ++idx)
        {
                set_num(stu[idx]);
                cout << stu[idx].name << " " << stu[idx].num << " " << stu[idx].sex << " " << stu[idx].age << endl;
        }
    
        return 0;
}
复制代码


具体代码编写及讲解见视频教程！

以上代码  set_num 函数真的能实现修改 stu 的学号吗？答案是否定的。上面已经跟大家说过了结构体类型变量作为函数的参数传递的时候也是以值传递的方式进行的，在函数调用的过程中实参 stu[idx] 会拷贝一份给形参，即进行 Student 类型变量的拷贝工作，会将 Student 类型内部的变量一个一个的复制过去。所以 set_num 函数是没办法修改外部的 stu[2] 数组里面的学生学号信息的。

解决方法相信大家已经想到了，将参数改成传递 Student* 指针的方式，一方面可以保证 set_num 函数可以修改外部的实参，还有一个好处大家想到了吗？那就是可以防止 Student 类型变量的拷贝工作，提高效率。当前 Student 类型变量内部只有四个成员，可以说不多，但是在以后的编程过程中某个结构体或者类对象中可能包含几十个成员，这个时候如果进行拷贝的话开销可想而知。所以有时候即使不想在函数的内部修改实参的值，函数的参数类型也想定义成指针的类型就是这个目的。

3、指向结构体变量的指针：
结构体变量指针的作用在上面的知识点中已经说的够详细的了，下面就给大家演示下如何来用！
之前给大家说过，结构体类型变量引用其成员的时候可以使用符号 . 来引用，例如：
Student stu;
stu.num = 102;
复制代码

但如果是指针类型呢？我们可以这样做：
Student stu;
Student* pstu = &stu;
(*pstu).num = 102;
复制代码

没问题吧？pstu是指向stu变量的指针，所以前面加上符号*就变成stu变量本身了。变成 stu本身了之后再用 . 来引用就可以了。

但是这么做可以说代码量少还可以，如果代码量比较多，写起来比较麻烦。所以C/C++中规定结构体类型的指针变量可以用 -> 符号来引用其成员，即如下：
Student stu;
Student* pstu = &stu;
pstu->num = 102;
复制代码


这样写起来就简单了。就是把 . 换成 -> 就可以了，方便吧？

4、改写 set_num 函数：
struct Student
{
        string name;
        int num;
        char sex;
        int age;
};

void set_num(Student* pstu)
{
        static int stu_num = 101;
        pstu->num = stu_num++;
}

int main(int argc, char* argv[])
{
        Student stu[2] =
        {
                { "aaa", 0, 'f', 10 },
                { "bbb", 0, 'm', 12 }
        };

        //遍历
        for (int idx = 0; idx < 2; ++idx)
        {
                set_num(&stu[idx]);
                cout << stu[idx].name << " " << stu[idx].num << " " << stu[idx].sex << " " << stu[idx].age << endl;
        }
    
        return 0;
}
复制代码


5、小作业：
①、根据运算符的优先级，大家想一下：
Student stu[2] =
{
        { "aaa", 0, 'f', 10 },
        { "bbb", 0, 'm', 12 }
};

Student* pstu = stu;
++p->num = 202; //这句代码执行之后，到底是stu[0] 的 num 值变化了，还是 stu[1] 的 num 值变化了？

②、定义一个学生类型的结构体，包含学生的：姓名、学号、分数。之后用该结构体定义大小为5的结构体变量数组。手动输入给数组成员赋值，之后将5个学生的信息输出出来，并且求出5个学生的分数的平均值也一起输出出来。

## 二十六、枚举类型及定义新的类型名字
1、枚举类型：
如果一个变量只能有几种可能的值，这样的变量可以定义成枚举类型。所谓的 “枚举” 是指可以将变量的值一一列举出来，变量的值只能在列举出来的值的范围内，其他的值对该变量没有意义，例如：星期几、人种颜色、性别、月份 等等。枚举类型也是一种自定义类型。

2、枚举类型的声明：
声明枚举类型用 enum 开头，例如：
enum ESex
{
        ESex_Male, //男性
        ESex_FMale //女性
};

以上就是定义了一个枚举类型 ESex，大括号内部的 ESex_Male、ESex_FMale 称为枚举元素或枚举常量。表示这个枚举类型可能的值。

注意事项：
①、枚举元素按常量处理，所以称作枚举常量。他们不是变量，所以不要对他们进行赋值，即枚举元素的值是固定的；
例如：ESex_Male = 8; 这种是错误的，大家可以在vs2013中试试；

②、枚举元素是常量，所以其也是有值的，他们的值是一个整数，按照元素声明时候的顺序从0开始依次进行+1操作，默认的值就是：0,1,2,3，...
例如，上面的ESex枚举类型中，ESex_Male 的值默认是0，ESex_FMale 的默认值是1，依此类推。

③、枚举元素有默认的值，但也可以在声明的时候指定值，例如：
enum EWeekDay
{
        EWeekDay_1 = 3,
        EWeekDay_2 = 4,
        EWeekDay_3 = 5,
        EWeekDay_4,
        EWeekDay_5,
        EWeekDay_6,
        EWeekDay_7,
};
其中从 EWeekDay_4 开始未赋值，所以按照他的上一个元素的值+1的规则进行默认赋值，也就是 EWeekDay_3 + 1 = 6。
这里面有个注意事项，即，上面赋值的最好是依次增大，不然有可能会造成两个枚举元素是一样的值，例如：
enum EWeekDay
{
        EWeekDay_1 = 3,
        EWeekDay_2 = 2,
        EWeekDay_3 = 1,
        EWeekDay_4,
        EWeekDay_5,
        EWeekDay_6,
        EWeekDay_7,
};

④、枚举值可以用来进行跟整数一样的判断，比较，switch-case 等操作，例如：
int ab = 2;
if(EWeekDay_1 > ab )
{
    //...
}

⑤、虽然枚举类型的变量可以看做是整形类型的变量，但是不能把普通的整数赋值给枚举类型变量，例如：
EWeekDay day = 2;
这种是错误的，除非进行强制类型转换，但是不建议。最好还是：
EWeekDay day = EWeekDay_2;

3、枚举类型举例：枚举类型和结构体类型结合：
struct Student
{
    string name;
    int num;
    ESex sex;
    int age;
};

Student stu;
stu.sex = ESex_Male;

4、用 typedef 类型声明新的类型名字：
除了可以用 struct 结构体，union 联合体，enum 枚举 等自定义类型以外，还可以使用 typedef 声明一个新的类型名字来代替已有的类型名。注意是新的类型名字，只是名字而已，不是一种全新的类型，只是改个名字而已。
例如，我们定义一个无符号的整型int变量可以这样来定义：unsigned int a = 5;
类型的名字比较长，unsigned int，而且以后所有定义无符号的整型int变量都得这么写，那么有没有简单的写法呢，typedef就派上用场了，咱们可以给 unsigned int 改个名字，例如：
typedef unsigned int uint;
uint a = 5;
所以，以后所有的 unsigned int 都可以改成 uint 了，方便吧？同理，其他的类型也都可以使用 typedef 改名，例如：
typedef int myint;
typedef unsigned long ulong;
typedef Student StuT;
typedef EWeekDay EWDay;
以上，都是可以的哦！

5、小作业：
课后自己练习定义枚举类型变量以及使用 typedef 定义新的类型名！

## 二十七、引用及new和delete的使用
1、何为变量的引用？
通过之前对指针的讲解，相信大家对于指针来说都比较熟悉了，指针里面存的是某个变量的地址。那么这节课给大家讲解一下变量的引用，跟指针有点像。他是C++对于C语言的一个重要的扩充。C语言中没有引用，C++有引用，而且C++中更建议大家多用引用少用指针。

变量的引用就是一个变量的别名，变量和变量的引用代表着同一个变量。例如：
int a = 5; //语句1
int& b = a; //语句2
int* p = &a; //语句3
这里面a是一个普通的int类型变量，b呢，就是变量a的一个引用，p呢就是指向变量a地址的一个指针变量。
其中语句2  & 符号是引用的声明符号，不是取地址哦，语句3  & 符号确实是取地址符。
如何来区分呢？大家记住：紧跟在数据类型后面的&符号就是引用的声明符号，其他情况都可以认为是取地址符号。

2、引用的注意事项：
①、引用不是一种独立的数据类型，引用只有声明，没有定义。必须先定义一个变量，之后对该变量建立一个引用。也就是说有变量才有变量的引用，不可能先声明一个引用而不去引用任何变量，这点跟指针不同，指针可以先声明，之后的任意时刻指向某个变量的地址，引用就不是；
例如：int &b; //先声明定义一个引用是错误的
②、声明一个引用时，必须同时对其初始化，即声明该引用代表哪一个变量。这个跟第①点要表达的意思一样。有一种例外的情况，当一个函数的参数是某个变量的引用时，形参不必在声明中初始化，他的初始化是在函数调用时的虚实结合实现的，即作为形参的引用是实参的别名；
void swap(int& a, int& b);

③、声明一个引用后，不能再让其作为另一个变量的引用了。例如：
int a1 = 2, a2 = 5;
int& b = a1; //正确
int& b = a2; //错误

④、不能建立引用数组，例如：
int a[5] = {0};
int& b[5] = a; //错误
int& c = a[0]; //正确（C++新标准支持）

⑤、可以建立引用的引用（C++新标准支持），也可以建立引用的指针，例如：
int a = 3;
int& b = a; //正确
int& c = b; //正确
int* p = &b; //正确，得到的是变量a的地址
*p = 5;
c = 6;

3、引用和指针的联系：
关于引用的性质，如果在程序中声明了b是变量a的引用，实际上在内存中为b开辟了一个指针型的存储单元，在其中存放变量a的地址，输出引用b时，就输出b所指向的变量a的值，相当于输出*b。引用其实就是一个指针常量，他的指向不能改变，只能指向一个指定的变量。所以，引用的本质还是指针，所有引用的功能都可以由指针实现。C++之所以增加引用的机制，是为了方便用户，用户可以不必具体去处理地址，而把引用作为变量的“别名”来理解和使用，而把地址的细节隐藏起来，这样难度会小一些。

4、引用的具体使用：
不用指针，用引用的方式实现 swap 函数，功能是交换两个整形变量的值，实现如下：
void swap(int& a, int& b)
{
        int t = a;
        a = b;
        b = a;
}
简单吧，跟指针能达到一样的效果。

5、使用new和delete动态分配内存：
在以后的开发过程中，因为局部变量的局限性，只能在其作用域内使用。因此，我们需要动态的分配和撤销内存空间，使其可以在任何函数中使用。例如：
char* get_same_string(char* p1, char* p2)
{
    //
}
get_same_string 函数的作用是从参数p1和p2中找出相同的部分，例如，p1的内容是："aabbcc"，p2的内容是："kkbcyy"，他们相同的子串就是 "bc" 对吧？我想把这个结果通过函数的返回值给传出去。所以函数的返回值是一个 char* 类型，如果在函数中定义一个局部变量 szret[100] 数组，用这个数组来存储相同部分的子串 "bc"，那么就不能返回，为什么呢？因为 szret 是局部变量，作用域只是在函数的内部，超过函数的作用域之后 szret 的内存就可能被释放了。所以用它来返回之后，在函数的外部再去使用是非常不安全的，也是错误的。所以这种情况就可以使用 new 动态分配内存来解决。

6、new 出来的变量/内存的生命周期：
C++   new操作符 和C语言  malloc 函数类似，如果你不主动 delete 掉这段申请的内存的话，它会一直存在，直到进程结束后系统会回收掉这段资源；而如果你delete掉这段申请的内存，则这段申请到的内存的生命周期为从你new（申请一段内存）到你delete（释放掉这段内存）这段时间。

7、new 和 delete 的使用：
C语言中是使用 malloc 和 free 两个函数来进行动态内存的申请和释放的，C++用引入了更为智能的 new 和 delete 操作符来进行内存的申请和释放，举例：
int* p = (int*)malloc(sizeof(int)); //C语言中使用 malloc 来申请一个int类型变量的内存
*p = 5;
free(p);

int* p = new int(5); //C++ 中使用 new 来申请一个int类型变量的内存
//怎么样，看出 new 的优势了吧！
delete p; //删除变量

int* p = new int[5]; //使用new申请一个包含5个int元素的数组
delete [] p; //删除数组

还有一个更重要的new优于malloc的地方，在以后的课程中会给大家讲解C++ 类class，用new申请一个类对象的时候，对象申请成功之后会默认调用其构造函数，而C语言 malloc只是会申请空间，但是不会调用对象的构造函数。这个会在以后的课程中给大家讲解。所以，在C++中大家就放弃 malloc 和 free 吧，直接用 new 和 delete 来操作动态内存。

8、小作业：
完成 get_same_string 函数的功能！

## 二十八、VS2013编程实用技巧
1、C++语言 保留关键字：
C++ 保留关键字很多，这些关键字是C++语言默认保留的，所以作为开发人员来说不能用这些关键字来作为变量的名字等用途。用了之后就会编译报错的哦，所以大家以后实用的时候要注意一点！
关于C++ 保留关键字都有哪些详见这篇帖子：https://www.cctry.com/thread-289434-1-1.html

2、C++语言 注释用法：
/*
*/
复制代码

或者：
//
复制代码

用法示例如下：
单行注释：
int a = 5;
/*int a = 5;*/
//int a = 5;
复制代码

多行注释：
/*int a = 5;
a = 6;
++a;
*/
复制代码

或者：
//int a = 5;
//a = 6;
//++a;
复制代码


在VS系列的编译器中，不用大家手动的去添加注释，在工具栏上面有个现成的两个图标，用于注释和取消注释： 
使用：
单行注释：将光标定位到所在的行，选中不选中都可以。之后点击工具栏的注释图标即可；
多行注释：鼠标选中所要注释的行，之后点击工具栏的注释图标即可。
具体操作见视频演示！

3、为什么调试的控制台的黑窗口一闪而过？
很多C++小白用户前期第一次使用VC6.0或者VS2013进行调试的时候，一般都是按F5，之后程序启动起来，黑窗口一闪而过，连程序执行的结果什么的都没看到，类似这样的情况如何操作呢？
①、getchar 法；
②、断点法；
③、Ctrl+F5 法；
④、工具栏添加快捷按钮点击法；
详情见视频演示！

4、清理工程源码，删除无用文件，大大减少工程体积，方便分享：
大家在写好了一个程序的源码之后，可能要传给别人，与好友之间分享资料。或者是自己的代码遇到了一些问题没办法解决请求好友帮忙，也要把工程源码打包给别人。或者是大家要把自己的工程源码打包之后发布到咱们VC驿站上面，但是论坛的附件是有大小限制的。如何将工程中一些没用的文件删除掉，这样无论是传递给别人或者发布到网上方便别人下载等等，都是非常不错的，那么哪些文件是没用的呢？哪些文件可以删除呢，而且还要保证工程代码的完整性，其他人收到这个工程源码之后，用VS打开即可编译生成EXE/DLL呢？下面给大家说一下：
①、工程目录下的Debug/Release文件夹都可以删除，包括两层结构；
②、工程目录下的：SolutionName.sdf、ipch文件夹 以及 *.pch 等文件都可以直接删除，大大减少体积；
备注：VC6.0的话有个 *.ncb 文件也可以删除。
③、如果不想让VS在工程目录中生成②的文件，可以按照如下设置：
工具(T)->选项(O)...->文本编辑器->C/C++->高级->回退位置->
始终使用回退位置->True
回退位置已在使用时，不警告->True
回退位置->留空
（具体操作见视频演示）
经过以上设置之后，VS会把 sdf、pch 等相关文件生成在系统的临时目录中，从而不生成在工程目录中，所以以后打包的时候就方便了，不用每次都清理。

## 二十九、面向对象的程序设计
1、什么是面向过程？
咱们先来说说什么是面向过程？其实C语言就是面向过程的语言，C++兼容C语言，所以C++有一部分就是面向过程的。之前咱们给大家讲解的28课的东西主要就是面向过程的。面向过程的程序中函数是构成程序的基本单位，我要实现个功能我就新写一个函数，我要实现另外一个功能我就再新写一个函数，之后调用就行了，这就是面向过程的程序开发的基本流程。

2、什么是面向对象？
面向对象就不单单是为了实现功能而写个函数这么简单了。既然是面向对象的，也就是说我把任何东西都看做是一个对象。这里所说的对象不是北方老百姓眼 男女朋友的对象，大家可以这么理解，这个对象就是一个物品，一个东西，一个个体。比如可以是个人，也可以是条狗，或者是一个苹果，万物都有可能，万物都是对象。我们拿狗来举例，狗是个对象，狗有什么属性呢？有品种，是哈士奇，还是金毛，是大狼狗，还是吉娃娃，等等。狗还有大小，有颜色，等等，这些都是狗的属性。狗还有一些行为动作或者可以叫做功能，比如狗可以吃东西，狗可以拉屎，狗可以跑，狗可以跳，狗可以汪汪叫，对不对？如果你是一条狗，那么所有这些属性和动作你都应该有，这样说明你才是一条狗。

所以，任何一个对象都应该有属性和行为这两个要素。一个对象就是由多个属性和多个行为构成的。
所以，面向对象的程序设计就是利用上面给大家说的想法。将这个程序涉及到的方方面面分成不同的彼此间有联系的多个对象。在C++语言中，每个对象都是由数据和函数这两个部分构成的。数据就是前面说的对象的属性，函数就是上面说的对象的行为或者功能，用来对数据进行操作的，以便实现某些功能。
例如：我要让狗对象汪汪叫，那么我就要调用其汪汪叫的行为函数，这样狗对象才能汪汪叫，不然他不会乱叫的。

3、对象的封装与信息屏蔽
可以对一个对象进行封装，换句通俗的话就是说可以对一个对象进行整理，我可以决定哪些东西可以让别人看到，哪些东西不想让别人看到。例如：狗对象有汪汪叫的功能。我只要告诉你这个狗对象有旺旺叫的功能就行，具体狗对象内部是怎么叫的，是用嘴巴叫，还是用鼻子叫你没必要知道。你想让狗对象汪汪叫，你就调用汪汪叫的这个行为函数就可以了。没必要知道内部的实现细节。这样也有利于使用，简单方便。C++类对象 函数名就是对象的对外接口，函数的内部实现别人没必要知道。再举个例子，电视机对象，你想看电视机，只要按电源按钮把电视机打开就可以看了，具体电视机对象是怎么显示节目的图像的，怎么把有线电视的信号接收过来的你不用管。这就是对象的封装与信息屏蔽。

封装是面向对象的程序设计 一个特点。这里面的封装性有两方面的含义：
一方面就是将这个对象相关的属性和行为封装在对象中，集成在对象中，形成一个基本单位，各个对象之间相互独立，互补干扰。另外一方面就是对象 某些实现细节对外界屏蔽，隐藏内部实现的细节，只提供基本可用的函数接口，让外界调用。这样做也有利于数据的安全。

4、什么是抽象？
对于刚开始学习面向对象的新手来说阅读各位书记都会提到抽象这个概念，到底什么是抽象？何为抽象？
很简单，其实抽象就是归类，或者说分类。按照类别把世间万物给归类。比如，男人，女人，是两个类别。男人，女人又可以统称为人类，人类和狗可以不可以归类呢？当然也可以，都可以说是哺乳动物，对不对？这就是归类，实际上这就是抽象。抽象的作用就是表示同一类的事物本质。
C++中，类就是对象的抽象，而对象就是类的特例，即，类的具体表现形式。

5、继承与重用：
还是拿之前的狗举例子，比如之前已经抽象出了一个狗的类了，之后呢又出现了一个狗的新品种。这时候你还用完全重头来定义这个狗的新品种吗？当然不用，你直接告诉别人，第一这是一条狗，第二这条狗有什么新的特性，比如不仅会汪汪叫，还会喵喵叫。这就是在以前狗的类型的基础上进行了继承与重用。我继承了基础的狗类别的一些特性，比如狗的颜色，有四条腿，会吃东西，会拉屎，会汪汪叫等等。并且增加了我自己的新特性，会喵喵叫。也就是说不用重头来定义或者描述这个新品种的狗了。可以说站在巨人的肩膀上。比如：中国八十年代的时候没有自己的汽车，想造一台属于中国人民自己的品台汽车。那么用从头来吗，肯定不用，为什么，因为国外有现成的汽车，也都知道，汽车有四个轮子，有发动机，有变速箱等等。所以这就是基础，这就是继承与重用。继承与重用也是面向对象编程过程 一个非常重要的特性。大大缩短了开发周期。

6、多态性：
面向对象编程 多态性，主要指的是对同一类别的不同对象调用同一个行为或者函数的时候，表现不同。例如：张三，李四，王五，这三个人，他们都属于同一类别，都是人类，对吧？调用他们的同一行为函数：跳高，三个人都会跳高，但是每个人跳的高度肯定不同。调用他们的同一行为函数：百米跑步，三个人都会向着100米的终点跑去，但是每个人所用时间肯定不同。这就是多态性。
在C++中多态性指的是由继承而产生的不同的派生类，派生类对象对同一行为调用会做出不同的响应。
多态性也是面向对象程序设计的一个非常重要的特性，能增加程序的灵活性！

7、小作业：
本节课主要讲解的是一些概念性的东西，但是这些东西大家一定要好好理解，做到真正明白是怎么回事，因为以后会经常用到，在这里我也想通过各种举例、比喻，通过通俗易懂的方式来让大家能更容易理解这些抽象的概念。
所以本节课的作业就是深入的理解面向对象编程，理解本节课介绍的这些概念性的东西，大家加油！

## 三十、类的声明
1、什么是类类型？
上节课给大家讲解了什么是面向对象的编程，即，可以把世间万物都看成是对象。既然是对象，那么就应该有对象的类型，也就是说可以把把世间万物抽象成类型，给归类对吧？
在C++中对象的类型称为类（class），用来表示一类具有共同属性和行为的类型。例如：人类，狗类，动物类，哺乳动物类等等。在C++中一般是先声明一个类类型，然后用这个类类型去定义多个对象，所以，对象就是类类型的一个实例，或者说是类类型的一个实例化的变量。

类类型是抽象出来的，所以类类型跟C++ 其他类型一样，不占用内存空间，而对象就是类类型的实例，是真正的变量，所以是占用存储空间的。

2、类类型的声明：
C++中声明一个类类型跟声明一个结构体类型很像。例如，咱们之前讲解的声明一个结构体的类型如下：
struct Student
{
    string name;
    int num;
    char sex;
    int age;
};
复制代码

一个学生的结构体类型Student，包含学生的一些属性，如：姓名、学好、性别、年龄。基于这个结构体类型我们改一下，改成生成一个类类型：
class Student
{
    string name;
    int num;
    char sex;
    int age;
};
复制代码


大家看到了吗？声明一个学生的类类型和声明一个学生的结构体类型很像很像，表面上看就差了一个关键字：struct 和 class，另外，C++中对结构体在基于C语言 重要扩充就是可以添加函数了，类class也是一样，例如：
class Student
{
    string name;
    int num;
    char sex;
    int age;

    void print_name()
    {
        cout << "name = " << name << endl;
    }
};
复制代码


//////////////////////////////////////////////////////////////
备注：这里面在给大家说说有关属性和方法的名字的问题。
class类 name，num，sex 之类的按照咱们上节课的只是可以叫做属性，print_name 这个函数呢，可以叫做行为或者方法。
这里面交给大家一些更通用的叫法：name，num，sex 之类的又可以叫做成员变量，print_name 可以叫做成员函数。
//////////////////////////////////////////////////////////////

那么我们接下来按照之前使用结构体类型对象的方式来使用一下类对象呢？看看好不好用，会不会有什么问题？我们来写几句代码：
Student zhangsan = {"张三", 1001, 'm', 25};
zhangsan.num = 29;
int num = zhangsan.num;
复制代码


编译一下，看看结果？问题详情还请观看视频教程！

3、成员访问限定符：
C++针对类的成员，设定了三种方式的访问限定符：public、private、protected（用的不多）
public：意为共有的，公开的，公用的 成员，既可以被本类 成员函数引用，也可以被类的作用域的其他函数所引用，即从类的外部是可以调用的；
例如，我家的房子就好比是一个类，如果来客人了，那么我可能招呼客人到客厅，这个客厅就是public类型的成员，外部可以访问，客人也可以到客厅中喝水，看电视等等；

private：意为私有的，私生的 成员，只能被本类的成员函数所引用，类外部不能调用（友元类可以，这个以后说明），
例如，我家的房子就好比是一个类，卧室就是private类型的成员，是一个相对隐私的地方。如果来客人了，我不希望客人访问我的卧室，除非经过我的允许（让成员函数去访问）；

protected：意为受保护的成员，不能被类外访问，这点类似private，但是可以被派生类的成员函数访问，有关派生类的说明，以后会讲解。

附：在 class 中，public、private、protected 可以出现多次，也没有先后顺序之分，例如：
class Student
{
public:
    string name;
    int num;
    int age;

private:
    char sex;

public:
    void print_name()
    {
        cout << "name = " << name << endl;
    }
};
复制代码


跟在谁后面的，就是哪种访问权限！

4、如何决定成员变量及成员函数的访问权限：
一般情况下，如果不希望外界访问本类的成员变量，那么就可以把成员变量都声明为私有的。但是有个前提必须提供可以访问的接口函数，不然一个类的所有成员都是private私有的话就没有意义了，相当于闭关锁国一样，不跟任何外界打交道，这点肯定不行。比如在Student这个类中，如果把sex性别这个成员变量设置为私有的，那么Student类就应该提供可以修改或者读取sex成员变量的成员函数，并且这个函数是public的，不然外界想要知道sex变量的值就没办法获取了。大家说是不是？

当然，也可以把一些成员设置为私有的，但是不对外提供修改的接口，因为可能这个属性或者成员变量对于类对象来说可能不想被外面知道或者修改，比如，这个学生是否脚臭，这个属性对别人有意义吗？鞋一穿上之后谁也不知道你脚臭不臭，只有自己知道，而且自己知道就够了。外界不需要知道。我也没熏到你，对不对？我也没在公共场合拖鞋，对不对？

还有一种情况就是将成员函数声明为私有的，这说明这个私有的成员函数只能被该类的其他成员函数所调用，是作为辅助的接口函数的，是在类的内部使用，不对外公开。例如：
class Student
{
public:
    string name;
    int num;
    int age;

private:
    char sex;
    int max_num(int x, int y)
    {
        return x > y ? x : y;
    }

public:
    int get_max_num(int a, int b, int c)
    {
        int max_ab = max_num(a, b);
        return max_ab > c ? max_ab : c;
    }

    void print_name()
    {
        cout << "name = " << name << endl;
    }
};
复制代码


max_num 成员函数就是private私有的，是辅助或者配合public的get_max_num函数来实现功能的，我只想让外界知道或者我只提供求三个int整形的数中较大的，我不想提供求两个int整形的数中较大的。明白了吗？

5、struct 和 class 关键字的区别：
上面已经说过了，在C++中已经对struct进行了扩充，不仅可以声明成员变量，还可以声明成员函数，class关键字本身就是从struct发展而来的，所以struct支持的，class都支持。那么在C++中他们有什么异同呢？
最重要的一个区别就是：class默认的成员访问限定符是private，struct默认的成员访问限定符是public，所以，在之前的课程中struct定义的对象我们可以这样用：
Student zhangsan = {"张三", 1001, 'm', 25};
zhangsan.num = 29;
int num = zhangsan.num;
复制代码


但是用class定义的对象就不行。因为你没办法直接这样给一个私有的成员变量赋值：zhangsan.num = 29;

6、小作业：
自己定义一个学生类，将该类的所有成员变量都声明为私有的，并添加一个共有的成员函数，实现从键盘录入该类对象的学生信息。

## 三十一、类的成员函数
1、类的普通成员函数：
类的普通成员函数跟普通的函数没什么太大的区别，也都是有参数的类型和形参，还有返回值之类的，唯一的区别就是必须由该类的实例化对象去调用。
这里面为什么强调是类的普通成员函数呢，难道还有不普通的吗？当然有，那就是类的静态成员函数，这个以后再做讲解！

2、inline 内联函数：
之前给大家讲解过普通的全局函数，刚刚又给大家讲解了类的成员函数，这里面又出来个inline内联函数是个什么东西呢？给大家讲解一下！
实际上inline内联函数是从C语言的宏发展而来的。例如，程序main函数中直接执行以下三行代码：
int a = 5;
++a;
int b = a + 3;
复制代码

和将该三行代码封装成一个函数让main函数调用的开销是完全不一样的。函数调用的过程中需要将参数压栈等等操作，详情可以看下这篇帖子：
https://www.cctry.com/thread-289482-1-1.html

C语言中可以用宏来实现一些相对简单的函数，例如：
#define MAX_NUM(x, y) (x > y ? x : y)
复制代码

调用的时候代码可以这样写：
int ret = MAX_NUM(3, 6);
复制代码

调用的时候感觉 MAX_NUM 像个函数，但是他是个宏，宏跟函数的区别是，在编译阶段就将宏的代码展开直接替换调用宏的地方。所以省去了函数调用的压栈、出栈等开销。所以执行效率方面要比函数高。
但是宏定义写起来比较难度倒是不大，就是麻烦一些，而且代码的可阅读性会变差。所以C++中引入了inline内联函数这么个东西，用inline关键字声明的函数，可以在调用的时候，将函数的代码直接嵌入到调用的地方，所以大大的减少了函数调用的开销，提高了效率。

例如：
class Student
{
public:
    string name;
    int num;
    int age;

private:
    char sex;
    inline int max_num(int x, int y)
    {
        return x > y ? x : y;
    }

public:
    int get_max_num(int a, int b, int c)
    {
        int max_ab = max_num(a, b);
        return max_ab > c ? max_ab : c;
    }

    void print_name()
    {
        cout << "name = " << name << endl;
    }
};
复制代码


备注1：默认情况下，在类体中直接定义/实现的函数，C++会自动的将其作为inline内联函数来处理，所以类似上面的代码：max_num、get_max_num、print_name 函数都会被看成是 inline 内联函数。而在类体外部定义的函数C++则会将其作为普通的类的成员函数来处理。那么如何在类体外部定义成员函数呢，接着往下看！

备注2：也不是把所有的函数都声明成 inline 就是好事儿，如果函数的执行体很大，很耗时，那么就不适合作为 inline 内联函数，只有当函数的执行体很小，只有几行代码，而且会被频繁的调用的时候才适合作为 inline 内联函数的。这点还请大家谨记。

3、类的声明和实现分离：
一般情况下，可以把类的声明和实现都写在一起，例如：
class Student
{
public:
    string name;
    int num;
    int age;

private:
    char sex;
    int max_num(int x, int y)
    {
        return x > y ? x : y;
    }

public:
    int get_max_num(int a, int b, int c)
    {
        int max_ab = max_num(a, b);
        return max_ab > c ? max_ab : c;
    }

    void print_name()
    {
        cout << "name = " << name << endl;
    }
};
复制代码

但是，随着类的功能越来越多，类 成员变量和成员函数也是越来越多，类的代码长度就越来越大，而且随着长度的增加不太便于阅读，层次不清晰，让人一眼望过去就一大面。那怎么办呢？
好的做法就是将类的声明和成员函数的定义分离开，成员函数的声明放在类的内部，实现或者定义放在类的外部，加上作用域限定一下就行，类似下面这样：
//类的声明
class Student
{
public:
    string name;
    int num;
    int age;

private:
    char sex;
    int max_num(int x, int y);

public:
    int get_max_num(int a, int b, int c);
    void print_name();
};
复制代码

//类的成员函数的实现
int Student::max_num(int x, int y)
{
    return x > y ? x : y;
}

int Student::get_max_num(int a, int b, int c)
{
    int max_ab = max_num(a, b);
    return max_ab > c ? max_ab : c;
}

void Student::print_name()
{
    cout << "name = " << name << endl;
}
复制代码


大家看到了吧，成员函数的实现已经拿出来了，这样类的声明就很短小精悍了，调理也比较清晰，易于阅读。
备注：注意类的作用域修饰：Student:: 这个不能丢，丢了就错了。

4、使用多文件分离类的声明和实现：
通过上面的学习，我们已经成功的将类的声明与实现分离了，但是呢，代码还是在一个文件中，不够清晰。接下来给大家介绍一种更贴近我们平时编程开发的方法：将类的声明放到 .h 头文件中，将类的实现放到 .cpp 实现文件中，谁要使用这个类，就 include 包含 .h 类的头文件就可以啦！接下来视频演示一下如何进行 h 和 cpp 的分离，具体看视频教程演示。
（模板类的代码必须都放在 .h 文件中，没办法实现 .h 和 .cpp 的分离，这个以后会讲解的）

这里面也可以直接使用VS2013添加类向导的方式来添加类到我们的工程中。起好类的名字之后，VS2013会自动添加该类的 h 头文件和 cpp 文件到我们的工程中，具体看教程演示！
所以，大家以后从一些开源网站，或者从咱们VC驿站下载的一些开源的类来使用的时候，作者都是提供关于该类的一个 .h 文件和一个 .cpp 文件。

备注：可以使用 Visual Assist X 小助手，快速的实现添加类的成员函数的实现，具体见视频教程演示！

5、小作业：
大家自己课后用VS2013练习如何添加类吧，多敲代码，多实践，不然你永远都记不住！

## 三十二、this指针
1、成员函数的存储方式：
讲解 this 指针之前，先来说说类的成员函数的存储方式！
用类实例化定义一个对象的时候，就好比是用int定义一个变量一样，系统会为该对象分配存储的内存空间。例如一个学生类：
class Student
{
public:
    char name[50];
    int num;
    int age;

public:
    void print_name()
    {
            cout << "name = " << name << endl;
    };
};
复制代码


用这个学生类定义一个对象：
Student stud = {0};
int stud_size = sizeof(stud);
复制代码

这个 stud_size 是多少呢？大家先不放分析一下，之后再到 VS2013中把以上代码敲一遍，之后看看结果是多少？

相关的原因可以参考这篇帖子：内存对齐相关说明：https://www.cctry.com/thread-289483-1-1.html

得到结论：C++语言中每个对象所占用的存储空间只是该对象的数据成员所占用的存储空间，而不包括函数代码所占用的存储空间。
因为针对某个类的多个对象而言，不同的只是数据成员，而函数成员来说都是一样的代码，所以没有必要为每个对象都保存一份成员函数的代码。这样可以很大程度上节省空间。

2、this指针：
上面已经跟大家讲解过了，既然成员函数不占用对象的存储空间，或者说多个对象是共用一个成员函数的，那么问题就来了。在调用成员函数的时候，函数如何区分是哪一个对象调用的呢？
例如：
Student zhang_san, li_si;
strcpy(zhang_san.name, "zhang_san");
strcpy(li_si.name, "li_si");

zhang_san.print_name();
li_si.print_name();
复制代码

这两条打印语句很很明显，打印出的结果肯定不同，张三就打印出张三的名字，李四就打印出李四的名字。那么 print_name 是如何来区分是张三对象还是李四对象呢？答案的关键就是：this 指针。

在每一个成员函数中都包含一个特殊的指针，这个指针的名字是固定的，称为 this，它也是C++ 保留关键字，它是指向本类对象的指针，它的值是当前被调用的成员函数所在的对象的起始地址。所以，当对象调用成员函数的时候，如：zhang_san.print_name(); 则系统会把 zhang_san 对象的地址赋值给 this 指针，所以在 print_name 函数的内部调用 cout 打印 name 成员的时候，实际上就是 this->name 这样调用的。只不过这里面的 this 可以省略不写，默认就是调用当前对象的。

3、关于 this 指针的一个很形象的比喻：
当你进入一个房子后，你可以看见桌子、椅子、地板等，但是房子你是看不到全貌了。
对于一个类的实例来说，你可以看到它的成员函数、成员变量，但是实例本身呢？
this是一个指针，它时时刻刻指向你这个实例本身。
举例给大家说明，具体说明见视频教程！

4、什么情况下需要手动加上this：
例如：
class Student
{
public:
    char name[50];
    int num;
    int age;

public:
    void set_age(int age)
    {
            age = age;
    };
};
复制代码


大家看到了吗？set_age 函数的参数名字和成员变量的名字一样，都是age，那么这样的情况下，大家说说成员变量的age是否能真的赋值呢？大家不妨先把视频教程暂停，自己实践下，之后再继续播放教程！
不同的编译器可能实现的结果不同，但是在我们的vs2013中，答案是否定的。成员变量age并没有通过函数 set_age 被正确的赋值。那么这个时候怎么办呢？解决的方法是将 set_age 函数改成如下：
void set_age(int age)
{
    this->age = age;
};
复制代码


5、小作业：
自己查找资料，详细说明this指针的作用域是哪里？

## 三十三、类的构造函数
1、对象的初始化：
之前给大家讲解过变量的初始化，例如：
int a = 0;
复制代码

那么类的对象呢？本身类是自从结构体发展过来的，所以之前结构体的初始化操作，类都支持
可以这样在定义的时候直接初始化，也可以先定义后初始化！
代码详见附件！

或者说我想在对象定义完了之后马上将其初始化一下，这个初始化可以说是给类的成员都赋上一些初值，但不是具体的值，不想让变量默认都是一些杂乱无章的没有什么规律的未初始化状态的数，例如：


我们可以这样做：
Student stud3;
stud3.age = 0;
stud3.num = 0;
memset(stud3.name, 0, 50);
复制代码

这样做是完全可以的，但是我问你，这是你定义的一个对象，那么如果你定义了100个学生的对象呢？重复的代码你可能要写100次，用循环来做吗？非常麻烦，而且，你这种初始化的方式只能初始化public类型的成员，private类型的你是初始化不了的，有的会员可能会说，我自己封装一个函数，定义完对象之后调用下就可以了，代码详见附件！

这样做也是可以的，但是如果对象很多的话，也得循环调用 init 函数，如果这样定义个对象数组：
Student stud_array[1000];
复制代码

那么你怎么为数组 每个对象都调用 init 函数初始化呢？用个 for 循环？麻不麻烦啊？有什么更好的解决办法吗？C++的作者早就想到了。。。构造函数！

2、什么是构造函数？
构造函数就是解决上面的问题而存在的。构造函数是一种特殊的成员函数，与其他成员函数不同，不需要用户来主动调用它，构造函数会在对象被建立时自动被调用的。作用就是用来处理对象的初始化操作。

3、构造函数的注意事项：
①、构造函数的名字必须与类名同名，不能随意命名，这样的话才能让编译器认为该函数是构造函数，而不是类的普通成员函数；
②、构造函数不具有任何类型，不返回任何值，连 void 都不是；
③、构造函数不需要用户调用，也不应该被用户调用，它是对象建立的时候自动被系统调用，用来初始化刚刚建立的对象的；
④、如果用户没有定义自己的类的构造函数，那么系统会自动生成一个默认的构造函数，只不过该构造函数的函数体是空的，也就是什么都不做。

4、为 Student 类实现构造函数：
代码详见附件！

接下来，我们来实例化一个类对象试试，具体演示见视频教程！

5、带参数的构造函数：
既然构造函数也是函数，那么这个构造函数是否可以带参数呢？答案是肯定的。
例如，Student 类不仅提供了默认的不带参数的构造函数，可以允许用户在定义类对象的时候自动调用，那么是否也可以提供一个带参数的构造函数，可以允许用户在定义类对象的时候就利用构造函数的参数来初始化对象的成员呢？我们来给大家演示下：
代码详见附件！

6、小作业：
有这么个需求，所有的在校生都必须有学号，所以能不能实现实例化一个Student对象之后，就要求输入学号，不存在一个没有学号的Student对象被实例化出来，大家明白了吗？也就是类似于 stud1 这样的对象是不允许存在的，因为其没有学号。大家课后试着做一下！

## 三十四、函数的重载与默认参数
1、函数重载的由来：
在平时的编程过程中，一个函数可能就实现一个功能，多个功能就需要多个函数。但有时候多个功能之间很像，只是一些细节有差异，那么类似这样的功能能不能写成一个函数呢？例如，要求2个数中比较大的数，这两个数的类型有时候是int类型，有时候是float类型，那么我们按照之前的写法应该是这样封装函数：
int max_int(int a, int b);
float max_float(float a, float b);
复制代码

所以，用户在调用的时候就要根据不同的参数类型，调用不同名字的函数，如果要求两个int类型的数 比较大的就要调用 max_int，如果要求两个float类型的数 比较大的就要调用 max_float，能不能叫一个名字呢？让系统自己去适配到底调用哪个？答案是可以的。例如：
int max_num(int a, int b);
float max_num(float a, float b);
复制代码

实际上这就是函数的重载。
C++允许同一函数名定义多个函数，这些函数的参数类型和个数可以不相同，而且至少要有一个不相同，如果都相同的话就会报重复定义的链接错误了。使一个函数名可以多用。

2、函数重载的要求：
重载函数的参数个数、参数类型、参数顺序 三者中必须至少有一种不同（不然会产生调用疑惑）。函数的返回值类型可以相同也可以不同。
单纯返回值类型不同的两个同名函数不能构成函数重载，会报链接错误。

举个例子：
int max_num(int a, int b);
bool max_num(int a, int b);
float max_num(float a, float b);
复制代码

这样就不行，int max_num(int a, int b); 和 bool max_num(int a, int b); 不满足条件，只有返回值类型不同。这样会导致系统不知道调用哪一个。编译直接报错。
例如：
max_num(2, 5);
复制代码

这时候如果我问你，要调用哪个，你也不能确定，因为我这里根本就没关心返回值返回什么。所以函数的重载也不是说随便重载。

另外，在跟大家说一下，函数的重载一般都是功能相近，或者功能类似的函数进行重载，不能把一些功能相差很大，或者完全不相关的函数叫同一个名字，语法上是没有错误，但是违背函数重载设计的初衷啦。

3、函数的默认参数：
我们来举个例子，实现一个函数，求出某个int类型数组的最大值和最小值，之前是当做一个小作业给大家出题来着，还有的网友问这个问题，详情见帖子：
https://www.cctry.com/thread-289893-1-1.html
那么现在呢，我想让这个函数更灵活一些，有的时候我只想求最大值，有的时候我只想求最小值，有的时候我同时求最大值和最小值。
void get_min_max(int src[], int arr_len, int* max_v, int* min_v);
能不能不让我每次都得定义两个 int 类型的变量用来接收数组 最大值和最小值。我需要最大值就给我最大值，我需要最小值就给我最小值。如何才能办到呢？
通过函数的默认参数就可以做到。

修改方法：
函数的声明改成如下：
void get_min_max(int src[], int arr_len, int* max_v = NULL, int* min_v = NULL);
复制代码

函数的定义及调用代码见附件！
具体代码讲解见视频教程！

4、函数默认参数的注意事项：
①、在函数声明的时候指定，如果没有函数的声明则可以放在函数的定义中，但是声明和定义只能选一个；
②、从第一个有默认值的参数开始，后面的所有参数必须都有默认值才行；
③、调用的时候如果要自定义非第一个默认值的参数，那么前面所有的参数都要明确的写上默认值才行；
④、从使用角度来说函数的默认值比重载更方便，从函数内部实现角度来说比函数的重载更复杂。

5、函数的默认参数对函数重载所造成的歧义：
例如，也有个名字叫做 get_min_max 的函数，作用是获取参数给定int整型数组的最大值，并通过函数的返回值返回，函数的代码如下：
//返回int数组 最大值
int get_min_max(int src[], int arr_len)
{
    int var_max = src[0];
    for (int i = 1; i < arr_len; ++i)
    {
        if (var_max < src[i]) var_max = src[i];
    }

    return var_max;
}
复制代码


跟刚才的第4知识点 函数放在一起会有什么情况发生呢？看看vs2013报不报错？为什么呢？具体见视频教程演示！

6、小作业：
实现一个函数，该函数的声明如下：
bool string_upper_diy(char str[], int str_len, bool b_odd_pos = true);
功能为对字符串指定位置的字符变换为大写。
str 参数为字符串的指针；
str_len 为字符串的长度；
b_odd_pos 为true的时候，就要将 str 字符串 奇数位置的字符变为大写，同时将非奇数位置的字符变为小写；
b_odd_pos 为false的时候，就要将 str 字符串 奇数位置的字符变为小写，同时将非奇数位置的字符变为大写；
奇数指的是：1,3,5,7,9,11,13,15,17,19...以此类推；
大家明白了吗？动手试着做一做！
## 三十五、类的构造函数与析构函数

1、类的构造函数的重载：
上节课给大家讲解的函数的重载与默认参数，拿的都是普通的函数来讲解的，实际上在类的构造函数和成员函数上面一样适用。在《实用C++》第33课 类的构造函数的课程中，第5个知识点，带参数的构造函数，其中就给大家讲解了多个带参数的构造函数，实际上就是实现了构造函数的重载。我们可以去看下：https://www.cctry.com/thread-289921-1-1.html

2、构造函数 参数初始化表：
用这种方式实现的构造函数体积小，代码显得更简洁，显得比较NB哈！那么怎么用呢，咱们举个例子：
class CStudent
{
public:
    char name[50];
    char sex;
    int num;
    int age;

    CStudent(char* pname, char t_sex, int t_num, int t_age);
};
复制代码

CStudent::CStudent(char* pname, char t_sex, int t_num, int t_age) :sex(t_sex), num(t_num), age(t_age)
{
    strcpy(name, pname);
}
复制代码


具体细节及注意事项讲解详见视频教程！

3、析构函数：
析构函数也是一个在类中跟构造函数类似的特殊功能的成员函数。只不过它的作用是与构造函数相反，是在对象的生命周期结束的时候会被自动调用的。在C++中析构函数的名字跟类名相同，并且前面带上一个取反的符号~，表达的意思也就是跟构造函数的过程相反。

默认情况下，如果类的设计者没有自己定义析构函数，那么编译器会自动为该类生成一个默认的析构函数，只不过函数体是空的，也就是什么都没做。所以，如果需要在对象被删除的时候做一些操作的话，那么就得自己定义析构函数喽。

以下几种情况会自动调用析构函数：
①、如果在一个函数中定义了一个局部变量的对象，那么当这个函数执行结束时也就是该变量对象生命周期结束的时候，所以析构函数会被自动调用；
②、全局变量或者static类型的变量，他们的生命周期一般是在程序退出的时候，这时候该对象的析构函数才会被调用；
③、如果是用new操作符动态的创建了一个对象，只有当用delete进行释放该对象的时候，析构函数才会被调用；

4、析构函数的作用：
先拿构造函数来说话，构造函数是新建对象吗？回答：不是，而是在对象被创建出来之后自动被调用的，用来初始化相关信息的函数。同理，析构函数也不是用来删除对象的，而是当对象被删除的时候自动会被调用的，用来做一些对象被删除之前的清理工作。只要对象的生命周期结束，那么程序就会自动执行析构函数来完成这个工作的。

5、析构函数的特点：
析构函数不返回任何值，没有函数类型，也没有任何函数的参数。由于上面这些特点，所以析构函数不能被重载，所以说一个类可以有多个构造函数，但只能有一个析构函数。

6、析构函数使用举例：
为 CStudent 类实现析构函数，如下：
CStudent::~CStudent()
{
    cout << "~CStudent() called." << endl;
}
复制代码


之后我们来看看，析构函数是否被调用呢？
#include "Student.h"
void test()
{
    CStudent stud;
}

int main(int argc, char* argv[])
{
    CStudent stud("zhangsan", 'f', 1001, 20);
    test();
    return 0;
}
复制代码




看到执行的结果截图，大家先想想为什么？之后我们再来讲解！

7、实际编程中经常用到的构造和析构过程：
CStudent 类 学生姓名字段，之前咱们都是事先定义好一个长度，默认是50个字节。但是实际的生活中，学生的姓名可能长度不固定，所以这里面我们就随着用户输入的长度来new出来。这样才更灵活，代码如下见附件！
相关讲解见视频教程！

8、小作业：
有这么个函数：
void test()
{
    CStudent zhang_san("zhangsan", 'f', 1001, 21);
    CStudent li_si("lisi", 'm', 1002, 22);
    CStudent wang_wu("wangwu", 'm', 1003, 23);
}
复制代码


在 test 函数中我依次定义了三个局部变量的对象：zhang_san、li_si、wang_wu，那么当离开 test 函数之后，这三个对象的析构顺序又是怎么样的呢？大家先想想，之后在VS编译器中试试，验证下你的猜想到底对不对，为什么会这样呢？

## 三十六、对象的赋值与复制及拷贝构造函数

1、对象的赋值：
何为对象的赋值？我们先来说说赋值，赋值咱们之前也给大家讲解过。说到赋值咱们肯定能想到=等号，一般赋值指的都是用=等号赋值，例如：
int a = 5; //赋值操作
int b = a; //这也是赋值
复制代码


那么对象也是一样的，也是用=等号，不过赋值的目标不是int类型的整型数了，而是用一个对象给同类的另外一个对象赋值。这个过程是通过成员复制来完成的，即，将一个对象的成员的值一个一个的复制给另外一个对象的对应成员。

2、对象的赋值举例：
有一个矩形的类，CMyRect 的声明如下：
class CMyRect
{
public:
    CMyRect(int w = 0, int h = 0):width(w), height(h){};
public:
    int width; //矩形的宽
    int height; //矩形的高
};
复制代码


接下来，我用这个矩形类定义两个对象：
CMyRect rect_a(200, 100), rect_b;
复制代码

之后，我用 rect_a 给 rect_b 赋值，如下：
rect_b = rect_a;
复制代码


之后，我们看看 rect_b 的宽和高都是多少呢？咱们来调试一下，看看具体的值。调试过程见视频教程的详细讲解！

3、对象赋值的注意事项：
①、对象的赋值，只是对对象的成员变量的赋值，对于成员函数来说不理会，也不做赋值处理，因为本身每个类的成员函数就一份而已所以也不需要赋值。这个之前给大家讲解this指针的时候提过，如果大家忘记了，可以看看以前的课程说明文档，在这里：《实用C++》第32课 this指针：https://www.cctry.com/thread-289911-1-1.html
②、类似上面的矩形类 CMyRect 的对象是可以直接用=等号赋值的，但是有一些成员是没办法用=等号赋值的，例如，成员变量是其他一种类对象，那么此时的解决办法就是重载类的=等号运算符，这个以后会给大家讲解；
③、还有一种情况下，使用对象的赋值也是非常危险的，例如咱们上节课最后给大家使用的那个 CStudent 类型，咱们来试试：
对象的赋值代码如下：
void test()
{
    CStudent stud_1("zhangsan", 'f', 1001, 20);
    CStudent stud_2;
    stud_2 = stud_1;
}

int main(int argc, char* argv[])
{
    test();
    return 0;
}
复制代码


执行之后，程序崩溃了，如下图：

大家想想为什么呢？为什么会崩溃，原因见视频教程讲解！

4、对象的复制：
刚才给大家说了对象的赋值，是利用=等号运算符将一个对象的成员变量赋值给另外一个同类对象的成员变量。可以说是对已经存在的两个对象进行操作。那么对象的复制呢？对象的复制是一个对象从无到有的一个过程，在对象创建的时候就以一个已经存在的对象为源头进行创建本对象。

例如：
Student zhangsan = {"zhangsan", 1002, 20};
Student lisi(zhangsan);
Student wangwu = lisi;
复制代码


对于对象 lisi 和 wangwu 来说都是在创建的时候以 zhangsan 这个对象为源对象进行创建的，所以这里面就是用到了对象的复制操作。
这里面咱们来调试下上面的代码，看看具体的信息是否复制过去了。详细调试过程见视频教程！

5、复制/拷贝构造函数：
上面的代码中这句话：Student lisi(zhangsan); 大家看着是不是有点眼熟，我们在给大家讲解构造函数的时候就用到过类似的写法，具体在：
《实用C++》第33课 类的构造函数：https://www.cctry.com/thread-289921-1-1.html
我们过去看一眼！

所以，按理说 Student lisi(zhangsan); 这句代码也应该调用的是构造函数，对不对？没错，确实是，只不过这个构造函数有点特殊，名为拷贝构造函数。
原型如下：
class Student
{
public:
    char name[50];
    int num;
    int age;
    Student(char* pname, int t_num, int t_age) :num(t_num), age(t_age)
    {
        strcpy(name, pname);
    }

    Student(Student& stud)
    {
        strcpy(name, stud.name);
        num = stud.num;
        age = stud.age;
    }
};
复制代码


6、拷贝构造函数的特点：
①、也是构造函数，所以函数名字就是类名字，并且无返回值；
②、参数上有点特殊，参数是一般是本类的对象的引用；
③、如果类没有提供拷贝构造函数，那么编译器会默认生成一个拷贝构造函数，作用比较单一，只是简单的将成员变量的值进行复制过去而已。

7、拷贝构造函数实现的必要性：
刚才已经跟大家说了，如果一个类没有提供拷贝构造函数，那么那么编译器会默认生成一个。既然编译器都可以默认生成了，我们为什么还要实现呢？
①、类的成员变量中有一些无法进行赋值的，此时就需要自定义实现拷贝构造函数；
②、针对类似上节课给大家讲解的 CStudent 类的实现方式上，调用起来也非常危险，咱们再来实验一下：
void test()
{
    CStudent stud_1("zhangsan", 'f', 1001, 20);
    CStudent stud_4(stud_1);
}
复制代码


之后，我们来执行下代码，执行完 test 函数之后，程序又崩溃了。为什么呢？具体原因及解决方法见视频教程讲解！

8、小作业：
实现 CStudent 类的拷贝构造函数，让 第 7 点的代码不崩溃！要慎重 new 和 delete 哦！

## 三十七、类的静态成员
1、类的静态成员变量：
之前给大家讲解了很多关于类的普通成员变量的知识。也跟大家说过，用类定义的多个对象之间彼此独立，各自拥有自己的一套成员变量，互不影响！但是有时候呢，某个类的所有对象共同拥有一个东西，或者说一个变量。打个比方，咱们之前定义的学生类 CStudent，每个学生都有自己的名字、学号、性别、年龄等属性。那么他们有没有共同的属性呢？有，比方说该学校的校长。不可能每个学生一个校长，我们先假定所有这些学生都是在一所学校，那么也就是说所有这些学生都只有一个公共的校长，这个校长不属于某个学生，而是属于这个学生类大家的，或者说属于这个学校。

所以，这时候将校长作为学生类 CStudent 的普通成员变量就有点不合适了。或者说也不方便。应该将它作为类的静态成员变量：
①、这样所有对象都可以直接访问这个静态成员变量，而且值是一样的；
②、静态成员变量在内存中只占用一份存储空间；
③、静态成员变量的值对于所有对象来说都是一样的。如果其中一个对象调用函数将其改变了，那么其他成员在访问这个静态成员变量的时候的值都是改变之后的；
④、只要在类中定义了类的静态成员变量，那么就占用存储空间了，不管有没有定义这个类的对象，因为静态成员变量不属于任何类对象，而是属于该类；
⑤、静态数据成员需要在类外进行声明或声明并初始化，否则在使用的时候会报链接的错误；
⑥、类的静态成员在定义的时候需要加 static，在类外声明的时候不需要加 static 关键字；
⑦、不能用构造函数的参数初始化表的形式对静态成员进行初始化操作；
⑧、静态数据成员既可以通过对象名引用，也可以通过类名来直接引用，具体代码见视频教程！
⑨、public 公有类型的静态数据成员，可以被类的对象引用，也可以直接用类名来引用。但如果静态数据成员被定义成private私有的，那么通过对象或者类名来引用都是不可以的，必须通过类的public类型的静态成员函数来引用了。

2、类的静态成员函数：
跟类的静态成员变量一样，类的静态成员函数也不属于该类的对象，而是属于这个类。
①、类的静态成员函数可以通过类对象调用，也可以通过类名调用；
②、之前跟大家说过类的普通成员函数中可以使用标识该类对象的this指针，但是类的静态成员函数是属于类，不属于任何对象，所以静态成员函数中没有this指针，也就无法访问本类的非静态成员变量，因为不知道是哪个对象的。
③、所以，类的静态成员函数可以直接引用类的静态成员变量，因为他们的作用域相同，都是属于该类的。

3、类的静态成员相关代码举例详见视频教程讲解！

## 三十八、运算符重载
1、什么是运算符重载？为什么要进行运算符的重载？
咱们之前给大家讲解过函数的重载，表现形式就是一名多用，同一个名字实现多个相近功能的函数。那么今天呢要给大家介绍运算符的重载，大家还记得C++中都有哪些运算符吗？
可以参考下《实用C++》第7课：C++ 运算符：https://www.cctry.com/thread-278774-1-1.html 我们跳过去看下！
可以说+-*/=这些基本的加减乘除对于C++ 基本类型是够用了，也不用我们在自定义的去重载。但是，针对我们当前正在使用的类类型，就有必要了。因为我们要重载这些运算符使之能达到我们自定义的功能。

2、运算符重载举例：
之前在《实用C++》第36课 对象的赋值与复制及拷贝构造函数：https://www.cctry.com/thread-289974-1-1.html 课程中给大家举例说明过了，在其 第③个知识点：对象赋值的注意事项中，当跳出test函数的作用域之后程序就崩溃了。原因就是 stud_1 和 stud_2 两个对象公用 p_name 指针指向的名字空间了。导致在对象结束调用析构函数释放 p_name 所指向的内存空间的时候，被释放了两次，所以才会崩溃报错。解决问题的方法呢，在36课中也提及了一嘴，所以这节课开始给大家讲解解决的办法，就是利用重载=等号运算符。

3、示例代码：
运算符的重载实际上就是函数的重载，即，定义一个重载运算符的函数。使指定的运算符不仅能实现原有的功能，而且在函数中还能实现新的自定义的功能，具体格式如下，详见视频教程讲解！
CStudent& CStudent::operator=(const CStudent& stud)
{
    if (p_name)
    {
        delete[] p_name;
        p_name = NULL;
    }

    int name_len = strlen(stud.p_name) + 1;
    p_name = new char[name_len];
    memset(p_name, 0, name_len);
    
    strcpy(p_name, stud.p_name);
    sex = stud.sex;
    num = stud.num;
    age = stud.age;
    return *this;
}
复制代码


具体敲代码过程见视频讲解，写好运算符重载的函数之后，我们再次的执行下程序，看看还崩溃吗？

4、重载运算符的规则：
①、C++不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载：
例如，在VB中可能有的人会使用**运算符，例如：3**5，表示3的5次方，如果你想在C++中创建**运算符并实现重载，那是不行的。

②、C++允许与不允许重载的运算符如下图：


③、重载运算符不能改变运算符操作对象的个数：例如 > 和 < 运算符，本身是比较用的双目运算符，也就是说要有2个操作数，如果你重载完了之后变成不是2了，那肯定不行；
④、重载运算符不能改变运算符的优先级别，乘除 */ 运算符的优先级别大于+-，如果你重载完了之后导致优先级改变了，那肯定也不行；
⑤、重载运算符不能改变运算符的结合性，例如，赋值运算符=是从右向左开始结合的，如果你重载完了之后导致从左往右了，那肯定也不行；
⑥、重载运算符的函数不能有默认的参数：不然就改变了运算符参数的个数，与第③点矛盾了；
⑦、重载运算符的函数参数至少有一个是本类的对象或引用，不能全部都是C++的基本类型，例如：CStudent& CStudent::operator+(int a, int b) 这种也是不行的；
⑧、重载运算符应该遵循运算符原有的含义，不能把+重载之后变成-的功能，虽然语法上没有错误，但是违背了重载运算符的初衷！

5、小作业：
为 CStudent 类重载 == 和 != 运算符，判断两个 CStudent 对象是否相等，或者说是否是同一个学生的数据。

## 三十九、类的继承与派生 

1、为什么要进行类的继承与派生？
关于这个话题其实在之前的课程中有给大家介绍过，就在《实用C++》第29课 面向对象的程序设计的第⑤个知识点：https://www.cctry.com/thread-289448-1-1.html
继承与派生是C++编程过程中经常用到的一个非常重要的功能。可以复用以前开发好的功能，站在巨人的肩膀上，节省时间，提高开发效率。不用重复造轮子了。这就是C++面向对象编程 继承与派生。
例如，咱们之前定义的学生类 CStudent，里面包含了一些普通学生的信息：姓名、学号、性别、年龄。那么接下来呢，我要定义一个小学生的类，又要定义一个中学生的类，还要定义一个大学生的类。不管是小学生、中学生还是大学生，肯定也包含学生的姓名、学号、性别、年龄等基本信息，如果都分别新定义一个类的话，可不可以？答案是当然可以的。但是这样跟之前的学生类 CStudent 貌似有点重复，同样的代码写了很多次。所以，我们可以通过C++ 继承的机制来解决这个问题。

2、继承举例：
既然 CStudent 学生类的信息可以作为所有学生的基础信息，任何一个学生都包含姓名、学号、性别、年龄等基本信息。那么我们在定义小学生、中学生或者大学生的类的时候就可以用 CStudent 作为父类进行派生子类，例如：
#include "Student.h"
class CXiaoStudent : public CStudent
{
public:
    int yuwen_score;
    int shuxue_score;
    int english_score;
};

class CZhongStudent : public CXiaoStudent
{
public:
    int wuli_score;
    int huaxue_score;
};
复制代码


其中 CXiaoStudent、CZhongStudent 是新定义的小学生、中学生的类名字，: public 之后跟着的是他的父类，也就是从哪个类继承过来的，咱们之前的类定义都是留空，这里面应该设计到继承关系，所以要加上，不然不知道从哪里继承过来的。这里面的 public 是指的继承方式，即：父类 成员在子类 继承方式，一般也包含三种：public公有继承、private私有继承、protedted受保护继承。这个咱们下个知识点讨论，这里面先举个小例子，看看怎么用：
CZhongStudent zhong_1;
zhong_1.wuli_score = 90; //调用本类的成员变量
zhong_1.yuwen_score = 100; //调用父类的成员变量
zhong_1.age = 15; //调用爷爷类的成员变量
复制代码


以上调用都是可以的，怎么样，大家看到了继承的方便之处了吧？

3、继承的方式：
①、public公有继承：
父类的公有成员和受保护成员在子类中保持原有的访问属性，其私有成员仍为父类私有，在子类中是访问不了的，即使通过子类的共有成员函数也访问不了；
②、private私有继承：
父类的公有成员和受保护的成员在子类中变成了私有成员，其私有成员仍为父类私有， 在子类中是访问不了的，即使通过子类的共有成员函数也访问不了；
③、protected受保护继承：
父类的公有成员和受保护的成员在子类中变成了受保护成员，其私有成员仍为父类私有， 在子类中是访问不了的，即使通过子类的共有成员函数也访问不了；

示例代码如下，具体详细敲代码过程及讲解详见视频教程！
#include "Student.h"
class CXiaoStudent : public CStudent
{
public:
    int yuwen_score;
    int shuxue_score;
    int english_score;

private:
    int flag_private;

protected:
    int flag_protected;
};

class CZhongStudent : public CXiaoStudent
{
public:
    int wuli_score;
    int huaxue_score;

public:
    int get_flag_1()
    {
        //return flag_private;
        return flag_protected;
    }
};
复制代码


备注：现实编程过程中 public 公有继承是使用最广泛的，其他两种使用的不是很多。所以 public 公有继承这块大家要熟练掌握。
总结为一张图：


4、小作业：
按照继承的规则，既然父类 private私有成员不能在子类中直接使用，那么有没有什么办法能解决这个问题呢？让子类可以直接或者间接的使用父类 private私有成员呢？大家想想？
比如上面代码  CZhongStudent 类的 get_flag_1 函数，如何能获取到 flag_private 的值呢？大家课后想一想，并且自己实现一下试试！

## 四十、子类的构造函数与析构函数
1、子类的构造函数概述：
构造函数这个话题之前跟大家讲解过多次了，在之前课上的示例代码中也都有给大家写过构造函数，包括带参数的，不带参数等等。如果是单独的自己一个类，那么构造函数的知识点就是之前给大家讲解的，这里没必要重复了。可现在我们讲解到了类的继承和派生，那么子类的构造函数和父类的构造函数又是一个什么关系呢？定义一个子类的对象会不会自动调用父类的构造函数呢？接下来我们带着这些疑问来给大家讲解下！

2、构造函数是否可以被继承？
子类可以继承父类所有的成员变量和成员函数，但不能继承父类的构造函数。因此，在创建子类对象的时候，为了初始化从父类继承来的数据成员，系统需要调用其父类的构造函数。

3、父类构造函数的调用规则：
①. 如果子类没有定义构造函数，则调用父类的无参数的构造函数；
②. 如果子类定义了构造函数，不论是无参数还是带参数，在创建子类的对象的时候，首先执行父类无参数的构造函数，然后执行自己的构造函数；
③. 在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数，则会调用父类的默认无参构造函数；
④. 在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类自己提供了无参构造函数，则会调用父类自己的无参构造函数；
⑤. 在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类只定义了自己的有参构造函数，则会出错（如果父类只有有参数的构造函数，则子类必须显示调用此带参构造函数）；

以上总结起来就两句话：
如果子类没有显示的调用父类的构造函数，那么默认会调用父类无参的构造函数！！！
如果父类只提供了有参数的构造函数，那么子类在默认情况下调用父类的无参构造函数时就会报错！

⑥. 如果子类调用父类带参数的构造函数，需要用初始化父类成员对象的方式，例如：
class CXiaoStudent : public CStudent
{
public:
    int yuwen_score;
    int shuxue_score;
    int english_score;

    CXiaoStudent() : CStudent("zhangsan", 'm', 1001, 20)
    {
        yuwen_score = 2;
        shuxue_score = 0;
        english_score = 0;
    
        flag_private = 0;
        flag_protected = 0;
    }

private:
    int flag_private;

protected:
    int flag_protected;
};
复制代码


具体每一条的详细规则见视频教程讲解！

4、子类的析构函数是否可以被继承？
跟父类的构造函数一样，子类也一样不能继承父类的析构函数，也需要通过派生子类的析构函数去调用父类的析构函数。在执行子类的析构函数时，系统会自动调用父类的析构函数和子对象的析构函数，对父类和子对象进行清理工作。
调用的顺序跟构造函数正好相反：先执行子类自己的析构函数，对派生类新增加的成员进行清理，之后调用子对象的析构函数，对子对象进行清理，最后调用父类的的析构函数，对基类进行清理。

5、多重继承：
关于多重继承方面的知识点，在实际编程过程中用的不多，这里不做课上讲解，大家感兴趣的话课后自己学习一下吧，也算是一个小作业了！

6、小作业：
用一个函数来实现一个功能，分别统计全市在校学生的平均年龄。学生包括小学生、中学生、高中生、大学生 等。用一个函数来实现！
下节课会给大家解答这个小作业，用的方法也是下节课即将要讲解的，大家先事先自己试试吧！

## 四十一、父类对象与子类对象之间的相互转换
1、有父子关系的两个类的对象之间能否进行互相转换呢？
答案：由子类对象给父类对象赋值是可以的，俗称大材小用。在赋值的时候会舍弃子类的新增成员，例如：
#include "Student.h"
class CXiaoStudent : public CStudent
{
public:
    int yuwen_score;
    int shuxue_score;
    int english_score;

    CXiaoStudent() : CStudent("zhangsan", 'm', 1001, 20)
    {
        yuwen_score = 2;
        shuxue_score = 0;
        english_score = 0;
    
        flag_private = 0;
        flag_protected = 0;
    }

private:
    int flag_private;

protected:
    int flag_protected;
};

class CZhongStudent : public CXiaoStudent
{
public:
    int wuli_score;
    int huaxue_score;

    CZhongStudent()
    {
        wuli_score = 0;
        huaxue_score = 0;
    }

public:
    int get_flag_1()
    {
        //return flag_private;
        return flag_protected;
    }
};
复制代码

//赋值操作：
int main(int argc, char* argv[])
{
    CZhongStudent zhong_1;
    zhong_1.wuli_score = 90;
    zhong_1.yuwen_score = 100;
    zhong_1.age = 15;

    CStudent base_stu = zhong_1; //由子类对象给父类对象赋值
    
    return 0;
}
复制代码


但是，反过来，由父类的对象给子类的对象赋值是不允许的，会出现填不满的不可预知行为。

2、父子类对象转换的实际用途：
在实际的编程过程中，直接进行父子类的对象的相互转换的情况比较少。一般是使用指针来操作。
上节课最后给大家留了一个小作业：
用一个函数来实现一个功能，分别统计全市在校学生的平均年龄。学生包括小学生、中学生、高中生、大学生 等。用一个函数来实现！
不知道大家思考的怎么样？只能用一个函数来实现，还要自动区分是小学生、中学生、高中生或者大学生？要怎么做呢？接下来教大家一种方法。

void average_age(CStudent* p_arr_stud, int n_size)
{
    if (!p_arr_stud || n_size <= 0) return;

    int total_age = 0;
    EStudentType type = p_arr_stud[0].type;
    for (int idx = 0; idx < n_size; ++idx)
    {
        switch (type)
        {
        case EStudentType_Xiao:
            total_age += ((CXiaoStudent*)p_arr_stud)[idx].age;
            break;
        case EStudentType_Zhong:
            total_age += ((CZhongStudent*)p_arr_stud)[idx].age;
            break;
        default:
            break;
        }
    }
    
    int aver_age = total_age / n_size;
    switch (type)
    {
    case EStudentType_Xiao:
        cout << "小学生的平均年龄是：" << aver_age << endl;
        break;
    case EStudentType_Zhong:
        cout << "中学生的平均年龄是：" << aver_age << endl;
        break;
    default:
        break;
    }
}
复制代码


说明：这里是统计所有类型学生的信息，学生有多种类型，有小学生、中学生、高中生、大学生 等等。以后还可能统计研究生、博士生等等。所以类型很多，如果你针对每种类型的学生都写一个函数进行统计那就非常麻烦了。所以这块我们只写一个函数，还要把全类型都覆盖了，那么我们只能传递各种学生的父类型的指针，因为从子对象往父对象转换是可以的，就是我们之前说的大材小用。但是由父对象往子对象转换往往很危险。另外我们这里面转换的也只是一个指针类型而已，真正子类型的指针指向的那块内存不会因为把指针类型改成父类型了就改变内存结构了。所以我们先通过参数把各种类型的学生都统一成基本的学生类型，之后在函数内部通过事先在父类中定义好的类型来区分参数传进来的到底是哪种子类型，之后强制类型转换就行了。

有的网友会说，你这个强制类型转换不就是从父类型转换到子类型吗？不是很危险吗？你为什么还这样做？刚刚我说过了，指针指向的那块内存本身就是子类型的，之前只不过用另外一种指针指了一下，不会影响那块的内存结构，也不会修改那块的内存内容，所以在函数中再转回来是一点问题没有的。大家明白了吗？我这个例子中用的方法在以后的编程过程中会时不时的用到的，可以解决不少问题，这个思想还是希望大家掌握哦！

3、小作业，刚刚的 average_age 函数我改成这样行不行？
void average_age(CStudent* p_arr_stud, int n_size)
{
    int total_age = 0;
    if (!p_arr_stud || n_size <= 0) return;
    for (int idx = 0; idx < n_size; ++idx)
    {
        total_age += p_arr_stud[idx].age;
    }

    EStudentType type = p_arr_stud[0].type;
    int aver_age = total_age / n_size;
    switch (type)
    {
    case EStudentType_Xiao:
        cout << "小学生的平均年龄是：" << aver_age << endl;
        break;
    case EStudentType_Zhong:
        cout << "中学生的平均年龄是：" << aver_age << endl;
        break;
    default:
        break;
    }
}
复制代码


代码看着很简洁，不知道结果是否正确，大家不妨先试试，如果结果正确那没什么说的，如果结果不争取，那是为什么呢？为什么会出现这样的情况？还请大家课后仔细想想！

## 四十二、多态性与虚函数

1、多态性介绍：
关于C++中面向对象的多态特性，这里面先给大家介绍一下。什么是多态性？多态，即多种形态。在C++中一般是这么解释的：向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为。
之前其实已经给大家有使用过了，就是成员函数的重载，或者运算符的重载等等，都算是多态性的一种体现。
举个现实 例子，我们还拿学生来做举例：说上课了，那么不同的学生可能会走进不同的教室，上课了，有的学生上语文课，有的学生上数学课，等等。所以针对同一个上课的消息，不同的学生产生的行为是不一样的。大家明白了吗？

2、使用虚函数实现多态：
这里面给大家介绍一个新的概念，虚函数。虚函数这个东西可以说是C++面向对象的一个非常重要的概念。他的核心思想就是一句话：使用基类之指针，指向派生类的对象，调用虚函数的时候，最后调用的是派生类的函数！
接下来给大家演示一下如何玩转这个虚函数：
①、分别给 CStudent、CXiaoStudent、CZhongStudent 三个类添加 shangke() 这么个成员函数；
②、分别在三个类的 shangke 函数中打印出不同的文本内容，以示区别；
③、测试如下代码：
int main(int argc, char* argv[])
{
    CZhongStudent stud_zhong;
    stud_zhong.shangke();

    CStudent *pStud = &stud_zhong;
    pStud->shangke();
    return 0;
}
复制代码


跟大家猜想的结果一致吗？
stud_zhong.shangke(); 打印的结果是 CZhongStudent::shangke 函数，pStud->shangke(); 打印的结果是 CStudent::shangke 的结果。因为我虽然用的是基类的指针 pStud 指向了派生类的对象，但是本身基类也有同名该函数，所以就调用了跟指针同类型的基类的 CStudent::shangke 的函数了；
④、这里面我改写一下，把 CStudent 的 shangke 函数声明成 virtual 虚函数，如下：
virtual void shangke()
{
    cout << "CStudent::shangke called." << endl;
}

之后我们其他不动，再来看看代码的执行结果？大家看到了吗？结果不一样了吧？两次调用的都是 CZhongStudent::shangke 函数。这就是 virtual 虚函数的妙用！
具体课程演示见视频教程！

3、虚函数的注意事项：
①、virtual 只能用来声明类的成员函数，把它作为虚函数，而不能将类作用域外的普通函数声明成虚函数。因为虚函数的作用是允许在派生类中对基类的虚函数重新定义。显然，他只能用于类的继承层次结构中；
②、一个类 某个函数被声明成虚函数之后，同一类中就不能再定义一个非virtual的参数和返回值类型都相同的成员函数了。

4、什么情况下使用虚函数：
一般情况下是某个函数所在的类可能会作为父类/基类，而且该函数有可能会被派生类重写，并被派生类使用，那么这个时候就可以考虑将该函数声明为 virtual 虚函数。否则就不用！因为声明成虚函数之后是有开销的，所以不要随随便便的想声明成虚函数就声明。

5、小作业：
创建一个狗的类 CDog，包含 wangwang 这个虚函数，之后从 CDog 分别派生2-3个子类，比如：有金毛、吉娃娃、藏獒 等。分别实现每个子类的 wangwang 方法，之后试着调用该方法，充分理解虚函数的特性！

## 四十三、文件IO操作之打开与关闭

1、什么是文件的IO操作？
C++的文件操作就是指对文件进行读写的操作，那么 IO 呢？字母 I 就是 Input 的缩写，意为输入，字母 O 就是 Output 的缩写，意为输出。所以文件的 IO 操作就是指文件的输入与输出。输入就是从磁盘上的文件中读取内容到内存中。输出就是将内存 数据内容输出或者说写入到磁盘的文件中。这么解释大家应该明白了吧？

2、文件的类型：
文件的类型分为文本文件和二进制文件，文本文件又称为ASCII文件，它的每个字节存放一个ASCII码，代表一个字符。二进制文件则是把内存 数据，按照其在内存 存储形式原样写在磁盘上存放。比如一个 short 类型的整数20000，在内存中占用2个字节，而按文本形式输出则占5个字节。因此在以文本形式输出时，一个字节对应一个字符，因而便于字符的输出，缺点则是占用存储空间较多。用二进制形式输出数据，节省了转化时间和存储空间，但不能直接以字符的形式输出。所以，大家可以根据自己的需要选择使用文本文件还是二进制文件存储。如果是输出log文件之类的，那肯定就得用文本形式了，二进制的也看不懂啊，对不对？

代码举例：
#include <fstream>
using namespace std;
int main(int argc, char* argv[])
{
    short var = 20000;
    ofstream fs;
    fs.open("d:\\123.txt");
    fs << var;
    fs.close();

    ofstream fs2;
    fs2.open("d:\\456.txt");
    fs2.write((const char*)&var, sizeof(short));
    fs2.close();
    
    short value = 0;
    ifstream fi;
    fi.open("d:\\456.txt");
    fi.read((char*)&value, sizeof(short));
    return 0;
}
复制代码


3、C++ 文件操作类：
fstream（输入输出文件流）：支持文件的输入与输出操作；
ifstream（输入文件流）：支持从文件中输入操作；
ofstream（输出文件流）：支持向文件写入的操作；
实际上这几个类都是C++标准模板库STL中提供给我们的，现成的，写好的文件流操作类，我们可以直接拿过来用！之前说过本身C++兼容C语言，所以C语言 文件读写函数仍然支持，比如：fopen、fread、fwrite、fclose 等等。不过C++ 这几个文件流操作类更符合C++的操作习惯，使用起来更为方便，所以，更建议大家使用C++ 文件操作类。

4、文件的打开操作：构造函数与open函数
ofstream fs("z:\\123.txt");
fs.open("z:\\123.txt");
复制代码

这两种操作都是可以的。当前我们这里只使用了第1个参数，即：传入了文件的路径。实际上open函数有多个参数，第2个参数也很常用，表示打开文件的方式，取值有如下：
ios::in
为输入(读)而打开文件
ios::out
为输出(写)而打开文件
ios::ate
初始位置：文件尾
ios::app
所有输出附加在文件末尾
ios::trunc
如果文件已存在则先删除该文件
ios::binary
二进制方式
这些方式是能够进行组合使用的，以“或”运算（“|”）的方式：例如：
ofstream fs;  
fs.open("123.txt", ios::in|ios::out|ios::binary);
复制代码


有的会员马上就会有疑问了，在第2个知识点的时候，我们并没有很明确的使用open函数的第2个参数，可以说是省略了，或者说使用了默认的第2个参数，为什么也好用呢？
实际上：ofstream、ifstream、fstream 的open函数或者构造函数都有默认的打开文件的方式，如果不传第2个参数，那么就用默认的，其值如下：
ofstream fs1("123.txt", ios::out);
ifstream fs2("123.txt", ios::in);
fstream fs3("123.txt", ios::in|ios::out);
复制代码

这回大家明白了吧？

5、文件是否成功打开了呢？
既然文件打开了，但是文件是否打开成功了呢？我们又该如何判断呢？有的会员会说，看看open函数的返回值，返回 false 肯定就表明打开失败了吧？但是open函数的返回值是 void 类型哦，也就是说无返回值，你又该如何判断呢？方法有多种，这里面一一列举给大家，大家喜欢用哪种方式就用哪种：
①、直接 if 判断 fs 对象；
②、用 is_open 方法判断；
③、用 good 方法判断；
④、用 fail 方法判断；
比较常用的还是前两种方法，意思表达明确。建议大家用前两种方法检测文件是否打开成功。具体使用见视频教程讲解！

6、文件流的关闭：
使用 fs.close() 关闭文件流。也就是是文件流对象 fs 跟磁盘文件断开连接。

7、小作业：
咱们课堂上主要是使用 ifstream 和 ofstream 对象来进行文件的操作，大家课后请使用 fstream 文件流来对文件进行读写操作，把课堂上讲解的知识点实现一遍。

## 四十四、文件IO操作之读写
1、简介：
上节课给大家介绍了各种类型的文件流对象，对文件进行了打开与关闭的操作。那么打开与关闭不是目的，打开文件之后重要的是为了要进行文件的读写操作，不然打开、关闭文件干嘛？对不对？在C++文件流操作中，可以使用多种方法对文件进行读写操作，例如：<<、>>、put、get、getline、read、write 都是可以的。接下来就分别给大家讲解下每个函数怎么用！

2、文件的写操作：
写操作对应的有：<<、put、write 等，我们来看下他们分别都能实现什么样的写文件功能！
①、写文本类型/ASCII码类型的可见字符串：<<、put
示例代码如下：见附件！

大家看到了吧，这就是写文本文件的方式，其中 << 支持的类型比较多，put 只能写单个字符到文件，还是有一定局限性的，所以 put 平时用的比较少。
<< 支持的类型详见：http://www.cplusplus.com/referen ... eam/operator%3C%3C/

②、二进制类型写文件：write
并不一定所有的文件都是文本文件，也并不是所有的功能都要求用文本文件来实现。例如：图片文件就是二进制文件，我们用记事本打开之后发现里面是乱码，根本不是我们用眼睛能看懂的文本文件，所以类似这样的文件就不能用 << 或者 put 来写入了。那么用什么呢？可以用接下来要给大家讲解的 write 函数，他支持文本类型和二进制类型。你只要告诉他内存的地址，以及从这个地址开始要写多少字节的数据到文件就可以了，例如：见附件！

这里面大家可以看到 write 的第一个参数是 char* 类型的，但是不要误以为 write 只能写字符串类型的数据，完全错误！char * 不一定是字符串，里面放的东西可能是字符串，也可能是二进制数据。其实对于 write 来说第一个参数如果写成 void* 可能大家能更好理解一些。也就是一个地址而已，具体这个地址里面的内容是什么，write 不关心。第二个参数就是要一个长度，要从多长的一块内存数据写到文件中。大家明白了吗？

3、文件的读操作：
①、读文本类型/ASCII码类型的文件：>>、get、getline
代码见附件！
>>支持的类型详见：http://www.cplusplus.com/referen ... eam/operator%3E%3E/
istream::get 详见：http://www.cplusplus.com/reference/istream/istream/get/

还有一个 getline 函数，该函数是从文件中读取一行数据，什么是一行？所谓的一行就是有换行符 \n，或者达到 getline 的缓冲区大小，或者读到文件末尾。
istream::getline 详见：http://www.cplusplus.com/reference/istream/istream/getline/
所以，如果是想把文件 内容一行一行的读进来，可以使用 getline 函数，还是非常方便的。
代码见附件！

②、读取二进制文件类型：read
代码见附件！

具体 read 函数的定义见：http://www.cplusplus.com/reference/istream/istream/read/
也就是说他从指定的文件中读取数据，读取的数据可以是文本类型的也可以是二进制类型的，其实read也不管你想要读取什么东西，我只管读就是了，把读取到的内容放在第一个参数指针指向的内存中，具体读取的字节数就是靠第二个参数指定。

4、小作业：
今天给大家讲解了如何进行文件的读写，介绍了相关的读写文件的函数，那么今天给大家留的小作业就是如何判断读写文件的操作/函数是否成功了呢？以及如何判断是否读到文件末尾了呢？希望大家课后自己实践下！

## 四十五、文件IO操作之文件指针

1、文件读写的注意事项：
①、文件读写是否成功？
可以使用 good、bad、fail 来进行判断！
fail() 方法用于判断最后一次读取数据的时候是否遇到了类型不配的情况，若是返回true（如果遇到了EOF，该方法也返回true）
bad() 如果出现意外的问题，如文件受损或硬件故障，最后一次读取数据的时候发生了这样的问题，方法 bad() 将返回true。
good() 该方法在没有发生任何错误的时候返回true。该方法也指出的最后一次读取输入的操作是否成功。

②、读取文件的时候是否已经读到文件末尾？
可以使用 eof 来进行判断！eof() 方法用于判断最后一次读取数据的时候是否遇到EOF，即到达文件末尾，若是则返回true。
代码见附件！

2、文件指针：
这里面说的文件指针也可以理解为文件内部记录读取或者写入的当前位置，不然程序如何知道下一次该从文件的什么位置开始读取或者写入呢？
在读写文件的时候，每读取或者写入一个字节，磁盘 文件指针就会向后移动一个字节。可以通过控制指针的位置，以便在我们需要的位置进行读写文件。

文件流提供以下成员函数来读取或配置文件指针：
tellg()      返回读取文件指针的当前位置
tellp()      返回写入文件指针的当前位置
seekg(指针偏移量)      将读取文件指针移到指定位置
seekg(指针偏移量，参照位置)      将读取文件指针移到指定位置
seekp(指针偏移量)      将写入文件指针移到指定位置
seekp(指针偏移量，参照位置)  将写入文件指针移到指定位置
这些成员函数名和参数，容易混淆，下面就简单解释一下：

备注：以上函数 最后一个字母不是g就是p，代表什么意思呢？其中，g代表get，表示读取；p代表put，表示写入。
另外，函数参数 “文件 位置”和“指针偏移量”为 long整型，以字节为单位。“参照位置”是一个有以下值的枚举：
ios::beg      文件开头计算偏移量
ios::cur       文件当前位置计算偏移量
ios::end      文件结尾计算偏移量
其中，函数seekg(指针偏移量) 和 seekp(指针偏移量)，默认从文件开头计算偏移量。
代码见附件！

3、使用文件指针获取文件大小：
原理：文件结尾的位置，就代表从文件开始的位置到结尾的字节数，即文件的大小！
代码见附件！

4、小作业：
通过文件读写的方式，自己实现一个函数，实现文件的拷贝功能。

## 四十六、C++容器之动态数组vector①

1、为什么有vector？什么是动态数组vector？
既然是数组，那么我们先来说说数组的概念，关于数组咱们之前讲解过，例如，一个int的数组，定义如下：
int arr_int[100] = {0};
对吧？这个数组里面有100个元素，那如果我这个学校有1000个学生，那么可能我就要定义数组的大小是1000个，本身是普通的数组，所以要求在定义的时候就给定大小。不然系统无法判断数组所占用的内存。但是现实生活中往往有很多时候是确定不了大小的，例如qq的服务器，他要同时接受N多人的连接，全国有上亿的人登陆qq，那么如果让你定义一个数组的话，你要定义多少？固定大小的话定义多少都不合适，本身数量在增长，是个动态的大小。定义太大了浪费空间，定义太小了还不够用。所以动态数组vector就为我们解决了这个问题。他是容量大小动态变化的数组，定义vector对象的时候先不用指定数组的大小，有数据的话就往数组里面插入就可以了。vector内部自己管理存储空间，不用你操心了。

2、vector 的头文件和命名空间：
#include <vector> //注意，没有 .h
using namespace std; //在 std 标准命名空间中

3、vector 的定义：
刚才给大家说了，vector是动态数组，但是并没有说vector是什么类型的数组，那么他的类型到底是什么呢？其实他能够适应任何类型！他是一个类模板，例如：
vector<int> arr_int; //定义了一个内部元素是int的动态数组；
vector<char> arr_char; //定义了一个内部元素是char的动态数组；
vector<CStudent> arr_student; //定义了一个内部元素是CStudent的动态数组；
vector<char*> arr_pchar; //定义了一个内部元素是char*的动态数组；
复制代码

怎么样？这个类模板非常方便吧，要什么类型就来什么类型，而且容量大小没有限制！

4、vector 的初始化：
初始化的方法也是有多种，咱们到 http://www.cplusplus.com/reference/vector/vector/ 这里面来看下，找到其构造函数的链接：http://www.cplusplus.com/reference/vector/vector/vector/
咱们来一一实现一下，具体演示见视频教程！
#include <vector>
int main (int argc, char* argv[])
{
  std::vector<int> one;                                //定义一个空的、元素类型是 int 的 vector 动态数组
  std::vector<int> two(4,100);               //定义一个包含4个元素，每个元素的值都是100的 vector 动态数组
  std::vector<int> three(two.begin(),two.end());  //使用 two 这个对象的迭代器，从开始到结束的所有元素来初始化当前对象
  std::vector<int> four(three);                       // 使用 three 这个对象来初始化当前对象

  int myints[] = {16,2,77,29};
  std::vector<int> five (myints, myints + sizeof(myints) / sizeof(int) ); //使用一个普通的 int 数组来初始化当前对象

  return 0;
}
复制代码


5、小作业：
使用之前课程中讲解的 CStudent 类型来定义多个 vector 动态数组，并进行初始化操作！

## 四十七、C++容器之动态数组vector②
1、vector 的的常用基本操作：
vector<int> arr_int;
① arr_int[idx] 或 arr_int.at(idx) //返回动态数组中下标为 idx 的 arr_int[idx] 元素的值
② arr_int.size();        //返回 arr_int 数组元素的总个数
③ arr_int.front();        //返回 arr_int 数组的第一个元素的值
④ arr_int.back();        //返回 arr_int 数组的最后一个元素的值
⑤ arr_int.clear();        //清空 arr_int 数组，即把里面的所有元素都删除
⑥ arr_int.begin();        //返回 arr_int 数组第一个数的下标
⑦ arr_int.end();        //返回 arr_int 数组最后一个数的下标
⑧ arr_int.empty();        //判断 arr_int 数组是否为空，如果为空则返回true，非空（有元素）则返回false
⑨ arr_int.swap(v1);    //v1是另一个动态数组，将 arr_int 和 v1 两个动态数组的元素互换
⑩ swap(arr_int, v1);    //同⑨

示例代码：见附件！

注意：vector 的下标跟普通数组一致，是从 0 开始的！
备注：代码详细讲解详见视频教程！

2、vector 的动态插入：
vector 支持的动态插入也有多种方式：
①、调用 push_back 在尾部插入一个元素，只能是一个一个插入：arr_int.push_back(3);
②、调用 insert 在下标为1的前面插入一个元素，arr_int.insert(arr_int.begin()+1, 888);
③、调用 insert 在下标为2的前面插入3个888元素，arr_int.insert(arr_int.begin()+2, 3, 888);
③、调用 insert 在下标为2的前面插入N个元素：
代码见附件！

怎么样？很灵活吧，其实有了上面的 insert 已经可以兼容到各个方面了！

3、vector 的动态删除：
①、arr_int.pop_back();    //删除 arr_int 动态数组的最后一个元素
②、arr_int.erase(v.begin()+k); //删除 arr_int 动态数组的下标为 k 的元素，返回下一个位置的迭代器
③、arr_int.erase(v.begin()+l, v.end()-r); //删除 arr_int 动态数组中下标 [l,v.end()-r) 的元素

4、vector 的遍历：
①、因为是 vector 也是数组，所以可以使用索引下标来遍历，如下：
②、使用迭代器遍历：

5、小作业：
定义一个 int 类型的 vector 动态数组，将以下元素：1, 4, 3, 7, 9, 3, 6, 8, 3, 5, 2, 3, 7 插入到动态数组中。之后，使用 for 循环删除动态数组 值为 3 的元素，并将结果输出出来！

## 四十八、C++容器之链表list①
1、为什么要有list链表，list 和 vector 有什么区别？
有很多网友会说，咱们之前不是讲解过vector了吗？动态的数组，而且数目也可以一直增加，已经够用了吧，以后只要是数目不确定的我就用vector就行了，为什么本节课又出来个list链表呢？他们有什么区别？

实际上他们适用的场合不同，这里面说明下：
①、vector 本身虽然是动态数组，但是归根结底他也是数组，对不对？所以数组最基本的特征他要满足，不然就不能称之为数组，最基本的特征就是内存连续，这个特征对于数组来说有优点也有缺点。优点是因为内存连续，每个元素的大小是确定的，所以，我知道了数组的首地址之后，就可以通过下标索引快速的定位到数组 任意一个元素，比如第5个元素，那么就 a[4]，第234个元素就是 a[233]，因为内存连续，所以可以直接通过下标计算出后面的元素相对于首地址的偏移，所以对于数组来说随机的访问数组 任意一个元素是比较快的。那么缺点呢？就是在插入数据的操作。如果我想在vector的中间插入n个元素，那么为了保持数组固有的内存连续的特性，所以元素插入到中间之后，后面的原有的元素只能大面积的依次向后挪，所以这就造成效率低下。举个例子：数组中原有的元素有：0,1,2,3,4,5,6,7,8,9，如果我想在5的前面插入3个8，那么数组就变成：0,1,2,3,4,8,8,8,5,6,7,8,9，看到了吧，3个8插入进去了，但是后面的5,6,7,8,9要依次往后挪，这就是数组插入时候的效率问题。

②、list 链表呢，本身是链表，所以内存是不连续的，其元素是一个一个的结点在内存中离散的分布。各个结点之间是通过元素内部的指针指过去的，所以对于list来说，如果我想快速的定位到指定的元素，那么他做不到！只能从头到尾的去遍历，通过第1个元素去找第2个元素，通过第2个元素去找第3个元素，以此类推，直到找到你要的元素才行。以上就是list的缺点。优点呢，既然有缺点就应该有优点，优点就是在内部随机的插入元素的时候比较快，因为只需要把插入位置的前后两个节点的指针断开，之后跟新插入的结点连上就可以了，不用大面积的移动其他元素的内存，这就是优点。

③、所以，通过以上两点的说明，大家可以根据自己具体的场合来选择到底是用 vector 还是用 list，尽量提高程序的性能。


2、list 的头文件和命名空间：
#include <list> //注意，没有 .h
using namespace std; //在 std 标准命名空间中

3、list 的定义：
list 是动态链表，跟 vector 一样，[b]他也能够适应任何类型[/b]！他是一个类模板，例如：
list<int> list_int; //定义了一个内部元素是int的链表；
list<char> list_char; //定义了一个内部元素是char的链表；
list<CStudent> list_student; //定义了一个内部元素是CStudent的链表；
list<char*> list_pchar; //定义了一个内部元素是char*的链表；
复制代码

怎么样？这个类模板非常方便吧，要什么类型就来什么类型，而且容量大小没有限制！

4、list 的初始化：
初始化的方法也是有多种，咱们到 http://www.cplusplus.com/reference/list/list/ 这里面来看下，找到其构造函数的链接：http://www.cplusplus.com/reference/list/list/list/
咱们来一一实现一下，具体演示见视频教程！
#include <list>
int main (int argc, char* argv[])
{
  std::list<int> one;                                //定义一个空的、元素类型是 int 的 list 链表
  std::list<int> two(4,100);               //定义一个包含4个元素，每个元素的值都是100的 list 链表
  std::list<int> three(two.begin(),two.end());  //使用 two 这个对象的迭代器，从开始到结束的所有元素来初始化当前对象
  std::list<int> four(three);                       // 使用 three 这个对象来初始化当前对象

  int myints[] = {16,2,77,29};
  std::list<int> five (myints, myints + sizeof(myints) / sizeof(int) ); //使用一个普通的 int 数组来初始化当前对象

  return 0;
}
复制代码


5、小作业：
能不能通过 list 的构造函数，实现将一个 vector 对象里面的内容赋值给 list 对象呢？大家课后试试吧！

## 四十九、 C++容器之链表list② 
1、list 的的常用基本操作：
list<int> list_int;
① list_int.size();        //返回 list_int 链表元素的总个数
② list_int.front();        //返回 list_int 链表的第一个元素的值
③ list_int.back();        //返回 list_int 链表的最后一个元素的值
④ list_int.clear();        //清空 list_int 链表，即把里面的所有元素都删除
⑤ list_int.begin();        //返回 list_int 链表第一个数的迭代器
⑥ list_int.end();        //返回 list_int 链表最后一个数的迭代器
⑦ list_int.empty();        //判断 list_int 链表是否为空，如果为空则返回true，非空（有元素）则返回false
⑧ list_int.swap(v1);    //v1是另一个动态链表，将 list_int 和 v1 两个链表的元素互换
⑨ list_int.reverse();     //把 list  元素顺序倒转
⑩ list_int.sort();                    // 给list排序
a list_int.splice(list_int.begin(), list_2); //将两个list合并

示例代码：见附件！

备注：代码详细讲解详见视频教程！

2、list 的动态插入：
list 支持的动态插入也有多种方式：
①、调用 push_back 在尾部插入一个元素，只能是一个一个插入：list_int.push_back(3);
①、调用 push_front 在头部插入一个元素，只能是一个一个插入：list_int.push_front(2);
②、调用 insert 在第一个元素的前面插入一个元素，list_int.insert(list_int.begin(), 888);
③、调用 insert 在第一个元素的前面插入3个888元素，list_int.insert(list_int.begin(), 3, 888);
示例代码见附件！

怎么样？很灵活吧，其实有了上面的 insert 已经可以兼容到各个方面了！

3、list 的动态删除：
①、list_int.pop_back();    //删除 list_int动态链表的最后一个元素
②、list_int.erase(list_int.begin()); //删除第一个元素
③、list_int.erase(itor, list_int.end()); //删除中间的元素

4、list 的遍历：
因为是 list 不是数组，所以不能用下标来遍历，只能用迭代器来遍历，如下：
for (list<int>::iterator itor =list_int.begin(); itor !=list_int.end(); ++itor)
{
    int value = *itor;
    cout << "value = " << value << endl;
}

5、小作业：
定义一个 int 类型的 list 动态链表，将以下元素：1, 4, 3, 7, 9, 3, 6, 8, 3, 5, 2, 3, 7 插入到动态链表中。之后，使用 for 循环删除动态链表 值为 3 的元素，并将结果输出出来！

## 五十、C++容器之映射map
1、什么是 map，他跟 vector 和 list 有什么区别？什么情况下使用 map？
map提供的是一种键值对的容器，里面的数据元素都是成对出现的，即：key-value，在知道 key 的情况下能迅速的找到 value，他们是一一对应的关系。
如下图：第一个值称之为关键字(key)，每个关键字只能在map中出现一次，是唯一的；第二个称之为该关键字的对应值：


例如：学校 学生，用学生的什么信息作为 key 呢？可以用学号，在校的学生学号不可能重复，所以可以用学号作为key，学生的姓名或者学生信息作为value，value可以重复，可以相同，毕竟有重名的情况发生。

2、map 的使用场景：
优点查找起来很快：根据 key 值快速查找记录，查找的复杂度基本是 Log(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。怎么样快吧？所以，当大家以后的工程中有比较多的使用想快速查找的话可以使用map。

3、map的头文件和命名空间：
#include <map> //注意，没有 .h
using namespace std; //在 std 标准命名空间中

4、map的定义：
一般情况下，都是定义一个空的 map 对象，例如：
map<int, char> stud_sex_map;
定义完了之后再使用，map也是个模板类，所以他也是支持各种类型的。

5、map的使用：
定义完了之后我们就可以开始使用了，例如：
int main(int argc, char* argv[])
{
    map<int, char> stud_sex_map;
    stud_sex_map[10010] = 'm'; //赋值
    stud_sex_map[10011] = 'f';
    int n_size = stud_sex_map.size(); //返回容器的元素个数
    stud_sex_map.empty(); //检测容器是否为空

    char sex = stud_sex_map[10010];
    sex = stud_sex_map[10012]; //这个值会是多少呢？
    
    if (stud_sex_map.count(10012) <= 0) //判断容器中是否有某个元素
    {
        stud_sex_map[10012] = 'f';
    }
    
    sex = stud_sex_map[10012];
    
    return 0;
}
复制代码


6、map的删除：
删除的话首当其冲的肯定是erase方法了。erase 方法支持 key 删除和迭代器删除，例如：
stud_sex_map.erase(10010);
stud_sex_map.erase(stud_sex_map.begin());

7、map的遍历：
因为是 map 不是数组，所以不能用下标来遍历，只能用迭代器来遍历，如下：
for (map<int, char>::iterator itor = stud_sex_map.begin(); itor != stud_sex_map.end(); ++itor)
{
    int key = itor->first;
    char ch = itor->second;
    cout << "key = " << key << ", value = " << ch << endl;
}

8、小作业：
定义一个 map<int, char> 类型的对象：
依次存入以下内容：
10010->'m'
10011->'f'
10012->'f'
10013->'m'
10014->'f'
10015->'m'

之后，使用 for 循环删除map value值为 'f' 的元素，并将结果输出出来！

## 五十一、C++ 字符串类stirng①
1、string概述：
之前给大家讲解过字符数组 char szbuf[] = "hello world."; 可以表示字符串，也可以使用指针 char* p = "hello world."; 但是这些操作方式对于非常基本的字符串表示可能够了，但是针对我们平时编程过程中遇到的各种各样的字符串操作就显得捉襟见肘，不太够用了。比如，字符串的连接，比较，拷贝等等，都得借助其他函数，strcat，strcmp，strcpy 等等，而且还要判断目标的字符数组空间大小是否够用，不够用了还得重新申请等等。那么有没有现成的封装好的字符串类呢？C++都都提供了 vector、list、queue、map 等各种各样的容器，难道就没有一个字符串的类吗？答案当然是有的，那就是 string。string 是C++ STL 标准模板库提供的，所以其与C++ 各种输入输出，各种容器等都是兼容适配的，使用起来也非常方便。

2、string的头文件和命名空间：
#include <string> //注意，没有 .h
using namespace std; //在 std 标准命名空间中

3、string对象的定义：
string str(const char *s);    //用C语言 字符串 s 初始化 string 对象
string str(int n, char c);     //用 n个字符c初始化 string对象 str
此外，string类还支持默认构造函数和拷贝构造函数，例如：
string s1;
string s2 = "hello";
以上都是正确的写法。怎么样很方便吧？

4、string字符串的字符相关操作：
可以使用 at 方法或者 [ ]操作符来访问string对象 某个位置的字符，例如：
string str = "abcdefg";
char ch1 = str.at(0);
char ch2 = str[1];
另外，刚才给大家说了，可以使用一个 char * 字符串来初始化 string 对象，那么反过来呢，能不能从一个 string 对象得到 char * 的指针？因为有的函数需要用 char * 而不是 string，下面教大家来操作下：
char* pstr = str.c_str();

5、string字符串的基本信息：
string 的 size() 方法返回字符串的长度，empty() 方法返回字符串是否为空。同时 string 支持输入与输出流操作：
string str = "123";
int n_size = str.size();
bool is_empty = str.empty();
cout << str << endl;
cin >> str;
cout << str << endl;

6、string字符串的赋值操作：
string &operator=(const string &s);    //把字符串s赋给当前字符串
string &assign(const char *s);                //用C类型字符串s赋值
string &assign(const char *s,int n);        //用C字符串s开始的n个字符赋值
string &assign(const string &s);            //把字符串s赋给当前字符串
string &assign(int n, char c);                    //用n个字符c赋值给当前字符串
string &assign(const string &s, int start, int n);    //把字符串s中从start开始的n个字符赋给当前字符串
string &assign(const_iterator first,const_itertor last);    //把 first 和 last 迭代器之间的部分赋给字符串

平时常用的就是 = 号操作符，当然 assign 函数更灵活一些，所以大家可以选择性的使用。
备注：相关代码演示详见视频教程！

7、string字符串的连接：
string &operator+=(const string &s);    //把字符串s连接到当前字符串的结尾
string &append(const char *s);            //把c类型字符串s连接到当前字符串结尾
string &append(const char *s,int n);    //把c类型字符串s的前n个字符连接到当前字符串结尾
string &append(const string &s);    //同operator+=()
string &append(const string &s,int pos,int n);    //把字符串s中从pos开始的n个字符连接到当前字符串的结尾
string &append(int n,char c);        //在当前字符串结尾添加n个字符c
string &append(const_iterator first,const_iterator last);    //把迭代器first和last之间的部分连接到当前字符串的结尾

如果大家对string的赋值操作都理解了的话，那么这个连接的操作跟赋值没什么太大的区别，就是把 = 换成 +=，把 assign 换成 append，对吧？
备注：相关代码演示详见视频教程！

8、string字符串的比较：
bool operator==(const string &s1, const string &s2) const;    //比较两个字符串是否相等
运算符 ">","<",">=","<=","!=" 均被重载用于字符串的比较；

int compare(const string &s) const;    //比较当前字符串和s的大小
int compare(int pos, int n, const string &s) const;    //比较当前字符串从pos开始的n个字符组成的字符串与s的大小
int compare(int pos, int n, const string &s, int pos2, int n2) const;    //比较当前字符串从pos开始的n个字符组成的字符串与s中pos2开始的n2个字符组成的字符串的大小
int compare(const char *s) const;    //跟C类型的字符串 s 做比较
int compare(int pos, int n, const char *s) const;    //比较当前字符串从pos开始的n个字符组成的字符串与C类型的字符串 s 的大小
int compare(int pos, int n, const char *s, int pos2) const;    //比较当前字符串从pos开始的n个字符组成的字符串与C风格字符串 s 中pos2开始的n2个字符组成的字符串的大小
compare 函数在 > 时返回1，< 时返回 -1，== 时返回 0

当然，一般情况下载比较字符串的时候直接使用 ==、>、>=、<、<=、!= 等操作符的几率会高一些，不过 compare 更细致更灵活一些。
备注：相关代码演示详见视频教程！


## 五十二、C++ 字符串类stirng②
1、string字符串的求子串操作：
string substr(int pos = 0, int n = npos) const;    //返回 pos 开始的 n个字符组成的字符串
string str = "abcdefg";
string sub = str.substr(2, 2);
cout << sub << endl;

2、string字符串类的查找操作：
int find(char c, int pos = 0) const;    //从pos开始查找字符c在当前字符串的位置
int find(const char *s, int pos = 0) const;    //从pos开始查找字符串s在当前串 位置
int find(const char *s, int pos, int n) const;    //从pos开始查找字符串s中前n个字符在当前串 位置
int find(const string &s, int pos = 0) const;    //从pos开始查找字符串s在当前串 位置
//查找成功时返回所在位置，是个 >=0 的数，失败返回 string::npos 的值。npos 的值默认就是  -1

此外，string字符串类还提供了反向查找的函数  rfind，大家可以课后来尝试下，使用方法跟 find 几乎一致。
备注：相关代码演示详见视频教程！

3、string字符串类的替换操作：
string &replace(int p0, int n0, const char *s);    //删除从p0开始的n0个字符，然后在p0处插入串s
string &replace(int p0, int n0, const char *s, int n);    //删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符
string &replace(int p0, int n0, const string &s);    //删除从p0开始的n0个字符，然后在p0处插入串s
string &replace(int p0, int n0, const string &s, int pos, int n);    //删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符
string &replace(int p0, int n0, int n, char c);    //删除p0开始的n0个字符，然后在p0处插入n个字符c
string &replace(iterator first0, iterator last0, const char *s);    //把 [first0，last0）之间的部分替换为字符串s
string &replace(iterator first0, iterator last0, const char *s, int n);    //把 [first0，last0）之间的部分替换为s的前n个字符
string &replace(iterator first0, iterator last0, const string &s);    //把 [first0，last0）之间的部分替换为串s
string &replace(iterator first0, iterator last0, int n, char c);    //把 [first0，last0）之间的部分替换为n个字符c
string &replace(iterator first0, iterator last0, const_iterator first, const_iterator last);    //把 [first0，last0）之间的部分替换成 [first，last）之间的字符串
备注：相关代码演示详见视频教程！

4、string字符串类的插入操作：
string &insert(int p0, const char *s);
string &insert(int p0, const char *s, int n);
string &insert(int p0, const string &s);
string &insert(int p0, const string &s, int pos, int n);
//前4个函数在p0位置插入字符串 s 中 pos 开始的前 n 个字符

string &insert(int p0, int n, char c);    //此函数在p0处插入n个字符c
iterator insert(iterator it, char c);    //在it处插入字符c，返回插入后迭代器的位置
void insert(iterator it, const_iterator first, const_iterator last);    //在it处插入[first，last）之间的字符
void insert(iterator it, int n, char c);    //在it处插入n个字符c
备注：相关代码演示详见视频教程！

5、string字符串类的删除操作
iterator erase(iterator first, iterator last);    //删除 [first，last）之间的所有字符，返回删除后迭代器的位置
iterator erase(iterator it);    //删除it指向的字符，返回删除后迭代器的位置
string &erase(int pos = 0, int n = npos);    //删除pos开始的n个字符，返回修改后的字符串
备注：相关代码演示详见视频教程！

6、小作业：
将以下字符串以#号为分隔符进行分割，将分割后的各个子串的结果存储到一个 vector 中，字符串如下：
123#ab#cctry.com#



参考：https://www.cctry.com/forum-140-1.html
