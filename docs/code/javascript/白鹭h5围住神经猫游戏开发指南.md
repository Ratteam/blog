## Egret引擎介绍

免费

开源

跨平台

使用TypeScript开发

结构简单

## 开发工具安装

安装node.js

安装egret引擎

## egret命令行介绍

egret help 查看命令

create                        创建新项目

build                         构建指定项目,编译指定项目的 TypeScript 文件

publish                       发布项目，使用GoogleClosureCompiler压缩代码

run                           启动HttpServer,并在默认浏览器中打开指定项目

clean                         重置项目中的引擎代码

create_lib                    创建新第三方库项目

create_app                    从h5游戏生成app

upgrade                       升级项目代码

make                          编译引擎源码

info                          获得Egret信息

## 创建第一个egret项目

```
egret create demo
```

**各文件含义**

- egretProperties.json：项目配置文件

- src：项目源代码目录。source code的缩写。

- libs：项目运行库。

  项目各模块所对应的所有类库。对egretProperties.json进行修改后，需要用project->build engine来重新生成项目运行库。

- bin-debug：项目编译目录。

  这文件夹包含调试运行过程中会调用到的所有文件。其中源代码目录的文件会被编译到bin-debug/src目录中。bin-debug/lib有个列表文件，用来列出项目需要的所有运行库文件。

- esource：项目资源目录。

  存放项目运行所需要的所有资源。包括图片和配置文件。通常在资源目录建立一个资源清单文件，默认为resource.json。
  图片或声音等资源文件的默认目录为resource/assets。配置数据文件的默认存储目录为resource/config。

- bin-release：项目发布目录。

## egret的事件机制

在Egret中，事件模型定义了一套标准的生成和处理事件消息的方法，使程序中的对象可以相互交互，通信，保持自身状态和相应变化。简单的说，数据的提供者只管发出数据对象，只要确保数据对象是 egret.Event 类或者子类的实例即可。这种数据对象 ，称为事件（Event）。数据对象的发出者，称之为事件发送者（Event dispatcher）。同时，接受事件的对象，称为 事件侦听者（Event listener)。

## 开发工具

egret工具集

## 围住神经猫游戏
用egret白鹭引擎写的围住神经猫h5游戏，使用的egret版本为5.2.11

github地址:https://github.com/Ratteam/nervecat.git

## 游戏资源处理

打开EgretWing，点击文件——新建项目

打开cmd控制台——输入`egret run -a`将项目启动

将游戏声音资源放到：resource\assets\audio

将图片文件资源放到：resource\assets\img

## 加载游戏资源

打开resource\default.res.json配置文件

将默认资源移除，将audio和img拖拽到资源列表

查看audio和img内资源是否都加载到配置中了，如果没有加载成功。请用手动拖拽资源到右边配置文件中

## 图片纹理集的处理

## 开始游戏界面制作
nervecat\src\Main.ts
```
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICESLOSS OF USE, DATA,
//  OR PROFITS OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////

class Main extends egret.DisplayObjectContainer {
    /**
    * 构造函数，创建对象时初始化对象
    */
    public constructor() {
        super()
        this.addEventListener(egret.Event.ADDED_TO_STAGE, this.onAddToStage, this)
    }
    /**
    * 访问构造函数结束后，通过addEventListener指定的回调调用该函数
    */
    private onAddToStage(event: egret.Event) {
        // 生命周期管理器 egret.lifecycle
        egret.lifecycle.addLifecycleListener((context) => {
            context.onUpdate = () => {
                // console.log(context);
            }
        })
        // 进入后台时调用
        egret.lifecycle.onPause = () => {
            console.log("app 进入后台");
            egret.ticker.pause()// 关闭渲染与心跳
        }
        // 进入前台时调用
        egret.lifecycle.onResume = () => {
            console.log("app 进入前台");
            egret.ticker.resume()// 打开渲染与心跳
        }
        // 调用开始游戏方法，捕捉异常
        this.runGame().catch(e => {
            console.log(e)
        })
    }
    /**
     * 开始游戏方法
     */
    private async runGame() {
        // 加载资源
        await this.loadResource()
        // 创建游戏场景
        this.createGameScene()
    }
    /**
     * 加载资源文件
     */
    private async loadResource() {
        try {
            // loading显示
            const loadingView = new LoadingUI()
            this.stage.addChild(loadingView)
            // 加载资源配置文件
            await RES.loadConfig("resource/default.res.json", "resource/")
            // 指定资源组
            await RES.loadGroup("preload", 0, loadingView)
            // loading隐藏
            this.stage.removeChild(loadingView)
        }
        catch (e) {
            console.error(e)
        }
    }

    /**
     * 创建游戏场景
     */
    private createGameScene() {
        // 显示对象容器
        let container: egret.DisplayObjectContainer = new egret.DisplayObjectContainer()
        // 将显示对象容器添加到页面
        this.addChild(container)
        // GameUtil类文件在game-nerve-cat-master\src\common\GameUtil.ts
        let bg: egret.Bitmap = GameUtil.createBitmapByName('bg', 'jpg')
        // 将背景图放到显示对象容器中
        container.addChild(bg)
        // 因为使用了fixedWide模式，自己根据舞台宽高，重新设置背景图片大小（会被裁剪）
        // 获取舞台宽度
        let ratioW = GameUtil.getStageWidth() / bg.width
        // 获取舞台宽度
        let ratioH = GameUtil.getStageHeight() / bg.height
        // 获取舞台比例
        let ratio = bg.width / bg.height
        // 比对比例更改页面显示
        if (ratioW > ratioH) {
            bg.width = GameUtil.getStageWidth()
            bg.height = bg.width / ratio
        } else {
            bg.height = GameUtil.getStageHeight()
            bg.width = bg.height * ratio
        }
        bg.x = (GameUtil.getStageWidth() - bg.width) / 2
        // 设置存放游戏场景的容器
        // SceneController类文件在game-nerve-cat-master\src\game\SceneController.ts
        SceneController.instance.setStage(container)
        // 初始化游戏显示游戏场景
        SceneController.initGame()
    }
}
```

## 游戏背景界面制作

```

```

## 游戏成功面板制作

## 游戏失败面板制作

## 游戏结束面板制作

## 神经猫的动画资源处理

## 制作神经猫动画

## 算法工具类的编写

## 地图元素制作

## 地图排序算法编写

## 视图管理器

## 其他界面逻辑

## 数据管理器的创建

## 创建寻路数据元素

## 创建寻路算法AI类

## 寻找周围可走范围算法

## 判断出口点算法

## 随机走路算法

## 寻找最短路径算法

## 文档类的编写

## 激活视图管理器

## 编写游戏开始逻辑

## 编写地图事件响应函数

## 测试游戏

## 美化界面

## 将游戏打包

