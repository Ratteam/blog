<TOC />

### CRUD
### JOIN、LEFT JOIN 、RIGHT JOIN、INNER JOIN
### UNION
### GROUP BY + COUNT + WHERE 组合案例
### [常用 MySQL 函数，如：now()、md5()、concat()、uuid()等](https://www.w3schools.com/sql/sql_ref_mysql.asp)
### `1:1`、`1:n`、`n:n` 各自适用场景
### 了解触发器是什么，说个使用场景
### 数据库优化手段
### 索引、联合索引（命中条件）
### 分库分表（`水平分表`、`垂直分表`）
### 分区
### 会使用 `explain` 分析 SQL 性能问题，了解各参数含义
### 重点理解 `type`、`rows`、`key`
### Slow Log（有什么用，什么时候需要）
### MSSQL(了解)
### 查询最新5条数据
### NOSQL
### Redis、Memcached、MongoDB
### 对比、适用场景（可从以下维度进行对比）
### 持久化
### 支持多钟数据类型
### 可利用 CPU 多核心
### 内存淘汰机制
### 集群 Cluster
### 支持 SQL
### 性能对比
### 支持事务
### 应用场景
### 你之前为了解决什么问题使用的什么，为什么选它？

## 服务器篇

### 服务器
```
心中有概念，然后足够的实际操作。
Apache
[百度百科介绍](https://baike.baidu.com/item/apache/6265)
Nginx
[百度百科介绍](https://baike.baidu.com/item/nginx/3817705)
```
```
### 查看 CPU、内存、时间、系统版本等信息
### find 、grep 查找文件
### awk 处理文本
### 查看命令所在目录
### 自己编译过 PHP 吗？如何打开 readline 功能
### 如何查看 PHP 进程的内存、CPU 占用
### 如何给 PHP 增加一个扩展
### 修改 PHP Session 存储位置、修改 INI 配置参数
### 负载均衡有哪几种，挑一种你熟悉的说明其原理
### 数据库主从复制 M-S 是怎么同步的？是推还是拉？会不会不同步？怎么办
### 如何保障数据的可用性，即使被删库了也能恢复到分钟级别。你会怎么做。
### 数据库连接过多，超过最大值，如何优化架构。从哪些方便处理？
### 502 大概什么什么原因？ 如何排查  504呢？
```

## 架构篇
```
### 偏运维（了解）：
    ### 负载均衡（Nginx、HAProxy、DNS）
    ### 主从复制（MySQL、Redis）
    ### 数据冗余、备份（MySQL增量、全量 原理）
    ### 监控检查（分存活、服务可用两个维度）
    ### MySQL、Redis、Memcached Proxy 、Cluster 目的、原理
    ### 分片
    ### 高可用集群
    ### RAID
    ### 源代码编译、内存调优
    
### php性能优化
```
php语言级的性能优化
优化点：少写代码，多用php自身能力
- 性能问题：自身代码冗余较多，可读性不佳，并且性能低。
- 为什么性能低：php代码需要编译解析为底层语言，这一过程每次请求都会处理一遍，开销大。
- 解决方案：多用php内置变量、常量、函数
- 测试方法：直接使用ab对比

优化点：php内置函数的性能优劣
- 性能问题：php内置函数，之间依然存在快慢差异
- 解决方案：多去了解php内置函数的时间复杂度
- 测试方法：对比isset()和array_key_exists()的性能差异
<?php
    $start = current_time();
    $i = 0;
    $arr = range(1, 200000);
    while($i<200000){
        ++$i;
        //isset($arr[$i]);
        array_key_exists($i,$arr);
    }
    $end = current_time();
    echo "Lost Time:". number_format($end-$start,3)###1000;
    echo "\n";
    function current_time(){
        list($usec, $sec) = explode(" ".microtime());
        return ((float)$usec + (float)$sec);
    }
?>
优化点：尽可能少用魔法函数
- 情况描述：php提供的魔法函数，性能不佳
- 为什么性能低：为了给php程序员省事，php语言为你做了很多
- 解决方案：尽可能规避使用魔法函数
- 测试方法：time php test.php
    - time  liunx命令
    - php 指定程序
    - test.php 指定文件 
    > 注意：php主要在返回值中看user耗时

优化点：产生额外开销在错误抑制符
- 情况描述：php提供的错误抑制符只是为了方便懒人
- @的实际逻辑：在代码开始前，结束后，增加Opcode,忽略报错
    vld php Opcode查看扩展:用于将Opcode显示出来
- 解决方案：尽量不要使用@错误抑制符
- 测试方法：php -dvld.active=1 -dvld.execute=0 at.php
    
- php 执行php的vld显示Opcode
    
优化点：避免在循环内做运算
- 情况描述：循环内在函数或运算会被重复执行
- 解决方案：在循环外获取需要在值，再给循环操作

优化点：减少计算密集型业务
- 情况描述：php不适合密集型的场景
- 为什么：php语言特性决定php不适合做大数据业务
- php适合场景：适合衔接webserver与sql

优化点：务必使用带引号字符串做键值
- 情况描述：php会将没有引号的键值当作常量，产生查找常量在开销。
- 解决方案：严格使用带引号作为键值

php周边问题的性能优化
- php周边有什么:
    - linux运行环境
    - 文件存储  硬盘
    - 数据库    mysql
    - 缓存      redis
    - 网络  

优化点：减少文件类操作
- 常见php场景在开销次序
读写内存 << 读写数据库 << 读写磁盘 << 读写网络数据

优化点：优化网络请求
- 网络请求的坑：
    1. 对方接口的不确定因素
    2. 网络稳定性
- 如何优化网络请求：
    - 设置超时时间
    1. 连接超时 <200ms
    2. 读超时   <800ms
    3. 写超时   <500ms
    - 将串行请求并行化
    1. 使用curl_multi_###()
    2. 使用swoole扩展

优化点：压缩php接口输出
- 如何压缩：使用Gzip即可
- 压缩的利于弊：利于我们的数据输出，Client段能更快获取数据;弊端为会有额外的CPU开销

优化点：缓存重复计算内容
- 什么情况下坐输出内容缓存：多次请求，内容不变情况

重叠时间窗口思想===并行
旁路方案===并行

php语言自身分析、优化
 php性能分析

工具:XHPorf（源自FackBook的php性能分析工具）
实践：通过分析Wordpress程序，做优化。
使用: php --ri xhprof   查看版本
在入口文件index.php添加

xhprof_enable();

// ...

$data = xhporf_disable();
include_once "/var/www/html/xhprof_lib/utils/xhprof_lib.php";
include_once "/var/www/html/xhprof_lib/utils/xhprof_runs.php";
$objXhprofRun = new XHProfRuns_Default();
$run_id = $objXhprofRun->save_run($data,"test");
var_dump($run_id);
查看xhp目录查看相关信息
参数：
    runction_name   函数名
    calls   被调用在次数
    InclWallTime    当流程走到该函数，之前和现在这个函数处理在总耗时
    ExclWallTime    这个函数执行了多少微秒

其他工具推荐：
    ab  压力测试
    vld opcode代码分析

php性能瓶颈解决方案：
    Opcode Cache:php扩展APC等
    peci.php.net    php扩展网站
    使用php扩展解决复杂的业务
    Runtime优化:HHVM

 Apache Benchmark(ab)

> ab是由Apache提供的压力测试软件。安装apache服务器时会自带该压测软件
- 使用方法: ./ab -n1000 -c100 http://www.baidu.com/
    - -n 请求数
    - -c 并发数
    - http 压测目标地址
    - -h 帮助 

###*返回参数说明**
- Requests per second（每秒接受请求数尽可能多）
- Time per request（每秒请求在耗时尽可能少）
```

### 缓存
```
    ### 工作中遇到哪里需要缓存，分别简述为什么
```
### 搜索解决方案
```
```
### 性能调优
```
```
### 各维度监控方案
```
```
### 日志收集集中处理方案
```
```
### 国际化
```
```
### 数据库设计
```
```
### [静态化如何实现的](https://blog.csdn.net/qq_39618306/article/details/79014438)
```
这里要说的静态化指的是页面静态化，也即生成实实在在的静态文件，
也即不需要查询数据库就可以直接从文件中获取数据，
指的是真静态。它的实现方式主要有两种：
一种是我们在添加信息入库的时候就生成的静态文件，也称为模板替换技术，
这种主要用在后台，用于一些基本上很少变化的信息上，
在添加信息的时候使用添加的信息来替换制定好的模板中的内容，
达到生成静态文件的目的，这样在前台访问该信息时，
可以直接从生成好的静态文件中获取信息，如一些CMS系统。
另外一种是用户在访问我们的页面时先判断是否有对应的缓存文件存在，
如果存在就读缓存，不存在就读数据库，同时生成缓存文件。
这种实现的主要原理是基于PHP中的ob缓冲技术来实现的，
当没有静态文件时，从数据库中读取，读取的数据使用OB缓存，
使用相关的函数从OB缓冲中读取数据，写入到文件中，形成静态文件。
当然这个过程中要考虑静态文件的缓存周期问题，
我们可以根据文件的最后修改时间和当前时间及设定的缓存时间来定时更新缓存文件。
```
### 静态化方案
```
```
### 画出常见 PHP 应用架构图
```
```

## 框架篇
```
### ThinkPHP（TP）、CodeIgniter（CI）、Zend（非 OOP 系列）
### Yaf、Phalcon（C 扩展系）
### Yii、Laravel、Symfony（纯 OOP 系列）
### Swoole、Workerman （网络编程框架）
### 对比框架区别几个方向点
    ### 是否纯 OOP
    ### 类库加载方式（自己写 autoload 对比 composer 标准）
    ### 易用性方向（CI 基础框架，Laravel 这种就是高开发效率框架以及基础组件多少） 
    ### 黑盒（相比 C 扩展系）
    ### 运行速度（如：Laravel 加载一大堆东西）
    ### 内存占用
```

## 设计模式
### php的设计模式
```
1. ###*单例模式**
一个类在整个应用中，只有一个对象实例的设计模式
类必须自行创建这个实例
必须自行向整个系统提供这个实例
###*三私**：私有静态成员变量、构造函数、克隆函数
###*一公**：公共的静态方法

2. ###*工厂模式**
可以根据输入的参数或者应用程序配置的不同,创建一种专门用来实例化并返回其它类的实例的类

3. 观察者模式
观察者模式提供了组件之间紧密耦合的另一种方法。
该模式：一个对象通过添加一个方法（该方法允许另一个对象，即观察者注册自己）全本身变得可观察。
当可观察的对象更改时，它会将消息发送到已注册的观察者。这些观察者使用该信息执行的操作与可观察的对象无关。

4. 命令链模式：
以松散耦合主题为基础，发送消息、命令和请求，或通过一组处理程序发送任意内容。
每个处理程序都会自行判断自己能否处理请求，如果可以，该请求被处理，进程停止。

5. 策略模式：
此算法是从复杂类提取的，因而可以方便地替换。
```

### 单例模式（重点）
```
```
### 工厂模式（重点）
```
```
### 观察者模式（重点）
```
```
### 依赖注入（重点）
```
```
### 装饰器模式
```
```
### 代理模式
```
```
### 组合模式
```
```

## 安全篇
```
### SQL 注入
### sql注入获取后台管理员账号密码
```
在完全拿下服务器主机之前，存在sql注入漏洞的网站，可能会因此提供给黑客后台管理员的账号密码，黑客登录后台后，上传木马，拿下整个主机。这是sql注入的一种应用场景。

以下讲解sql注入获取后台管理员账号密码的过程，本文以尽力对新手友好的展现过程来讲解基本原理，高手与百事通请避免观看，以免徒耗时间。

为避免读者惹上麻烦，已对原本目标网站信息进行涂抹，并提供笔者自己搭建的测试网站供有兴趣的朋友操作，换句话说，黑我的网站是合法的。

正式开始，在网站中，点击人才招聘，跳转到如下页面，同时地址栏url变为图中所示。

可以看到链接中传给服务器参数，id=2，此处逻辑一般为：服务器获取到id值为2，再通过id值返回给浏览器对应页面或内容，这个过程有可能会经过数据库。

首先惯常试试是否存在sql注入漏洞，将地址栏中的id=2更改为id=2'，即在值2后面添加单引号，回车看结果。

sweet，塔斯丁狗，服务器返回了数据库错误，并详细的打印了错误信息。由错误信息可以得知，网站使用了mysql数据库，并展示了具体的sql语句：

select ### from sy_page where 1 and id=2
这条语句表示：查询sy_page表里id为2的全部数据，而发生错误的原因则是因为多出的单引号使sql语句语法发生错误。

同时可以看出，我们只加过一个单引号'，上图错误信息却显示，实际sql语句中变为了\'反斜杠加单引号，这说明，服务器是做了特殊符号过滤的，以此来防sql注入，这确实起作用，我们便无法注入带有单引号双引号等特殊符号的语句，但其他的注入却是没问题的。

在确定存在sql注入漏洞后，对于查询语句，可以先确定查询的数据有多少列，通过如下图链接所示增加排序条件order by来探测，将地址栏中id=2改为id=2 order by 15，这将使原本的查询语句变成

select ### from sy_page where 1 and id=2 order by 15
这表示，在原来查询结果的基础上进行排序，排序的依据是第15列数据的值。

但实际结果却报错，显示不存在第15列，这正是我们追求的结果，说明查询的出数据不超过15列。

递减列数尝试，直到列数降为10時，才不再报错，如下图所示，说明数据有10列。

在得知列数后，便可以开启真正的掠夺了。那就是在原本的查询结果中加入自己的查询数据。如下图所示，将地址栏中

id=2
改为

id=2 union select 1,2,3,4,5,6,7,8,9,10

这样变化的意图是什么？举个例子，假如下图所示查询数据为网站本来正常的查询结果，id=852，从左至右刚好10列数据。

而加入union select 1,2,3,4,5,6,7,8,9,10后，查询结果便如下图所示。多出了一行结果为1 2 3 4 5 6 7 8 9 10的数据。

而网站中这行多出来的数据没有显示在页面上的原因是什么？可以想像，网站在获取到两行数据后只取了第一行的数据，因为网站根本没预料到会有两行以上的数据。那么我们只需要将自己的数据排到第一行，就可以替代网站本身的数据了。于是再做一次排序，继续追加一句order by 1，根据第一列的值进行排序，便产生如下结果

可以看到，我们自己的数据排到了最前面，这是因为我们自己构建的数据中，第一列的值为1，小于上图示例数据852，于是排到了前面。

随后拿到网站中测试，将

id=2
改为

id=2 union select 1,2,3,4,5,6,7,8,9,10 order by 1
可以看到，我们的内容替换掉了网站内容，第二列数据值2与第6列数据值6显示在了网站页面。

这两列显示数据便成了数据输出窗口。换言之，只需要将2和6的值替换为数据库实际内容，就可以输出到页面显示，被我们看见。

得知第2列和第6列会显示后，便可以开始尝试将2和6替换为系统表数据，将前面的

id=2 union select 1,2,3,4,5,6,7,8,9,10 order by 1
更改为

id=2 union select 1,table_schema,3,4,5,table_name,7,8,9,10 from information_schema.columns order by 1

这句表示，我们自己追加的数据不再是单纯的10个数字，而是从mysql的系统表columns中查询的数据，第二列与第六列分别显示columns表中的table_schema列与table_name列数据。table_schema列存储的是数据库名字信息，table_name列存储着表名信息。下图查询到的数据库名为information_schema，表名为character_sets

上面查询的columns表是mysql的系统表，里面存储着mysql中所有的表名及列信息，如下图的本机展示可以看到所有的表名，列名，列的数据类型，通过这个表，可以爆出所有的表名，列名，及所在数据库，是获取数据的突破口。

下图是一个本机测试，用的是前面爆网站表名的语句：

select ### from table1 where id=852 union select 1,table_schema,3,4,5,table_name,7,8,9,10 from information_schema.columns order by 1
可以看到，所有的表列数据被追加到我们自己的数据里，做个对比的话，下图最后一列数据就像网站正常显示的数据，其他的则是我们注入的数据。

那么如何把这么多行数据逐个爆出来呢？很明显依靠排序是不足以实现的，这时可以再在之前的查询语句后追加一个limit条件，如下图所示

limit m,n
表示筛选出从第m+1行开始的n行数据

limit 0,1
便表示筛选出第一行开始的一行数据，这样如下图就得到了第一行数据，换成limit 1,1则是筛选出第二行数据，以此类推，可以分别得出每一行的数据。

应用到网站中，发现从第41行开始不再是系统表，如下图所示，第41行爆出了数据库名sq_sydata，表名sy_admin

一行一行爆，如图展示，更改limit限定值会爆出其他的表名。

最后爆出了所有的表，如下图所示。

按照命名推断，sy_admin表必定是后台管理员账号表，既然columns系统表中存放着所有列信息，自然也可以用来将sy_admin表的列名爆出来，将

id=2 union select 1,table_schema,3,4,5,table_name,7,8,9,10 from information_schema.columns order by 1
中的table_schema（数据库名）替换为table_name（表名），table_name（表名）替换为column_name（列名），再尝试更改limit的限定值，直到更改为480時开始出现sy_admin表的内容，下图可以看到第481列（limit 480,1）爆出了sy_admin表的一个列名为id。

继续递增列爆481，得到列名loginname。

继续递增，最终爆出sy_admin表的所有列名，如下图所示。

可以推断，上图中的lpginname列应该是用户名，password则是登录密码。

ok，已经得到了sy_admin表的所有列名，接下来就可以开始获取sy_admin表中的实际数据了。

然后我们不再查询系统表，转向sy_admin表，如下图所示，将第二列替换为loginname，第六列替换为password，表名从系统表information_schema.columns（information_schema数据库中的columns表）更换为sq_sydata.sy_admin（sq_sydata数据库中的sy_admin表），再稍微更换limit限定条件，最终得到了后台管理员admin的密码，如下图所示

目标达成。

上图中加密后的密码可以通过工具或百度在线md5解密工具解密，不作赘述。

同样也可以更换列名查出其他的信息，比如下图所示登录次数27次，上次登录于2月1号。以及其他的东西，你懂的。
```
### xss攻击怎么防止
```
XSS又称CSS，全称Cross SiteScript(跨站脚本攻击)， XSS攻击类似于SQL注入攻击，
是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。
其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当用户浏览该网站时，
这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie信息、破坏页面结构
常见的恶意字符XSS输入：
1. XSS 输入通常包含 JavaScript 脚本，如弹出恶意警告框：
`<script>alert("XSS");</script>`
2. XSS 输入也可能是 HTML 代码段，譬如：
    (1) 网页不停地刷新 `<meta http-equiv="refresh" content="0;">`
    (2) 嵌入其它网站的链接，重定向到其它网站等。
方法：利用php htmlentities()函数
php防止XSS跨站脚本攻击的方法：是针对非法的HTML代码包括单双引号等，使用htmlspecialchars()函数。
```

### XSS 与 CSRF
```
```
### 输入过滤
```
```
### Cookie 安全
```
```
### 禁用 `mysql_` 系函数
```
```
### 数据库存储用户密码时，应该是怎么做才安全
```
```
### 验证码 Session 问题
```
```
### 安全的 Session ID （让即使拦截后，也无法模拟使用）
```
```
### 目录权限安全
```
```
### 包含本地与远程文件
```
```
### 文件上传 PHP 脚本
```
```
### `eval` 函数执行脚本
```
```
### `disable_functions` 关闭高危函数
```
```
### FPM 独立用户与组，给每个目录特定权限
```
```
### 了解 Hash 与 Encrypt 区别
```
```
### php在储存session以什么形式存在
```
PHP为session的存储提供了三种方式: 文件/ 内存/ 自定义存储,默认是使用文件存储.
在访问量大的网站上采用这种方式就不大合适,因为这样会导致大量的输入输出的冗余.
我们可以在php.ini更改配置文件或者php脚本中通过相应的函数来设置session文件的存储类型
来改变session文件的存储形式
```
### Session 共享、存活时间
```
https://blog.csdn.net/m_nanle_xiaobudiu/article/details/81177698
一、Session的原理
以下以默认情况举例：

session_start();之后，会生成一个唯一的session_id，每一个用户对应唯一一个session_id，每一个session_id对应服务器端的一个session文件。这个session文件存储着当前session_id的信息，比如下面，就存储了name和age的键值。

 

1、设置Session存储的引擎（本地服务器的文件还是redis等），【php.ini 文件】

[Session]
 
session.save_handler = files
 
session.save_path = /data/SessionLogs
 

2、默认情况下的Session的使用 

<?php
/**
 * session的使用
 * 默认情况（不更改session.save_handle参数时），是存储在文件file中的
 * 默认情况下使用session的情况（用户24分钟内没有刷新操作会过期）
 * 每个用户对应唯一session_id,每一个session_id对应服务器中存储的一个session文件，这个文件中存储了当前session_id的信息，比如下面，就存储了name和age的键值
 */
session_start();
echo session_id();
echo "<br>";
$_SESSION['age'] = 26;
$_SESSION['name'] = 'xiaobudiu';
var_dump($_SESSION);
 

3、在服务器中存储的形式是这样的



 

 

二、使用Redis存储Session
在网站访问量较大时，我们通常会做集群（比如nginx负载均衡等），这时，如何解决session会话的共享问题。

（1）使用ip_hash或者自定义key做负载均衡轮询策略是一个办法，但由于有时候用户可能走代理，所以这个方法其实并不是那么完美。

（2）另一个解决session共享问题的方法就是使用redis或者memcache缓存数据库去存储session，进而实现session共享问题。

 

1、设置php.ini 文件中的session.save_handle 和session.save_path

session.save_handler = Redis
 
session.save_path = "tcp://localhost:6379"
注1：如果连接的是远程redis，需要将localhost换成对应的远程ip地址。像这样，

session.save_handler = Redis
 
session.save_path =  "tcp://47.94.203.119:6379"
注2：如果为redis已经添加了auth权限（requirpass），session.save_path项则应该这样写

session.save_handler = Redis
 
session.save_path =  "tcp://47.94.203.119:6379?persistent=1&database=10&auth=myredisG506"
 

2、使用redis存储session信息

<?php
/**
 * 将session存储在redis中
 */
session_start();
echo session_id();
echo "<br>";
$_SESSION['age'] = 26;
$_SESSION['name'] = 'xiaobudiu';
$_SESSION['sex'] = 'man';
var_dump($_SESSION);
在redis上是以这样的形式进行存储的



 

注：

搭建nginx集群： https://blog.csdn.net/m_nanle_xiaobudiu/article/details/80862272

搭建mysql主从复制架构：https://blog.csdn.net/m_nanle_xiaobudiu/article/details/81086243

搭建redis集群： https://blog.csdn.net/m_nanle_xiaobudiu/article/details/81004557

 
 
三、使用Redis存储Session，并设置Session会话存活时间以及Session中某一元素存活时间
 

封装session类 b.php

<?php
 
 
/**
 * session控制类
 *
 */
 
class Session
{
 
    function __construct($lifetime = 3600)
    {
        //初始化设置session会话存活时间
        ini_set('session.gc_maxlifetime',$lifetime);
    }
 
    /**
     * 设置当前会话session的key-value
     * @param String $name   session name
     * @param Mixed  $data   session data
     * @param Int    $expire 有效时间(秒)
     */
    function set($name, $data, $expire = 600)
    {
        $session_data = array();
        $session_data['data'] = $data;
        $session_data['expire'] = time()+$expire;
        $_SESSION[$name] = $session_data;
    }
 
    /**
     * 读取当前会话session中的key-value
     * @param  String $name  session name
     * @return Mixed
     */
    function get($name)
    {
        if(isset($_SESSION[$name])) {
            if($_SESSION[$name]['expire'] > time()) {
                return $_SESSION[$name]['data'];
            }else{
                self::clear($name);
            }
        }
        return false;
    }
 
    /**
     * 清除当前session会话中的某一key-value
     * @param  String  $name  session name
     */
    function clear($name)
    {
        unset($_SESSION[$name]);
    }
 
    /**
     * 删除当前session_id对应的session文件（清空当前session会话存储）
     */
    function destroy()
    {
        session_destroy();
    }
 
}
 
session类的使用：d.php

<?php
 
require_once 'b.php';
 
session_start();
 
$session = new Session();
$session->set('wan','kkkk',1966);
 
$session->set('name','xiaobudiu');
$session->set('age',26);
$session->set('sex','man');
 
 
//输出当前会话的session存储数据
var_dump($_SESSION);
 
 
 
//unset掉某一个session属性
//$session->clear('name');
 
//删除当前session_id对应session文件
//$session->destroy();
//echo $session->get('sex');
 

redis中显示：

```

## 高阶篇

### GD库 图像处理扩展
```
[GD 和图像处理 函数](http://php.net/manual/zh/ref.image.php)
gd_info — 取得当前安装的 GD 库的信息
getimagesize — 取得图像大小
getimagesizefromstring — 从字符串中获取图像尺寸信息
image_type_to_extension — 取得图像类型的文件后缀
image_type_to_mime_type — 取得 getimagesize，exif_read_data，exif_thumbnail，exif_imagetype 所返回的图像类型的 MIME 类型
image2wbmp — 以 WBMP 格式将图像输出到浏览器或文件
imageaffine — 返回经过仿射变换后的图像，剪切区域可选
imageaffinematrixconcat — Concatenate two affine transformation matrices
imageaffinematrixget — Get an affine transformation matrix
imagealphablending — 设定图像的混色模式
imageantialias — 是否使用抗锯齿（antialias）功能
imagearc — 画椭圆弧
imagebmp — Output a BMP image to browser or file
imagechar — 水平地画一个字符
imagecharup — 垂直地画一个字符
imagecolorallocate — 为一幅图像分配颜色
imagecolorallocatealpha — 为一幅图像分配颜色 + alpha
imagecolorat — 取得某像素的颜色索引值
imagecolorclosest — 取得与指定的颜色最接近的颜色的索引值
imagecolorclosestalpha — 取得与指定的颜色加透明度最接近的颜色
imagecolorclosesthwb — 取得与给定颜色最接近的色度的黑白色的索引
imagecolordeallocate — 取消图像颜色的分配
imagecolorexact — 取得指定颜色的索引值
imagecolorexactalpha — 取得指定的颜色加透明度的索引值
imagecolormatch — 使一个图像中调色板版本的颜色与真彩色版本更能匹配
imagecolorresolve — 取得指定颜色的索引值或有可能得到的最接近的替代值
imagecolorresolvealpha — 取得指定颜色 + alpha 的索引值或有可能得到的最接近的替代值
imagecolorset — 给指定调色板索引设定颜色
imagecolorsforindex — 取得某索引的颜色
imagecolorstotal — 取得一幅图像的调色板中颜色的数目
imagecolortransparent — 将某个颜色定义为透明色
imageconvolution — 用系数 div 和 offset 申请一个 3x3 的卷积矩阵
imagecopy — 拷贝图像的一部分
imagecopymerge — 拷贝并合并图像的一部分
imagecopymergegray — 用灰度拷贝并合并图像的一部分
imagecopyresampled — 重采样拷贝部分图像并调整大小
imagecopyresized — 拷贝部分图像并调整大小
imagecreate — 新建一个基于调色板的图像
imagecreatefrombmp — 由文件或 URL 创建一个新图象。
imagecreatefromgd2 — 从 GD2 文件或 URL 新建一图像
imagecreatefromgd2part — 从给定的 GD2 文件或 URL 中的部分新建一图像
imagecreatefromgd — 从 GD 文件或 URL 新建一图像
imagecreatefromgif — 由文件或 URL 创建一个新图象。
imagecreatefromjpeg — 由文件或 URL 创建一个新图象。
imagecreatefrompng — 由文件或 URL 创建一个新图象。
imagecreatefromstring — 从字符串中的图像流新建一图像
imagecreatefromwbmp — 由文件或 URL 创建一个新图象。
imagecreatefromwebp — 由文件或 URL 创建一个新图象。
imagecreatefromxbm — 由文件或 URL 创建一个新图象。
imagecreatefromxpm — 由文件或 URL 创建一个新图象。
imagecreatetruecolor — 新建一个真彩色图像
imagecrop — Crop an image to the given rectangle
imagecropauto — Crop an image automatically using one of the available modes
imagedashedline — 画一虚线
imagedestroy — 销毁一图像
imageellipse — 画一个椭圆
imagefill — 区域填充
imagefilledarc — 画一椭圆弧且填充
imagefilledellipse — 画一椭圆并填充
imagefilledpolygon — 画一多边形并填充
imagefilledrectangle — 画一矩形并填充
imagefilltoborder — 区域填充到指定颜色的边界为止
imagefilter — 对图像使用过滤器
imageflip — Flips an image using a given mode
imagefontheight — 取得字体高度
imagefontwidth — 取得字体宽度
imageftbbox — 给出一个使用 FreeType 2 字体的文本框
imagefttext — 使用 FreeType 2 字体将文本写入图像
imagegammacorrect — 对 GD 图像应用 gamma 修正
imagegd2 — 将 GD2 图像输出到浏览器或文件
imagegd — 将 GD 图像输出到浏览器或文件
imagegetclip — Get the clipping rectangle
imagegif — 输出图象到浏览器或文件。
imagegrabscreen — Captures the whole screen
imagegrabwindow — Captures a window
imageinterlace — 激活或禁止隔行扫描
imageistruecolor — 检查图像是否为真彩色图像
imagejpeg — 输出图象到浏览器或文件。
imagelayereffect — 设定 alpha 混色标志以使用绑定的 libgd 分层效果
imageline — 画一条线段
imageloadfont — 载入一新字体
imageopenpolygon — Draws an open polygon
imagepalettecopy — 将调色板从一幅图像拷贝到另一幅
imagepalettetotruecolor — Converts a palette based image to true color
imagepng — 以 PNG 格式将图像输出到浏览器或文件
imagepolygon — 画一个多边形
imagepsbbox — 给出一个使用 PostScript Type1 字体的文本方框
imagepsencodefont — 改变字体中的字符编码矢量
imagepsextendfont — 扩充或精简字体
imagepsfreefont — 释放一个 PostScript Type 1 字体所占用的内存
imagepsloadfont — 从文件中加载一个 PostScript Type 1 字体
imagepsslantfont — 倾斜某字体
imagepstext — 用 PostScript Type1 字体把文本字符串画在图像上
imagerectangle — 画一个矩形
imageresolution — Get or set the resolution of the image
imagerotate — 用给定角度旋转图像
imagesavealpha — 设置标记以在保存 PNG 图像时保存完整的 alpha 通道信息（与单一透明色相反）
imagescale — Scale an image using the given new width and height
imagesetbrush — 设定画线用的画笔图像
imagesetclip — Set the clipping rectangle
imagesetinterpolation — Set the interpolation method
imagesetpixel — 画一个单一像素
imagesetstyle — 设定画线的风格
imagesetthickness — 设定画线的宽度
imagesettile — 设定用于填充的贴图
imagestring — 水平地画一行字符串
imagestringup — 垂直地画一行字符串
imagesx — 取得图像宽度
imagesy — 取得图像高度
imagetruecolortopalette — 将真彩色图像转换为调色板图像
imagettfbbox — 取得使用 TrueType 字体的文本的范围
imagettftext — 用 TrueType 字体向图像写入文本
imagetypes — 返回当前 PHP 版本所支持的图像类型
imagewbmp — 以 WBMP 格式将图像输出到浏览器或文件
imagewebp — 将 WebP 格式的图像输出到浏览器或文件
imagexbm — 将 XBM 图像输出到浏览器或文件
iptcembed — 将二进制 IPTC 数据嵌入到一幅 JPEG 图像中
iptcparse — 将二进制 IPTC 块解析为单个标记
jpeg2wbmp — 将 JPEG 图像文件转换为 WBMP 图像文件
png2wbmp — 将 PNG 图像文件转换为 WBMP 图像文件
```

### yaf
```
[Yet Another Framework](http://php.net/manual/zh/book.yaf.php)
使用框架会降低性能, 经常举例的就是Zend Framework，采用框架能提高开发效率, 损失点性能也是值得的。
有的项目组为了性能而选择某些框架，而另外一些项目组,，则为了更好的封装选择了另外的框架。
Yaf框架既不会有损性能, 又能提高开发效率。
Yaf有着和Zend Framework相似的API，相似的理念,，而同时又保持着对Bingo的兼容,，以此来提高开发效率,，规范开发习惯。本着对性能的追求, Yaf把框架中不易变的部分抽象出来，采用PHP扩展实现(c语言)，以此来保证性能。在作者自己做的简单测试中，Yaf和原生的PHP在同样功能下，性能损失小于10%，而和Zend Framework的对比中，Yaf的性能是Zend Framework的50-60倍。
Yaf是一个C语言编写的PHP框架。
Yaf的优点
用C语言开发的PHP框架，相比原生的PHP，几乎不会带来额外的性能开销。
所有的框架类，不需要编译，在PHP启动的时候加载，并常驻内存。
更短的内存周转周期，提高内存利用率，降低内存占用率。
灵巧的自动加载。支持全局和局部两种加载规则，方便类库共享。
高性能的视图引擎。
高度灵活可扩展的框架，支持自定义视图引擎，支持插件，支持自定义路由等等。
内建多种路由, 可以兼容目前常见的各种路由协议.
强大而又高度灵活的配置文件支持. 并支持缓存配置文件, 避免复杂的配置结构带来的性能损失.
在框架本身,对危险的操作习惯做了禁止.
更快的执行速度, 更少的内存占用.
名词解释
1、Yaf Yet Another Framework

| adv. | 用于否定句和疑问句，谈论尚未发生但可能发生的事; 现在; 即刻; 马上; 从现在起直至某一时间; 还; |

| conj. | 但是; 然而; |

[例句]They haven't finished yet

他们还没有完成。

2、API （Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。

3、bootstrap v.独自创立; 靠一己之力做成; 附属于; 与…相联系;

```

### curl
```
[Client URL](http://php.net/manual/zh/book.curl.php)
Client URL 库
简介
安装／配置
需求
安装
运行时配置
资源类型
预定义常量
范例
curl 基础例子
cURL 函数
curl_close — 关闭 cURL 会话
curl_copy_handle — 复制一个cURL句柄和它的所有选项
curl_errno — 返回最后一次的错误代码
curl_error — 返回当前会话最后一次错误的字符串
curl_escape — 使用 URL 编码给定的字符串
curl_exec — 执行 cURL 会话
curl_file_create — 创建一个 CURLFile 对象
curl_getinfo — 获取一个cURL连接资源句柄的信息
curl_init — 初始化 cURL 会话
curl_multi_add_handle — 向curl批处理会话中添加单独的curl句柄
curl_multi_close — 关闭一组cURL句柄
curl_multi_errno — 返回上一次 curl 批处理的错误码
curl_multi_exec — 运行当前 cURL 句柄的子连接
curl_multi_getcontent — 如果设置了CURLOPT_RETURNTRANSFER，则返回获取的输出的文本流
curl_multi_info_read — 获取当前解析的cURL的相关传输信息
curl_multi_init — 返回一个新cURL批处理句柄
curl_multi_remove_handle — 移除cURL批处理句柄资源中的某个句柄资源
curl_multi_select — 等待所有cURL批处理中的活动连接
curl_multi_setopt — 为 cURL 并行处理设置一个选项
curl_multi_strerror — 返回字符串描述的错误代码
curl_pause — 暂停和取消暂停一个连接。
curl_reset — 重置一个 libcurl 会话句柄的所有的选项
curl_setopt_array — 为 cURL 传输会话批量设置选项
curl_setopt — 设置 cURL 传输选项
curl_share_close — 关闭 cURL 共享句柄
curl_share_errno — 返回共享 curl 句柄的最后一次错误号
curl_share_init — 初始化一个 cURL 共享句柄。
curl_share_setopt — 为 cURL 共享句柄设置选项。
curl_share_strerror — 返回错误号对应的错误消息
curl_strerror — 返回错误代码的字符串描述
curl_unescape — 解码给定的 URL 编码的字符串
curl_version — 获取 cURL 版本信息
CURLFile — CURLFile 类
CURLFile::__construct — 创建 CURLFile 对象
CURLFile::getFilename — 获取被上传文件的 文件名
CURLFile::getMimeType — 获取被上传文件的 MIME 类型
CURLFile::getPostFilename — 获取 POST 请求时使用的 文件名
CURLFile::setMimeType — 设置被上传文件的 MIME 类型
CURLFile::setPostFilename — 设置 POST 请求时使用的文件名
CURLFile::__wakeup — 反序列化句柄
```

### mysqli
```
[mysql增强版](http://php.net/manual/zh/book.mysqli.php)
MySQL增强版扩展
简介
Overview
Quick start guide
Dual procedural and object-oriented interface
Connections
Executing statements
Prepared Statements
Stored Procedures
Multiple Statements
API support for transactions
Metadata
安装／配置
需求
安装
运行时配置
资源类型
mysqli 扩展和持久化连接
预定义常量
Notes
MySQLi 扩展的功能概述
MySQLi — MySQLi类
mysqli::$affected_rows — Gets the number of affected rows in a previous MySQL operation
mysqli::autocommit — 打开或关闭本次数据库连接的自动命令提交事务模式
mysqli::begin_transaction — Starts a transaction
mysqli::change_user — Changes the user of the specified database connection
mysqli::character_set_name — 返回当前数据库连接的默认字符编码
mysqli::close — 关闭先前打开的数据库连接
mysqli::commit — 提交一个事务
mysqli::$connect_errno — Returns the error code from last connect call
mysqli::$connect_error — Returns a string description of the last connect error
mysqli::__construct — Open a new connection to the MySQL server
mysqli::debug — Performs debugging operations
mysqli::dump_debug_info — 将调试信息输出到日志
mysqli::errno — 返回最近函数调用的错误代码
mysqli::$error_list — Returns a list of errors from the last command executed
mysqli::$error — Returns a string description of the last error
mysqli::$field_count — Returns the number of columns for the most recent query
mysqli::get_charset — Returns a character set object
mysqli::$client_info — 获取 MySQL 客户端信息
mysqli_get_client_version — 作为一个整数返回MySQL客户端的版本
mysqli::get_connection_stats — 返回客户端连接的统计数据
mysqli::$host_info — 返回一个表述使用的连接类型的字符串
mysqli::$protocol_version — 返回MySQL使用的协议版本号
mysqli::$server_info — 返回MySQL服务器的版本号
mysqli::$server_version — 作为一个整数返回MySQL服务器的版本
mysqli::get_warnings — Get result of SHOW WARNINGS
mysqli::$info — 返回最近执行的 SQL 语句的信息
mysqli::init — 初始化 MySQLi 并返回一个资源类型的值，这个值可以作为 mysqli_real_connect() 函数的传入参数
mysqli::$insert_id — 返回最后一条插入语句产生的自增 ID
mysqli::kill — 让服务器杀掉一个 MySQL 线程
mysqli::more_results — 检查批量查询中是否还有查询结果
mysqli::multi_query — 执行查询
mysqli::next_result — 为读取 multi_query 执行之后的下一个结果集做准备
mysqli::options — 设置选项
mysqli::ping — ping 一个连接，或者如果连接处于断开状态，重新连接
mysqli::poll — 轮询连接
mysqli::prepare — 准备执行一个 SQL 语句
mysqli::query — 对数据库执行一次查询
mysqli::real_connect — 建立一个 MySQL 服务器连接
mysqli::real_escape_string — 根据当前连接的字符集，对于 SQL 语句中的特殊字符进行转义
mysqli::real_query — 执行一个mysql查询
mysqli::reap_async_query — 获取异步查询的结果
mysqli::refresh — 刷新
mysqli::release_savepoint — 从当前事务的保存点中移除一个命名保存点
mysqli::rollback — 回退当前事务
mysqli::rpl_query_type — 返回 RPL 查询类型
mysqli::savepoint — 在当前事务中增加一个命名保存点
mysqli::select_db — 选择用于数据库查询的默认数据库
mysqli::send_query — 发送请求并返回结果
mysqli::set_charset — 设置默认字符编码
mysqli::set_local_infile_default — 取消用户指定的回调函数
mysqli::set_local_infile_handler — 设置 LOAD DATA LOCAL INFILE 命令的回调函数
mysqli::$sqlstate — 返回上一次 SQL 操作的 SQLSTATE 错误信息
mysqli::ssl_set — 使用 SSL 建立到数据库之间的安全连接
mysqli::stat — 获取当前系统状态信息
mysqli::stmt_init — 初始化一条语句并返回一个用于mysqli_stmt_prepare(调用)的对象
mysqli::store_result — 转移上一次查询返回的结果集
mysqli::$thread_id — 返回当前连接的线程 ID
mysqli::thread_safe — 返回是否是线程安全的
mysqli::use_result — Initiate a result set retrieval
mysqli::$warning_count — Returns the number of warnings from the last query for the given link
MySQLi_STMT — MySQLi_STMT类
mysqli_stmt::$affected_rows — Returns the total number of rows changed, deleted, or inserted by the last executed statement
mysqli_stmt::attr_get — Used to get the current value of a statement attribute
mysqli_stmt::attr_set — Used to modify the behavior of a prepared statement
mysqli_stmt::bind_param — Binds variables to a prepared statement as parameters
mysqli_stmt::bind_result — Binds variables to a prepared statement for result storage
mysqli_stmt::close — Closes a prepared statement
mysqli_stmt::__construct — Constructs a new mysqli_stmt object
mysqli_stmt::data_seek — Seeks to an arbitrary row in statement result set
mysqli_stmt::$errno — Returns the error code for the most recent statement call
mysqli_stmt::$error_list — Returns a list of errors from the last statement executed
mysqli_stmt::$error — Returns a string description for last statement error
mysqli_stmt::execute — Executes a prepared Query
mysqli_stmt::fetch — Fetch results from a prepared statement into the bound variables
mysqli_stmt::$field_count — Returns the number of field in the given statement
mysqli_stmt::free_result — Frees stored result memory for the given statement handle
mysqli_stmt::get_result — Gets a result set from a prepared statement
mysqli_stmt::get_warnings — Get result of SHOW WARNINGS
mysqli_stmt::$insert_id — Get the ID generated from the previous INSERT operation
mysqli_stmt::more_results — Check if there are more query results from a multiple query
mysqli_stmt::next_result — Reads the next result from a multiple query
mysqli_stmt::$num_rows — Return the number of rows in statements result set
mysqli_stmt::$param_count — Returns the number of parameter for the given statement
mysqli_stmt::prepare — Prepare an SQL statement for execution
mysqli_stmt::reset — Resets a prepared statement
mysqli_stmt::result_metadata — Returns result set metadata from a prepared statement
mysqli_stmt::send_long_data — Send data in blocks
mysqli_stmt::$sqlstate — Returns SQLSTATE error from previous statement operation
mysqli_stmt::store_result — Transfers a result set from a prepared statement
mysqli_result — mysqli_result类
mysqli_result::$current_field — Get current field offset of a result pointer
mysqli_result::data_seek — Adjusts the result pointer to an arbitrary row in the result
mysqli_result::fetch_all — Fetches all result rows as an associative array, a numeric array, or both
mysqli_result::fetch_array — Fetch a result row as an associative, a numeric array, or both
mysqli_result::fetch_assoc — Fetch a result row as an associative array
mysqli_result::fetch_field_direct — Fetch meta-data for a single field
mysqli_result::fetch_field — Returns the next field in the result set
mysqli_result::fetch_fields — Returns an array of objects representing the fields in a result set
mysqli_result::fetch_object — Returns the current row of a result set as an object
mysqli_result::fetch_row — Get a result row as an enumerated array
mysqli_result::$field_count — Get the number of fields in a result
mysqli_result::field_seek — Set result pointer to a specified field offset
mysqli_result::free — Frees the memory associated with a result
mysqli_result::$lengths — Returns the lengths of the columns of the current row in the result set
mysqli_result::$num_rows — Gets the number of rows in a result
MySQLi_Driver — MySQLi_Driver类
mysqli_driver::embedded_server_end — Stop embedded server
mysqli_driver::embedded_server_start — Initialize and start embedded server
mysqli_driver::$report_mode — Enables or disables internal report functions
MySQLi_Warning — MySQLi_Warning类
mysqli_warning::__construct — The __construct purpose
mysqli_warning::next — Fetch next warning
mysqli_sql_exception — mysqli异常类
别名和过时的 Mysqli 函数
mysqli_bind_param — mysqli_stmt_bind_param 的别名
mysqli_bind_result — mysqli_stmt_bind_result 的别名
mysqli_client_encoding — mysqli_character_set_name 的别名
mysqli_connect — 别名 mysqli::__construct
mysqli::disable_reads_from_master — 在主从服务器结构中，禁用从主机读取数据
mysqli_disable_rpl_parse — 禁用RPL解析
mysqli_enable_reads_from_master — 开启从主机读取
mysqli_enable_rpl_parse — 开启RPL解析
mysqli_escape_string — 别名 mysqli_real_escape_string
mysqli_execute — mysqli_stmt_execute 的别名
mysqli_fetch — mysqli_stmt_fetch 的别名。
mysqli_get_cache_stats — 返回客户端Zval缓存统计信息
mysqli_get_client_stats — 返回客户端进程统计信息
mysqli_get_links_stats — 返回打开和缓存的链接相关信息
mysqli_get_metadata — mysqli_stmt_result_metadata 的别名
mysqli_master_query — 在主/从机制中强制在主机中执行一个查询
mysqli_param_count — mysqli_stmt_param_count 的别名
mysqli_report — 别名 mysqli_driver->report_mode
mysqli_rpl_parse_enabled — 检查是否开启了 RPL 解析
mysqli_rpl_probe — RPL 探测
mysqli_send_long_data — mysqli_stmt_send_long_data 的别名
mysqli::set_opt — Alias of mysqli_options
mysqli_slave_query — 在主/从机制中强制在从机上执行一个查询
```

### php7
```
[php7新特性](http://www.runoob.com/w3cnote/php7-new-features.html)
PHP 7 新特性
分类 PHP 常用实例
标量类型声明
PHP 7 中的函数的形参类型声明可以是标量了。在 PHP 5 中只能是类名、接口、array 或者 callable (PHP 5.4，即可以是函数，包括匿名函数)，现在也可以使用 string、int、float和 bool 了。

<?php
// 强制模式
function sumOfInts(int ...$ints)
{
    return array_sum($ints);
}

var_dump(sumOfInts(2, '3', 4.1));
以上实例会输出：

int(9)
需要注意的是上文提到的严格模式的问题在这里同样适用：强制模式（默认，既强制类型转换）下还是会对不符合预期的参数进行强制类型转换，严格模式下则触发 TypeError 的致命错误。

返回值类型声明
PHP 7 增加了对返回类型声明的支持。 类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。

<?php

function arraysSum(array ...$arrays): array
{
    return array_map(function(array $array): int {
        return array_sum($array);
    }, $arrays);
}

print_r(arraysSum([1,2,3], [4,5,6], [7,8,9]));
以上实例会输出：

Array
(
    [0] => 6
    [1] => 15
    [2] => 24
)
NULL 合并运算符
由于日常使用中存在大量同时使用三元表达式和 isset()的情况，NULL 合并运算符使得变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。

实例如下：

<?php
// 如果 $_GET['user'] 不存在返回 'nobody'，否则返回 $_GET['user'] 的值
$username = $_GET['user'] ?? 'nobody';
// 类似的三元运算符
$username = isset($_GET['user']) ? $_GET['user'] : 'nobody';
?>
太空船操作符（组合比较符）
太空船操作符用于比较两个表达式。当$a大于、等于或小于$b时它分别返回-1、0或1。

实例如下：

<?php
// 整型
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// 浮点型
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// 字符串
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
?>
通过 define() 定义常量数组
实例如下：

<?php
define('ANIMALS', [
    'dog',
    'cat',
    'bird'
]);

echo ANIMALS[1]; // 输出 "cat"
?>
匿名类
现在支持通过new class 来实例化一个匿名类，实例如下：

<?php
interface Logger {
    public function log(string $msg);
}

class Application {
    private $logger;

    public function getLogger(): Logger {
         return $this->logger;
    }

    public function setLogger(Logger $logger) {
         $this->logger = $logger;
    }
}

$app = new Application;
$app->setLogger(new class implements Logger {
    public function log(string $msg) {
        echo $msg;
    }
});

var_dump($app->getLogger());
?>
以上实例会输出：

object(class@anonymous)#2 (0) {
}
Unicode codepoint 转译语法
这接受一个以16进制形式的 Unicode codepoint，并打印出一个双引号或heredoc包围的 UTF-8 编码格式的字符串。 可以接受任何有效的 codepoint，并且开头的 0 是可以省略的。

echo "\u{aa}";
echo "\u{0000aa}";
echo "\u{9999}";
以上实例会输出：

ª
ª (same as before but with optional leading 0's)
香
Closure::call()
Closure::call() 现在有着更好的性能，简短干练的暂时绑定一个方法到对象上闭包并调用它。

<?php
class A {private $x = 1;}

// Pre PHP 7 代码
$getXCB = function() {return $this->x;};
$getX = $getXCB->bindTo(new A, 'A'); // intermediate closure
echo $getX();

// PHP 7+ 代码
$getX = function() {return $this->x;};
echo $getX->call(new A);
以上实例会输出：

1
1
为unserialize()提供过滤
这个特性旨在提供更安全的方式解包不可靠的数据。它通过白名单的方式来防止潜在的代码注入。

<?php

// 转换对象为 __PHP_Incomplete_Class 对象
$data = unserialize($foo, ["allowed_classes" => false]);

// 转换对象为 __PHP_Incomplete_Class 对象，除了 MyClass 和 MyClass2
$data = unserialize($foo, ["allowed_classes" => ["MyClass", "MyClass2"]);

// 默认接受所有类
$data = unserialize($foo, ["allowed_classes" => true]);
IntlChar
新增加的 IntlChar 类旨在暴露出更多的 ICU 功能。这个类自身定义了许多静态方法用于操作多字符集的 unicode 字符。

<?php
printf('%x', IntlChar::CODEPOINT_MAX);
echo IntlChar::charName('@');
var_dump(IntlChar::ispunct('!'));
以上实例会输出：

10ffff
COMMERCIAL AT
bool(true)
若要使用此类，请先安装Intl扩展

预期
预期是向后兼用并增强之前的 assert() 的方法。 它使得在生产环境中启用断言为零成本，并且提供当断言失败时抛出特定异常的能力。

<?php
ini_set('assert.exception', 1);

class CustomError extends AssertionError {}

assert(false, new CustomError('Some error message'));
?>
以上实例会输出：

Fatal error: Uncaught CustomError: Some error message
use 加强
从同一 namespace 导入的类、函数和常量现在可以通过单个 use 语句 一次性导入了。

<?php

//  PHP 7 之前版本用法
use some\namespace\ClassA;
use some\namespace\ClassB;
use some\namespace\ClassC as C;

use function some\namespace\fn_a;
use function some\namespace\fn_b;
use function some\namespace\fn_c;

use const some\namespace\ConstA;
use const some\namespace\ConstB;
use const some\namespace\ConstC;

// PHP 7+ 用法
use some\namespace\{ClassA, ClassB, ClassC as C};
use function some\namespace\{fn_a, fn_b, fn_c};
use const some\namespace\{ConstA, ConstB, ConstC};
?>
Generator 加强
增强了Generator的功能，这个可以实现很多先进的特性

<?php
<?php

function gen()
{
    yield 1;
    yield 2;

    yield from gen2();
}

function gen2()
{
    yield 3;
    yield 4;
}

foreach (gen() as $val)
{
    echo $val, PHP_EOL;
}

?>
以上实例会输出：

1
2
3
4
整除
新增了整除函数 intdiv(),使用实例：

<?php
var_dump(intdiv(10, 3));
?>
以上实例会输出：

int(3)
```

### PHP 数组底层实现 （HashTable + Linked list）
```
https://zhuanlan.zhihu.com/p/97762122
https://www.jb51.net/article/168406.htm
```

### Copy on write 原理，何时 GC
```
https://www.jb51.net/article/50079.htm
https://segmentfault.com/a/1190000014024336
```

### PHP 进程模型，进程通讯方式，进程线程区别
```
http://www.gxlcms.com/PHPjiqiao-378142.html
```

### yield 核心原理是什么
```
https://www.php.cn/faq/453725.html
```

### PDO prepare 原理
```
https://www.cnblogs.com/DataArt/p/10240829.html
https://www.jb51.net/article/56612.htm
```

### PHP 7 与 PHP 5 有什么区别
```
https://www.cnblogs.com/FLy-1992/p/11647839.html
https://www.jb51.net/article/171609.htm
https://zhuanlan.zhihu.com/p/96785667
```

### Swoole 适用场景，协程实现方式
```
https://blog.csdn.net/assasin0308/article/details/93649725
https://segmentfault.com/a/1190000019089997?utm_source=tag-newest
```

## 前端篇

### 原生获取 DOM 节点，属性
```
https://www.cnblogs.com/zero18/p/10998642.html
```

### 盒子模型
```
https://www.runoob.com/css/css-boxmodel.html
```

### CSS 文件、style 标签、行内 style 属性优先级
```
http://www.liangshunet.com/ca/201705/479457580.htm
```

### HTML 与 JS 运行顺序（页面 JS 从上到下）
```
https://www.cnblogs.com/xiaoxiaoqiang001/p/5331322.html
```

### JS 数组操作
```
https://www.cnblogs.com/lzm1989/p/5967815.html
```

### 类型判断
```
https://www.cnblogs.com/wilfredo/p/10489142.html
```

### this 作用域
```
https://www.cnblogs.com/wxy1233/p/9892264.html
```

### .map() 与 this 具体使用场景分析
```
https://www.cnblogs.com/mhtss/p/11334034.html
https://blog.csdn.net/weixin_42881768/article/details/104648611
```

### Cookie 读写
```
https://www.cnblogs.com/rxbook/p/11773553.html
```

### JQuery 操作
```
https://www.cnblogs.com/gaohuayan/p/11304745.html
```

### Ajax 请求（同步、异步区别）随机数禁止缓存
```
https://www.cnblogs.com/liu-zhao/p/7055250.html
```

### Bootstrap 有什么好处
```
https://www.php.cn/bootstrap/425318.html
```

### 跨域请求 N 种解决方案
```
https://www.cnblogs.com/momo798/p/6164124.html
```

### ES6
```
https://www.runoob.com/w3cnote/es6-tutorial.html
```

### 模块化
```
https://www.jianshu.com/p/8573cdcde863
```

### 打包
```
http://www.fly63.com/article/detial/3628
```

### 构建工具
```
https://www.cnblogs.com/lihuijuan/p/9296315.html
```

### vue、react、webpack、
```
http://www.97yrbl.com/portal.php?mod=view&aid=353
```

### 前端 mvc 
```
https://www.zhihu.com/question/267581572
https://segmentfault.com/a/1190000009127861
```

### 优化
```
https://www.cnblogs.com/tianshu/p/10555921.html
```

### 如何处理负载、高并发
```
从低成本、高性能和高扩张性的角度来说有如下处理方案：
1. HTML静态化
其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，
所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。
2. 图片服务器分离
把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等
3. 数据库集群和库表散列及缓存
数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。
另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。
4. 镜像：
尽量减少下载，可以把不同的请求分发到多个镜像端。
5. 负载均衡：
Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。
当然硬件的成本比较高，我们往往从软件方面着手。
###*负载均衡**建立在现有网络结构之上，
它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，
同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。
- 知识点： [反向代理](https://www.cnblogs.com/Anker/p/6056540.html)
```

### 浏览器单域名并发数限制
```
https://www.cnblogs.com/sunsky303/p/8862128.html
```

### 静态资源缓存 304 （If-Modified-Since 以及 Etag 原理）
```
https://blog.csdn.net/lihongjun_0204/article/details/84096679
https://blog.csdn.net/weixin_43915587/article/details/95499873
```
### 多个小图标合并使用 position 定位技术 减少请求
```
https://blog.csdn.net/ldl_xz/article/details/84804133
```
### 静态资源合为单次请求 并压缩
```
https://www.cnblogs.com/LO-ME/p/7523596.html
```
### CDN
```
https://www.bejson.com/othertools/libcdn/
```
### 静态资源延迟加载技术、预加载技术
```
https://www.cnblogs.com/leyan/p/6085148.html
```
### keep-alive
```
https://www.jianshu.com/p/9523bb439950
```

### CSS 在头部，JS 在尾部的优化（原理）
```
https://www.cnblogs.com/straybirds/p/11108124.html
```

## 网络篇
### IP 地址转 INT
```
https://www.cnblogs.com/zhshlimi/p/10715911.html
https://www.cnblogs.com/shanyansheng/p/5580232.html
```
### 192.168.0.1/16 是什么意思
```
https://blog.csdn.net/aerchi/article/details/39396423?t=1476605876076
```
### DNS 主要作用是什么？
```
https://www.php.cn/faq/442356.html
```
### IPv4 与 v6 区别
```
https://www.php.cn/windows-414619.html
```

## 网络编程篇

### TCP 三次握手流程
```
https://blog.csdn.net/xuezhiwu001/article/details/78587439
```

### TCP、UDP 区别，分别适用场景
```
https://www.cnblogs.com/liangyc/p/11628208.html
```

### 有什么办法能保证 UDP 高可用性(了解)
```
https://blog.csdn.net/qq_37651267/article/details/93368908
```

### TCP 粘包如何解决？
```
https://blog.csdn.net/feng020a/article/details/60587726
```

### 为什么需要心跳？
```
https://www.cnblogs.com/coderzh/p/WhyHeartBeatNeeded.html
```

### 什么是长连接？
```
https://www.jb51.net/article/135006.htm
```

### HTTPS 是怎么保证安全的？
```
https://www.php.cn/safe/452112.html
```

### 流与数据报的区别
```
https://phpor.net/blog/post/1223
```

### 进程间通信几种方式，最快的是哪种？
```
https://blog.csdn.net/rorntuck7/article/details/84565211
```

### `fork()` 会发生什么？
```
https://zhidao.baidu.com/question/268326157628607205.html
```

## API 篇

### RESTful 是什么
```
https://www.runoob.com/php/php-restful.html
```

### 如何在不支持 `DELETE` 请求的浏览器上兼容 `DELETE` 请求
```
https://www.cnblogs.com/snandy/archive/2012/04/20/2459065.html
```

### 常见 API 的 `APP_ID` `APP_SECRET` 主要作用是什么？阐述下流程 
```
https://blog.csdn.net/qq_24656927/article/details/54910875
```

### API 请求如何保证数据不被篡改？
```
https://www.oschina.net/question/228530_2288017
```

### JSON 和 JSONP 的区别
```
https://www.cnblogs.com/bjfy/p/5461571.html
```

### 数据加密和验签的区别
```
https://www.jb51.net/article/62091.htm
```

### RSA 是什么
```
https://www.cnblogs.com/hzijone/p/6306818.html
```

### API 版本兼容怎么处理
```
https://www.cnblogs.com/vus520/p/3152772.html
```

### 限流（木桶、令牌桶）
```
https://www.jianshu.com/p/9f76dd2757c7
```

### OAuth 2 主要用在哪些场景下
```
https://blog.csdn.net/u33445687/article/details/107655728
```

### JWT
```
https://www.cnblogs.com/heyue0117/p/11917540.html
```

### PHP 中 `json_encode(['key'=>123]);` 与 `return json_encode([]);` 区别，会产生什么问题？如何解决
```
https://www.cnblogs.com/dadiaomengmei/p/11212344.html
```

## 加分项
### 了解常用语言特性，及不同场景适用性。
```
```

### PHP VS Golang
```
https://www.php.cn/be/go/421167.html
```

### PHP VS Python
```
https://blog.csdn.net/csdnnews/article/details/88373787
```

### PHP VS JAVA
```
https://www.cnblogs.com/itplay/p/10727690.html
```

### 了解 PHP 扩展开发
```
https://www.cnblogs.com/tosser/p/11564818.html
```

### 熟练掌握 C/C++
```
```
