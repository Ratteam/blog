<TOC />


### MySQL 各个存储引擎、及区别（一定会问 MyISAM 与 Innodb 区别）
```
```

### HTTP 与 HTTPS 区别
```
```

### Apache 与 Nginx 区别
```
```

### define() 与 const 区别
```
```

### traits 与 interfaces 区别 及 traits 解决了什么痛点？
```
```

### Git 与 SVN 区别
```
```

## 数据库篇
```
### MySQL

## mysql
```
 mysql优化怎么做的？

1. 设计角度：存储引擎的选择，字段类型选择，范式

2. 功能角度：可以利用mysql自身的特性，如索引，查询缓存，碎片整理，分区、分表等

3. sql语句的优化方面:尽量简化查询语句，能查询字段少就尽量少查询字段，优化分页语句、分组语句等。

4. 部署大负载架构体系：数据库服务器单独出来，负载大时可以采用主从复制，读写分离机制进行设计

5. 从硬件上升级数据库服务器。

 sql注入是什么及如何预防sql注入？

SQL注入攻击指的是用户或者黑客通过构建特殊的输入作为参数传入我们的Web应用程序端，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序员没有细致地过滤用户输入的数据，致使非法数据侵入系统而造成的。因此我们在做开发过程中一定要预防sql注入，主要从两方面着手：

1、占位符的方式，就是对sql语句进行预处理，然后执行sql语句

2、通过addslashes或者mysql_real_escape_string这两个函数对用户输入的值进行转义处理，把一些特殊的字符转义掉。

 预处理

预处理语句用于执行多个相同的 SQL 语句，并且执行效率更高。

###*预处理语句的工作原理如下**：

1. 预处理：创建 SQL 语句模板并发送到数据库。预留的值使用参数 "?" 标记 。例如：
`INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)`
数据库解析，编译，对SQL语句模板执行查询优化，并存储结果不输出。

2. 执行：最后，将应用绑定的值传递给参数（"?" 标记），数据库执行语句。应用可以多次执行语句，如果参数的值不一样。

相比于直接执行SQL语句，预处理语句有两个主要优点：

1. 预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行）。

2. 绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句。

预处理语句针对###*SQL注入**是非常有用的，因为参数值发送后使用不同的协议，保证了数据的合法性。

$stmt = $conn->prepare("INSERT INTO MyGuests (firstname, lastname, email) VALUES (?, ?, ?)");
$stmt->bind_param("sss", $firstname, $lastname, $email);

// 设置参数并执行
$firstname = "John";
$lastname = "Doe";
$email = "john@example.com";
$stmt->execute();

$stmt->close();

 mysql索引

- ###*非常重要！**

了解InnoDB和Myisam，B+tree,聚簇索引等等
[InnoDB索引原理详解](https://www.cnblogs.com/shijingxiang/articles/4743324.html)
```

## MongoDB
```
MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。

SQL术语/概念|MongoDB术语/概念|解释/说明
-|-|-
database|database|数据库
table|collection|数据库表/集合
row|document|数据记录行/文档
column|field|数据字段/域
index|index|索引
table joins| |表连接,MongoDB不支持
primary key|primary key|主键,MongoDB自动将_id字段设置为主键

<?php
// from runoob
$m = new MongoClient(); // 连接默认主机和端口为：mongodb://localhost:27017
$db = $m->test; // 获取名称为 "test" 的数据库

$collection = $db->createCollection("runoob"); // 创建集合

$collection = $db->runoob; // 选择集合
$document = array( 
    "title" => "MongoDB", 
    "description" => "database", 
    "likes" => 100,
    "url" => "http://www.runoob.com/mongodb/",
    "by", "菜鸟教程"
);

// 插入文档
$collection->insert($document);

// 查找文档
$cursor = $collection->find();

// 更新文档
$collection->update(array("title"=>"MongoDB"), array('$set'=>array("title"=>"MongoDB 教程")));

// 删除文档
$collection->remove(array("title"=>"MongoDB 教程"), array("justOne" => true));
?>
```

    ### CRUD
    ### JOIN、LEFT JOIN 、RIGHT JOIN、INNER JOIN
    ### UNION
    ### GROUP BY + COUNT + WHERE 组合案例
    ### [常用 MySQL 函数，如：now()、md5()、concat()、uuid()等](https://www.w3schools.com/sql/sql_ref_mysql.asp)
    ### `1:1`、`1:n`、`n:n` 各自适用场景
    ### 了解触发器是什么，说个使用场景
    ### 数据库优化手段
        ### 索引、联合索引（命中条件）
        ### 分库分表（`水平分表`、`垂直分表`）
        ### 分区
        ### 会使用 `explain` 分析 SQL 性能问题，了解各参数含义
            ### 重点理解 `type`、`rows`、`key`
        ### Slow Log（有什么用，什么时候需要）
### MSSQL(了解)
    ### 查询最新5条数据
### NOSQL
    ### Redis、Memcached、MongoDB
    ### 对比、适用场景（可从以下维度进行对比）
        ### 持久化
        ### 支持多钟数据类型
        ### 可利用 CPU 多核心
        ### 内存淘汰机制
        ### 集群 Cluster
        ### 支持 SQL
        ### 性能对比
        ### 支持事务
        ### 应用场景
    ### 你之前为了解决什么问题使用的什么，为什么选它？
```

## 服务器篇

### 服务器
```
心中有概念，然后足够的实际操作。
Apache
[百度百科介绍](https://baike.baidu.com/item/apache/6265)
Nginx
[百度百科介绍](https://baike.baidu.com/item/nginx/3817705)
```
```
### 查看 CPU、内存、时间、系统版本等信息
### find 、grep 查找文件
### awk 处理文本
### 查看命令所在目录
### 自己编译过 PHP 吗？如何打开 readline 功能
### 如何查看 PHP 进程的内存、CPU 占用
### 如何给 PHP 增加一个扩展
### 修改 PHP Session 存储位置、修改 INI 配置参数
### 负载均衡有哪几种，挑一种你熟悉的说明其原理
### 数据库主从复制 M-S 是怎么同步的？是推还是拉？会不会不同步？怎么办
### 如何保障数据的可用性，即使被删库了也能恢复到分钟级别。你会怎么做。
### 数据库连接过多，超过最大值，如何优化架构。从哪些方便处理？
### 502 大概什么什么原因？ 如何排查  504呢？
```

## 架构篇
```
### 偏运维（了解）：
    ### 负载均衡（Nginx、HAProxy、DNS）
    ### 主从复制（MySQL、Redis）
    ### 数据冗余、备份（MySQL增量、全量 原理）
    ### 监控检查（分存活、服务可用两个维度）
    ### MySQL、Redis、Memcached Proxy 、Cluster 目的、原理
    ### 分片
    ### 高可用集群
    ### RAID
    ### 源代码编译、内存调优
    
### php性能优化
```
php语言级的性能优化
优化点：少写代码，多用php自身能力
- 性能问题：自身代码冗余较多，可读性不佳，并且性能低。
- 为什么性能低：php代码需要编译解析为底层语言，这一过程每次请求都会处理一遍，开销大。
- 解决方案：多用php内置变量、常量、函数
- 测试方法：直接使用ab对比

优化点：php内置函数的性能优劣
- 性能问题：php内置函数，之间依然存在快慢差异
- 解决方案：多去了解php内置函数的时间复杂度
- 测试方法：对比isset()和array_key_exists()的性能差异
<?php
    $start = current_time();
    $i = 0;
    $arr = range(1, 200000);
    while($i<200000){
        ++$i;
        //isset($arr[$i]);
        array_key_exists($i,$arr);
    }
    $end = current_time();
    echo "Lost Time:". number_format($end-$start,3)###1000;
    echo "\n";
    function current_time(){
        list($usec, $sec) = explode(" ".microtime());
        return ((float)$usec + (float)$sec);
    }
?>
优化点：尽可能少用魔法函数
- 情况描述：php提供的魔法函数，性能不佳
- 为什么性能低：为了给php程序员省事，php语言为你做了很多
- 解决方案：尽可能规避使用魔法函数
- 测试方法：time php test.php
    - time  liunx命令
    - php 指定程序
    - test.php 指定文件 
    > 注意：php主要在返回值中看user耗时

优化点：产生额外开销在错误抑制符
- 情况描述：php提供的错误抑制符只是为了方便懒人
- @的实际逻辑：在代码开始前，结束后，增加Opcode,忽略报错
    vld php Opcode查看扩展:用于将Opcode显示出来
- 解决方案：尽量不要使用@错误抑制符
- 测试方法：php -dvld.active=1 -dvld.execute=0 at.php
    
- php 执行php的vld显示Opcode
    
优化点：避免在循环内做运算
- 情况描述：循环内在函数或运算会被重复执行
- 解决方案：在循环外获取需要在值，再给循环操作

优化点：减少计算密集型业务
- 情况描述：php不适合密集型的场景
- 为什么：php语言特性决定php不适合做大数据业务
- php适合场景：适合衔接webserver与sql

优化点：务必使用带引号字符串做键值
- 情况描述：php会将没有引号的键值当作常量，产生查找常量在开销。
- 解决方案：严格使用带引号作为键值

php周边问题的性能优化
- php周边有什么:
    - linux运行环境
    - 文件存储  硬盘
    - 数据库    mysql
    - 缓存      redis
    - 网络  

优化点：减少文件类操作
- 常见php场景在开销次序
读写内存 << 读写数据库 << 读写磁盘 << 读写网络数据

优化点：优化网络请求
- 网络请求的坑：
    1. 对方接口的不确定因素
    2. 网络稳定性
- 如何优化网络请求：
    - 设置超时时间
    1. 连接超时 <200ms
    2. 读超时   <800ms
    3. 写超时   <500ms
    - 将串行请求并行化
    1. 使用curl_multi_###()
    2. 使用swoole扩展

优化点：压缩php接口输出
- 如何压缩：使用Gzip即可
- 压缩的利于弊：利于我们的数据输出，Client段能更快获取数据;弊端为会有额外的CPU开销

优化点：缓存重复计算内容
- 什么情况下坐输出内容缓存：多次请求，内容不变情况

重叠时间窗口思想===并行
旁路方案===并行

php语言自身分析、优化
 php性能分析

工具:XHPorf（源自FackBook的php性能分析工具）
实践：通过分析Wordpress程序，做优化。
使用: php --ri xhprof   查看版本
在入口文件index.php添加

xhprof_enable();

// ...

$data = xhporf_disable();
include_once "/var/www/html/xhprof_lib/utils/xhprof_lib.php";
include_once "/var/www/html/xhprof_lib/utils/xhprof_runs.php";
$objXhprofRun = new XHProfRuns_Default();
$run_id = $objXhprofRun->save_run($data,"test");
var_dump($run_id);
查看xhp目录查看相关信息
参数：
    runction_name   函数名
    calls   被调用在次数
    InclWallTime    当流程走到该函数，之前和现在这个函数处理在总耗时
    ExclWallTime    这个函数执行了多少微秒

其他工具推荐：
    ab  压力测试
    vld opcode代码分析

php性能瓶颈解决方案：
    Opcode Cache:php扩展APC等
    peci.php.net    php扩展网站
    使用php扩展解决复杂的业务
    Runtime优化:HHVM

 Apache Benchmark(ab)

> ab是由Apache提供的压力测试软件。安装apache服务器时会自带该压测软件
- 使用方法: ./ab -n1000 -c100 http://www.baidu.com/
    - -n 请求数
    - -c 并发数
    - http 压测目标地址
    - -h 帮助 

###*返回参数说明**
- Requests per second（每秒接受请求数尽可能多）
- Time per request（每秒请求在耗时尽可能少）
```

### 缓存
```
    ### 工作中遇到哪里需要缓存，分别简述为什么
```
### 搜索解决方案
```
```
### 性能调优
```
```
### 各维度监控方案
```
```
### 日志收集集中处理方案
```
```
### 国际化
```
```
### 数据库设计
```
```
### [静态化如何实现的](https://blog.csdn.net/qq_39618306/article/details/79014438)
```
这里要说的静态化指的是页面静态化，也即生成实实在在的静态文件，
也即不需要查询数据库就可以直接从文件中获取数据，
指的是真静态。它的实现方式主要有两种：
一种是我们在添加信息入库的时候就生成的静态文件，也称为模板替换技术，
这种主要用在后台，用于一些基本上很少变化的信息上，
在添加信息的时候使用添加的信息来替换制定好的模板中的内容，
达到生成静态文件的目的，这样在前台访问该信息时，
可以直接从生成好的静态文件中获取信息，如一些CMS系统。
另外一种是用户在访问我们的页面时先判断是否有对应的缓存文件存在，
如果存在就读缓存，不存在就读数据库，同时生成缓存文件。
这种实现的主要原理是基于PHP中的ob缓冲技术来实现的，
当没有静态文件时，从数据库中读取，读取的数据使用OB缓存，
使用相关的函数从OB缓冲中读取数据，写入到文件中，形成静态文件。
当然这个过程中要考虑静态文件的缓存周期问题，
我们可以根据文件的最后修改时间和当前时间及设定的缓存时间来定时更新缓存文件。
```
### 静态化方案
```
```
### 画出常见 PHP 应用架构图
```
```

## 框架篇
```
### ThinkPHP（TP）、CodeIgniter（CI）、Zend（非 OOP 系列）
### Yaf、Phalcon（C 扩展系）
### Yii、Laravel、Symfony（纯 OOP 系列）
### Swoole、Workerman （网络编程框架）
### 对比框架区别几个方向点
    ### 是否纯 OOP
    ### 类库加载方式（自己写 autoload 对比 composer 标准）
    ### 易用性方向（CI 基础框架，Laravel 这种就是高开发效率框架以及基础组件多少） 
    ### 黑盒（相比 C 扩展系）
    ### 运行速度（如：Laravel 加载一大堆东西）
    ### 内存占用
```

## 设计模式
### php的设计模式
```
1. ###*单例模式**
一个类在整个应用中，只有一个对象实例的设计模式
类必须自行创建这个实例
必须自行向整个系统提供这个实例
###*三私**：私有静态成员变量、构造函数、克隆函数
###*一公**：公共的静态方法

2. ###*工厂模式**
可以根据输入的参数或者应用程序配置的不同,创建一种专门用来实例化并返回其它类的实例的类

3. 观察者模式
观察者模式提供了组件之间紧密耦合的另一种方法。
该模式：一个对象通过添加一个方法（该方法允许另一个对象，即观察者注册自己）全本身变得可观察。
当可观察的对象更改时，它会将消息发送到已注册的观察者。这些观察者使用该信息执行的操作与可观察的对象无关。

4. 命令链模式：
以松散耦合主题为基础，发送消息、命令和请求，或通过一组处理程序发送任意内容。
每个处理程序都会自行判断自己能否处理请求，如果可以，该请求被处理，进程停止。

5. 策略模式：
此算法是从复杂类提取的，因而可以方便地替换。
```

### 单例模式（重点）
```
```
### 工厂模式（重点）
```
```
### 观察者模式（重点）
```
```
### 依赖注入（重点）
```
```
### 装饰器模式
```
```
### 代理模式
```
```
### 组合模式
```
```

## 安全篇
```
### SQL 注入
### sql注入获取后台管理员账号密码
```
在完全拿下服务器主机之前，存在sql注入漏洞的网站，可能会因此提供给黑客后台管理员的账号密码，黑客登录后台后，上传木马，拿下整个主机。这是sql注入的一种应用场景。

以下讲解sql注入获取后台管理员账号密码的过程，本文以尽力对新手友好的展现过程来讲解基本原理，高手与百事通请避免观看，以免徒耗时间。

为避免读者惹上麻烦，已对原本目标网站信息进行涂抹，并提供笔者自己搭建的测试网站供有兴趣的朋友操作，换句话说，黑我的网站是合法的。

正式开始，在网站中，点击人才招聘，跳转到如下页面，同时地址栏url变为图中所示。

可以看到链接中传给服务器参数，id=2，此处逻辑一般为：服务器获取到id值为2，再通过id值返回给浏览器对应页面或内容，这个过程有可能会经过数据库。

首先惯常试试是否存在sql注入漏洞，将地址栏中的id=2更改为id=2'，即在值2后面添加单引号，回车看结果。

sweet，塔斯丁狗，服务器返回了数据库错误，并详细的打印了错误信息。由错误信息可以得知，网站使用了mysql数据库，并展示了具体的sql语句：

select ### from sy_page where 1 and id=2
这条语句表示：查询sy_page表里id为2的全部数据，而发生错误的原因则是因为多出的单引号使sql语句语法发生错误。

同时可以看出，我们只加过一个单引号'，上图错误信息却显示，实际sql语句中变为了\'反斜杠加单引号，这说明，服务器是做了特殊符号过滤的，以此来防sql注入，这确实起作用，我们便无法注入带有单引号双引号等特殊符号的语句，但其他的注入却是没问题的。

在确定存在sql注入漏洞后，对于查询语句，可以先确定查询的数据有多少列，通过如下图链接所示增加排序条件order by来探测，将地址栏中id=2改为id=2 order by 15，这将使原本的查询语句变成

select ### from sy_page where 1 and id=2 order by 15
这表示，在原来查询结果的基础上进行排序，排序的依据是第15列数据的值。

但实际结果却报错，显示不存在第15列，这正是我们追求的结果，说明查询的出数据不超过15列。

递减列数尝试，直到列数降为10時，才不再报错，如下图所示，说明数据有10列。

在得知列数后，便可以开启真正的掠夺了。那就是在原本的查询结果中加入自己的查询数据。如下图所示，将地址栏中

id=2
改为

id=2 union select 1,2,3,4,5,6,7,8,9,10

这样变化的意图是什么？举个例子，假如下图所示查询数据为网站本来正常的查询结果，id=852，从左至右刚好10列数据。

而加入union select 1,2,3,4,5,6,7,8,9,10后，查询结果便如下图所示。多出了一行结果为1 2 3 4 5 6 7 8 9 10的数据。

而网站中这行多出来的数据没有显示在页面上的原因是什么？可以想像，网站在获取到两行数据后只取了第一行的数据，因为网站根本没预料到会有两行以上的数据。那么我们只需要将自己的数据排到第一行，就可以替代网站本身的数据了。于是再做一次排序，继续追加一句order by 1，根据第一列的值进行排序，便产生如下结果

可以看到，我们自己的数据排到了最前面，这是因为我们自己构建的数据中，第一列的值为1，小于上图示例数据852，于是排到了前面。

随后拿到网站中测试，将

id=2
改为

id=2 union select 1,2,3,4,5,6,7,8,9,10 order by 1
可以看到，我们的内容替换掉了网站内容，第二列数据值2与第6列数据值6显示在了网站页面。

这两列显示数据便成了数据输出窗口。换言之，只需要将2和6的值替换为数据库实际内容，就可以输出到页面显示，被我们看见。

得知第2列和第6列会显示后，便可以开始尝试将2和6替换为系统表数据，将前面的

id=2 union select 1,2,3,4,5,6,7,8,9,10 order by 1
更改为

id=2 union select 1,table_schema,3,4,5,table_name,7,8,9,10 from information_schema.columns order by 1

这句表示，我们自己追加的数据不再是单纯的10个数字，而是从mysql的系统表columns中查询的数据，第二列与第六列分别显示columns表中的table_schema列与table_name列数据。table_schema列存储的是数据库名字信息，table_name列存储着表名信息。下图查询到的数据库名为information_schema，表名为character_sets

上面查询的columns表是mysql的系统表，里面存储着mysql中所有的表名及列信息，如下图的本机展示可以看到所有的表名，列名，列的数据类型，通过这个表，可以爆出所有的表名，列名，及所在数据库，是获取数据的突破口。

下图是一个本机测试，用的是前面爆网站表名的语句：

select ### from table1 where id=852 union select 1,table_schema,3,4,5,table_name,7,8,9,10 from information_schema.columns order by 1
可以看到，所有的表列数据被追加到我们自己的数据里，做个对比的话，下图最后一列数据就像网站正常显示的数据，其他的则是我们注入的数据。

那么如何把这么多行数据逐个爆出来呢？很明显依靠排序是不足以实现的，这时可以再在之前的查询语句后追加一个limit条件，如下图所示

limit m,n
表示筛选出从第m+1行开始的n行数据

limit 0,1
便表示筛选出第一行开始的一行数据，这样如下图就得到了第一行数据，换成limit 1,1则是筛选出第二行数据，以此类推，可以分别得出每一行的数据。

应用到网站中，发现从第41行开始不再是系统表，如下图所示，第41行爆出了数据库名sq_sydata，表名sy_admin

一行一行爆，如图展示，更改limit限定值会爆出其他的表名。

最后爆出了所有的表，如下图所示。

按照命名推断，sy_admin表必定是后台管理员账号表，既然columns系统表中存放着所有列信息，自然也可以用来将sy_admin表的列名爆出来，将

id=2 union select 1,table_schema,3,4,5,table_name,7,8,9,10 from information_schema.columns order by 1
中的table_schema（数据库名）替换为table_name（表名），table_name（表名）替换为column_name（列名），再尝试更改limit的限定值，直到更改为480時开始出现sy_admin表的内容，下图可以看到第481列（limit 480,1）爆出了sy_admin表的一个列名为id。

继续递增列爆481，得到列名loginname。

继续递增，最终爆出sy_admin表的所有列名，如下图所示。

可以推断，上图中的lpginname列应该是用户名，password则是登录密码。

ok，已经得到了sy_admin表的所有列名，接下来就可以开始获取sy_admin表中的实际数据了。

然后我们不再查询系统表，转向sy_admin表，如下图所示，将第二列替换为loginname，第六列替换为password，表名从系统表information_schema.columns（information_schema数据库中的columns表）更换为sq_sydata.sy_admin（sq_sydata数据库中的sy_admin表），再稍微更换limit限定条件，最终得到了后台管理员admin的密码，如下图所示

目标达成。

上图中加密后的密码可以通过工具或百度在线md5解密工具解密，不作赘述。

同样也可以更换列名查出其他的信息，比如下图所示登录次数27次，上次登录于2月1号。以及其他的东西，你懂的。
```
### xss攻击怎么防止
```
XSS又称CSS，全称Cross SiteScript(跨站脚本攻击)， XSS攻击类似于SQL注入攻击，
是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。
其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当用户浏览该网站时，
这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie信息、破坏页面结构
常见的恶意字符XSS输入：
1. XSS 输入通常包含 JavaScript 脚本，如弹出恶意警告框：
`<script>alert("XSS");</script>`
2. XSS 输入也可能是 HTML 代码段，譬如：
    (1) 网页不停地刷新 `<meta http-equiv="refresh" content="0;">`
    (2) 嵌入其它网站的链接，重定向到其它网站等。
方法：利用php htmlentities()函数
php防止XSS跨站脚本攻击的方法：是针对非法的HTML代码包括单双引号等，使用htmlspecialchars()函数。
```

### XSS 与 CSRF
```
```
### 输入过滤
```
```
### Cookie 安全
```
```
### 禁用 `mysql_` 系函数
```
```
### 数据库存储用户密码时，应该是怎么做才安全
```
```
### 验证码 Session 问题
```
```
### 安全的 Session ID （让即使拦截后，也无法模拟使用）
```
```
### 目录权限安全
```
```
### 包含本地与远程文件
```
```
### 文件上传 PHP 脚本
```
```
### `eval` 函数执行脚本
```
```
### `disable_functions` 关闭高危函数
```
```
### FPM 独立用户与组，给每个目录特定权限
```
```
### 了解 Hash 与 Encrypt 区别
```
```
### php在储存session以什么形式存在
```
PHP为session的存储提供了三种方式: 文件/ 内存/ 自定义存储,默认是使用文件存储.
在访问量大的网站上采用这种方式就不大合适,因为这样会导致大量的输入输出的冗余.
我们可以在php.ini更改配置文件或者php脚本中通过相应的函数来设置session文件的存储类型
来改变session文件的存储形式
```
### Session 共享、存活时间
```
https://blog.csdn.net/m_nanle_xiaobudiu/article/details/81177698
一、Session的原理
以下以默认情况举例：

session_start();之后，会生成一个唯一的session_id，每一个用户对应唯一一个session_id，每一个session_id对应服务器端的一个session文件。这个session文件存储着当前session_id的信息，比如下面，就存储了name和age的键值。

 

1、设置Session存储的引擎（本地服务器的文件还是redis等），【php.ini 文件】

[Session]
 
session.save_handler = files
 
session.save_path = /data/SessionLogs
 

2、默认情况下的Session的使用 

<?php
/**
 * session的使用
 * 默认情况（不更改session.save_handle参数时），是存储在文件file中的
 * 默认情况下使用session的情况（用户24分钟内没有刷新操作会过期）
 * 每个用户对应唯一session_id,每一个session_id对应服务器中存储的一个session文件，这个文件中存储了当前session_id的信息，比如下面，就存储了name和age的键值
 */
session_start();
echo session_id();
echo "<br>";
$_SESSION['age'] = 26;
$_SESSION['name'] = 'xiaobudiu';
var_dump($_SESSION);
 

3、在服务器中存储的形式是这样的



 

 

二、使用Redis存储Session
在网站访问量较大时，我们通常会做集群（比如nginx负载均衡等），这时，如何解决session会话的共享问题。

（1）使用ip_hash或者自定义key做负载均衡轮询策略是一个办法，但由于有时候用户可能走代理，所以这个方法其实并不是那么完美。

（2）另一个解决session共享问题的方法就是使用redis或者memcache缓存数据库去存储session，进而实现session共享问题。

 

1、设置php.ini 文件中的session.save_handle 和session.save_path

session.save_handler = Redis
 
session.save_path = "tcp://localhost:6379"
注1：如果连接的是远程redis，需要将localhost换成对应的远程ip地址。像这样，

session.save_handler = Redis
 
session.save_path =  "tcp://47.94.203.119:6379"
注2：如果为redis已经添加了auth权限（requirpass），session.save_path项则应该这样写

session.save_handler = Redis
 
session.save_path =  "tcp://47.94.203.119:6379?persistent=1&database=10&auth=myredisG506"
 

2、使用redis存储session信息

<?php
/**
 * 将session存储在redis中
 */
session_start();
echo session_id();
echo "<br>";
$_SESSION['age'] = 26;
$_SESSION['name'] = 'xiaobudiu';
$_SESSION['sex'] = 'man';
var_dump($_SESSION);
在redis上是以这样的形式进行存储的



 

注：

搭建nginx集群： https://blog.csdn.net/m_nanle_xiaobudiu/article/details/80862272

搭建mysql主从复制架构：https://blog.csdn.net/m_nanle_xiaobudiu/article/details/81086243

搭建redis集群： https://blog.csdn.net/m_nanle_xiaobudiu/article/details/81004557

 
 
三、使用Redis存储Session，并设置Session会话存活时间以及Session中某一元素存活时间
 

封装session类 b.php

<?php
 
 
/**
 * session控制类
 *
 */
 
class Session
{
 
    function __construct($lifetime = 3600)
    {
        //初始化设置session会话存活时间
        ini_set('session.gc_maxlifetime',$lifetime);
    }
 
    /**
     * 设置当前会话session的key-value
     * @param String $name   session name
     * @param Mixed  $data   session data
     * @param Int    $expire 有效时间(秒)
     */
    function set($name, $data, $expire = 600)
    {
        $session_data = array();
        $session_data['data'] = $data;
        $session_data['expire'] = time()+$expire;
        $_SESSION[$name] = $session_data;
    }
 
    /**
     * 读取当前会话session中的key-value
     * @param  String $name  session name
     * @return Mixed
     */
    function get($name)
    {
        if(isset($_SESSION[$name])) {
            if($_SESSION[$name]['expire'] > time()) {
                return $_SESSION[$name]['data'];
            }else{
                self::clear($name);
            }
        }
        return false;
    }
 
    /**
     * 清除当前session会话中的某一key-value
     * @param  String  $name  session name
     */
    function clear($name)
    {
        unset($_SESSION[$name]);
    }
 
    /**
     * 删除当前session_id对应的session文件（清空当前session会话存储）
     */
    function destroy()
    {
        session_destroy();
    }
 
}
 
session类的使用：d.php

<?php
 
require_once 'b.php';
 
session_start();
 
$session = new Session();
$session->set('wan','kkkk',1966);
 
$session->set('name','xiaobudiu');
$session->set('age',26);
$session->set('sex','man');
 
 
//输出当前会话的session存储数据
var_dump($_SESSION);
 
 
 
//unset掉某一个session属性
//$session->clear('name');
 
//删除当前session_id对应session文件
//$session->destroy();
//echo $session->get('sex');
 

redis中显示：

```

## 高阶篇

### GD库 图像处理扩展
```
[GD 和图像处理 函数](http://php.net/manual/zh/ref.image.php)
gd_info — 取得当前安装的 GD 库的信息
getimagesize — 取得图像大小
getimagesizefromstring — 从字符串中获取图像尺寸信息
image_type_to_extension — 取得图像类型的文件后缀
image_type_to_mime_type — 取得 getimagesize，exif_read_data，exif_thumbnail，exif_imagetype 所返回的图像类型的 MIME 类型
image2wbmp — 以 WBMP 格式将图像输出到浏览器或文件
imageaffine — 返回经过仿射变换后的图像，剪切区域可选
imageaffinematrixconcat — Concatenate two affine transformation matrices
imageaffinematrixget — Get an affine transformation matrix
imagealphablending — 设定图像的混色模式
imageantialias — 是否使用抗锯齿（antialias）功能
imagearc — 画椭圆弧
imagebmp — Output a BMP image to browser or file
imagechar — 水平地画一个字符
imagecharup — 垂直地画一个字符
imagecolorallocate — 为一幅图像分配颜色
imagecolorallocatealpha — 为一幅图像分配颜色 + alpha
imagecolorat — 取得某像素的颜色索引值
imagecolorclosest — 取得与指定的颜色最接近的颜色的索引值
imagecolorclosestalpha — 取得与指定的颜色加透明度最接近的颜色
imagecolorclosesthwb — 取得与给定颜色最接近的色度的黑白色的索引
imagecolordeallocate — 取消图像颜色的分配
imagecolorexact — 取得指定颜色的索引值
imagecolorexactalpha — 取得指定的颜色加透明度的索引值
imagecolormatch — 使一个图像中调色板版本的颜色与真彩色版本更能匹配
imagecolorresolve — 取得指定颜色的索引值或有可能得到的最接近的替代值
imagecolorresolvealpha — 取得指定颜色 + alpha 的索引值或有可能得到的最接近的替代值
imagecolorset — 给指定调色板索引设定颜色
imagecolorsforindex — 取得某索引的颜色
imagecolorstotal — 取得一幅图像的调色板中颜色的数目
imagecolortransparent — 将某个颜色定义为透明色
imageconvolution — 用系数 div 和 offset 申请一个 3x3 的卷积矩阵
imagecopy — 拷贝图像的一部分
imagecopymerge — 拷贝并合并图像的一部分
imagecopymergegray — 用灰度拷贝并合并图像的一部分
imagecopyresampled — 重采样拷贝部分图像并调整大小
imagecopyresized — 拷贝部分图像并调整大小
imagecreate — 新建一个基于调色板的图像
imagecreatefrombmp — 由文件或 URL 创建一个新图象。
imagecreatefromgd2 — 从 GD2 文件或 URL 新建一图像
imagecreatefromgd2part — 从给定的 GD2 文件或 URL 中的部分新建一图像
imagecreatefromgd — 从 GD 文件或 URL 新建一图像
imagecreatefromgif — 由文件或 URL 创建一个新图象。
imagecreatefromjpeg — 由文件或 URL 创建一个新图象。
imagecreatefrompng — 由文件或 URL 创建一个新图象。
imagecreatefromstring — 从字符串中的图像流新建一图像
imagecreatefromwbmp — 由文件或 URL 创建一个新图象。
imagecreatefromwebp — 由文件或 URL 创建一个新图象。
imagecreatefromxbm — 由文件或 URL 创建一个新图象。
imagecreatefromxpm — 由文件或 URL 创建一个新图象。
imagecreatetruecolor — 新建一个真彩色图像
imagecrop — Crop an image to the given rectangle
imagecropauto — Crop an image automatically using one of the available modes
imagedashedline — 画一虚线
imagedestroy — 销毁一图像
imageellipse — 画一个椭圆
imagefill — 区域填充
imagefilledarc — 画一椭圆弧且填充
imagefilledellipse — 画一椭圆并填充
imagefilledpolygon — 画一多边形并填充
imagefilledrectangle — 画一矩形并填充
imagefilltoborder — 区域填充到指定颜色的边界为止
imagefilter — 对图像使用过滤器
imageflip — Flips an image using a given mode
imagefontheight — 取得字体高度
imagefontwidth — 取得字体宽度
imageftbbox — 给出一个使用 FreeType 2 字体的文本框
imagefttext — 使用 FreeType 2 字体将文本写入图像
imagegammacorrect — 对 GD 图像应用 gamma 修正
imagegd2 — 将 GD2 图像输出到浏览器或文件
imagegd — 将 GD 图像输出到浏览器或文件
imagegetclip — Get the clipping rectangle
imagegif — 输出图象到浏览器或文件。
imagegrabscreen — Captures the whole screen
imagegrabwindow — Captures a window
imageinterlace — 激活或禁止隔行扫描
imageistruecolor — 检查图像是否为真彩色图像
imagejpeg — 输出图象到浏览器或文件。
imagelayereffect — 设定 alpha 混色标志以使用绑定的 libgd 分层效果
imageline — 画一条线段
imageloadfont — 载入一新字体
imageopenpolygon — Draws an open polygon
imagepalettecopy — 将调色板从一幅图像拷贝到另一幅
imagepalettetotruecolor — Converts a palette based image to true color
imagepng — 以 PNG 格式将图像输出到浏览器或文件
imagepolygon — 画一个多边形
imagepsbbox — 给出一个使用 PostScript Type1 字体的文本方框
imagepsencodefont — 改变字体中的字符编码矢量
imagepsextendfont — 扩充或精简字体
imagepsfreefont — 释放一个 PostScript Type 1 字体所占用的内存
imagepsloadfont — 从文件中加载一个 PostScript Type 1 字体
imagepsslantfont — 倾斜某字体
imagepstext — 用 PostScript Type1 字体把文本字符串画在图像上
imagerectangle — 画一个矩形
imageresolution — Get or set the resolution of the image
imagerotate — 用给定角度旋转图像
imagesavealpha — 设置标记以在保存 PNG 图像时保存完整的 alpha 通道信息（与单一透明色相反）
imagescale — Scale an image using the given new width and height
imagesetbrush — 设定画线用的画笔图像
imagesetclip — Set the clipping rectangle
imagesetinterpolation — Set the interpolation method
imagesetpixel — 画一个单一像素
imagesetstyle — 设定画线的风格
imagesetthickness — 设定画线的宽度
imagesettile — 设定用于填充的贴图
imagestring — 水平地画一行字符串
imagestringup — 垂直地画一行字符串
imagesx — 取得图像宽度
imagesy — 取得图像高度
imagetruecolortopalette — 将真彩色图像转换为调色板图像
imagettfbbox — 取得使用 TrueType 字体的文本的范围
imagettftext — 用 TrueType 字体向图像写入文本
imagetypes — 返回当前 PHP 版本所支持的图像类型
imagewbmp — 以 WBMP 格式将图像输出到浏览器或文件
imagewebp — 将 WebP 格式的图像输出到浏览器或文件
imagexbm — 将 XBM 图像输出到浏览器或文件
iptcembed — 将二进制 IPTC 数据嵌入到一幅 JPEG 图像中
iptcparse — 将二进制 IPTC 块解析为单个标记
jpeg2wbmp — 将 JPEG 图像文件转换为 WBMP 图像文件
png2wbmp — 将 PNG 图像文件转换为 WBMP 图像文件
```

### yaf
```
[Yet Another Framework](http://php.net/manual/zh/book.yaf.php)
使用框架会降低性能, 经常举例的就是Zend Framework，采用框架能提高开发效率, 损失点性能也是值得的。
有的项目组为了性能而选择某些框架，而另外一些项目组,，则为了更好的封装选择了另外的框架。
Yaf框架既不会有损性能, 又能提高开发效率。
Yaf有着和Zend Framework相似的API，相似的理念,，而同时又保持着对Bingo的兼容,，以此来提高开发效率,，规范开发习惯。本着对性能的追求, Yaf把框架中不易变的部分抽象出来，采用PHP扩展实现(c语言)，以此来保证性能。在作者自己做的简单测试中，Yaf和原生的PHP在同样功能下，性能损失小于10%，而和Zend Framework的对比中，Yaf的性能是Zend Framework的50-60倍。
Yaf是一个C语言编写的PHP框架。
Yaf的优点
用C语言开发的PHP框架，相比原生的PHP，几乎不会带来额外的性能开销。
所有的框架类，不需要编译，在PHP启动的时候加载，并常驻内存。
更短的内存周转周期，提高内存利用率，降低内存占用率。
灵巧的自动加载。支持全局和局部两种加载规则，方便类库共享。
高性能的视图引擎。
高度灵活可扩展的框架，支持自定义视图引擎，支持插件，支持自定义路由等等。
内建多种路由, 可以兼容目前常见的各种路由协议.
强大而又高度灵活的配置文件支持. 并支持缓存配置文件, 避免复杂的配置结构带来的性能损失.
在框架本身,对危险的操作习惯做了禁止.
更快的执行速度, 更少的内存占用.
名词解释
1、Yaf Yet Another Framework

| adv. | 用于否定句和疑问句，谈论尚未发生但可能发生的事; 现在; 即刻; 马上; 从现在起直至某一时间; 还; |

| conj. | 但是; 然而; |

[例句]They haven't finished yet

他们还没有完成。

2、API （Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。

3、bootstrap v.独自创立; 靠一己之力做成; 附属于; 与…相联系;

```

### curl
```
[Client URL](http://php.net/manual/zh/book.curl.php)
Client URL 库
简介
安装／配置
需求
安装
运行时配置
资源类型
预定义常量
范例
curl 基础例子
cURL 函数
curl_close — 关闭 cURL 会话
curl_copy_handle — 复制一个cURL句柄和它的所有选项
curl_errno — 返回最后一次的错误代码
curl_error — 返回当前会话最后一次错误的字符串
curl_escape — 使用 URL 编码给定的字符串
curl_exec — 执行 cURL 会话
curl_file_create — 创建一个 CURLFile 对象
curl_getinfo — 获取一个cURL连接资源句柄的信息
curl_init — 初始化 cURL 会话
curl_multi_add_handle — 向curl批处理会话中添加单独的curl句柄
curl_multi_close — 关闭一组cURL句柄
curl_multi_errno — 返回上一次 curl 批处理的错误码
curl_multi_exec — 运行当前 cURL 句柄的子连接
curl_multi_getcontent — 如果设置了CURLOPT_RETURNTRANSFER，则返回获取的输出的文本流
curl_multi_info_read — 获取当前解析的cURL的相关传输信息
curl_multi_init — 返回一个新cURL批处理句柄
curl_multi_remove_handle — 移除cURL批处理句柄资源中的某个句柄资源
curl_multi_select — 等待所有cURL批处理中的活动连接
curl_multi_setopt — 为 cURL 并行处理设置一个选项
curl_multi_strerror — 返回字符串描述的错误代码
curl_pause — 暂停和取消暂停一个连接。
curl_reset — 重置一个 libcurl 会话句柄的所有的选项
curl_setopt_array — 为 cURL 传输会话批量设置选项
curl_setopt — 设置 cURL 传输选项
curl_share_close — 关闭 cURL 共享句柄
curl_share_errno — 返回共享 curl 句柄的最后一次错误号
curl_share_init — 初始化一个 cURL 共享句柄。
curl_share_setopt — 为 cURL 共享句柄设置选项。
curl_share_strerror — 返回错误号对应的错误消息
curl_strerror — 返回错误代码的字符串描述
curl_unescape — 解码给定的 URL 编码的字符串
curl_version — 获取 cURL 版本信息
CURLFile — CURLFile 类
CURLFile::__construct — 创建 CURLFile 对象
CURLFile::getFilename — 获取被上传文件的 文件名
CURLFile::getMimeType — 获取被上传文件的 MIME 类型
CURLFile::getPostFilename — 获取 POST 请求时使用的 文件名
CURLFile::setMimeType — 设置被上传文件的 MIME 类型
CURLFile::setPostFilename — 设置 POST 请求时使用的文件名
CURLFile::__wakeup — 反序列化句柄
```

### mysqli
```
[mysql增强版](http://php.net/manual/zh/book.mysqli.php)
MySQL增强版扩展
简介
Overview
Quick start guide
Dual procedural and object-oriented interface
Connections
Executing statements
Prepared Statements
Stored Procedures
Multiple Statements
API support for transactions
Metadata
安装／配置
需求
安装
运行时配置
资源类型
mysqli 扩展和持久化连接
预定义常量
Notes
MySQLi 扩展的功能概述
MySQLi — MySQLi类
mysqli::$affected_rows — Gets the number of affected rows in a previous MySQL operation
mysqli::autocommit — 打开或关闭本次数据库连接的自动命令提交事务模式
mysqli::begin_transaction — Starts a transaction
mysqli::change_user — Changes the user of the specified database connection
mysqli::character_set_name — 返回当前数据库连接的默认字符编码
mysqli::close — 关闭先前打开的数据库连接
mysqli::commit — 提交一个事务
mysqli::$connect_errno — Returns the error code from last connect call
mysqli::$connect_error — Returns a string description of the last connect error
mysqli::__construct — Open a new connection to the MySQL server
mysqli::debug — Performs debugging operations
mysqli::dump_debug_info — 将调试信息输出到日志
mysqli::errno — 返回最近函数调用的错误代码
mysqli::$error_list — Returns a list of errors from the last command executed
mysqli::$error — Returns a string description of the last error
mysqli::$field_count — Returns the number of columns for the most recent query
mysqli::get_charset — Returns a character set object
mysqli::$client_info — 获取 MySQL 客户端信息
mysqli_get_client_version — 作为一个整数返回MySQL客户端的版本
mysqli::get_connection_stats — 返回客户端连接的统计数据
mysqli::$host_info — 返回一个表述使用的连接类型的字符串
mysqli::$protocol_version — 返回MySQL使用的协议版本号
mysqli::$server_info — 返回MySQL服务器的版本号
mysqli::$server_version — 作为一个整数返回MySQL服务器的版本
mysqli::get_warnings — Get result of SHOW WARNINGS
mysqli::$info — 返回最近执行的 SQL 语句的信息
mysqli::init — 初始化 MySQLi 并返回一个资源类型的值，这个值可以作为 mysqli_real_connect() 函数的传入参数
mysqli::$insert_id — 返回最后一条插入语句产生的自增 ID
mysqli::kill — 让服务器杀掉一个 MySQL 线程
mysqli::more_results — 检查批量查询中是否还有查询结果
mysqli::multi_query — 执行查询
mysqli::next_result — 为读取 multi_query 执行之后的下一个结果集做准备
mysqli::options — 设置选项
mysqli::ping — ping 一个连接，或者如果连接处于断开状态，重新连接
mysqli::poll — 轮询连接
mysqli::prepare — 准备执行一个 SQL 语句
mysqli::query — 对数据库执行一次查询
mysqli::real_connect — 建立一个 MySQL 服务器连接
mysqli::real_escape_string — 根据当前连接的字符集，对于 SQL 语句中的特殊字符进行转义
mysqli::real_query — 执行一个mysql查询
mysqli::reap_async_query — 获取异步查询的结果
mysqli::refresh — 刷新
mysqli::release_savepoint — 从当前事务的保存点中移除一个命名保存点
mysqli::rollback — 回退当前事务
mysqli::rpl_query_type — 返回 RPL 查询类型
mysqli::savepoint — 在当前事务中增加一个命名保存点
mysqli::select_db — 选择用于数据库查询的默认数据库
mysqli::send_query — 发送请求并返回结果
mysqli::set_charset — 设置默认字符编码
mysqli::set_local_infile_default — 取消用户指定的回调函数
mysqli::set_local_infile_handler — 设置 LOAD DATA LOCAL INFILE 命令的回调函数
mysqli::$sqlstate — 返回上一次 SQL 操作的 SQLSTATE 错误信息
mysqli::ssl_set — 使用 SSL 建立到数据库之间的安全连接
mysqli::stat — 获取当前系统状态信息
mysqli::stmt_init — 初始化一条语句并返回一个用于mysqli_stmt_prepare(调用)的对象
mysqli::store_result — 转移上一次查询返回的结果集
mysqli::$thread_id — 返回当前连接的线程 ID
mysqli::thread_safe — 返回是否是线程安全的
mysqli::use_result — Initiate a result set retrieval
mysqli::$warning_count — Returns the number of warnings from the last query for the given link
MySQLi_STMT — MySQLi_STMT类
mysqli_stmt::$affected_rows — Returns the total number of rows changed, deleted, or inserted by the last executed statement
mysqli_stmt::attr_get — Used to get the current value of a statement attribute
mysqli_stmt::attr_set — Used to modify the behavior of a prepared statement
mysqli_stmt::bind_param — Binds variables to a prepared statement as parameters
mysqli_stmt::bind_result — Binds variables to a prepared statement for result storage
mysqli_stmt::close — Closes a prepared statement
mysqli_stmt::__construct — Constructs a new mysqli_stmt object
mysqli_stmt::data_seek — Seeks to an arbitrary row in statement result set
mysqli_stmt::$errno — Returns the error code for the most recent statement call
mysqli_stmt::$error_list — Returns a list of errors from the last statement executed
mysqli_stmt::$error — Returns a string description for last statement error
mysqli_stmt::execute — Executes a prepared Query
mysqli_stmt::fetch — Fetch results from a prepared statement into the bound variables
mysqli_stmt::$field_count — Returns the number of field in the given statement
mysqli_stmt::free_result — Frees stored result memory for the given statement handle
mysqli_stmt::get_result — Gets a result set from a prepared statement
mysqli_stmt::get_warnings — Get result of SHOW WARNINGS
mysqli_stmt::$insert_id — Get the ID generated from the previous INSERT operation
mysqli_stmt::more_results — Check if there are more query results from a multiple query
mysqli_stmt::next_result — Reads the next result from a multiple query
mysqli_stmt::$num_rows — Return the number of rows in statements result set
mysqli_stmt::$param_count — Returns the number of parameter for the given statement
mysqli_stmt::prepare — Prepare an SQL statement for execution
mysqli_stmt::reset — Resets a prepared statement
mysqli_stmt::result_metadata — Returns result set metadata from a prepared statement
mysqli_stmt::send_long_data — Send data in blocks
mysqli_stmt::$sqlstate — Returns SQLSTATE error from previous statement operation
mysqli_stmt::store_result — Transfers a result set from a prepared statement
mysqli_result — mysqli_result类
mysqli_result::$current_field — Get current field offset of a result pointer
mysqli_result::data_seek — Adjusts the result pointer to an arbitrary row in the result
mysqli_result::fetch_all — Fetches all result rows as an associative array, a numeric array, or both
mysqli_result::fetch_array — Fetch a result row as an associative, a numeric array, or both
mysqli_result::fetch_assoc — Fetch a result row as an associative array
mysqli_result::fetch_field_direct — Fetch meta-data for a single field
mysqli_result::fetch_field — Returns the next field in the result set
mysqli_result::fetch_fields — Returns an array of objects representing the fields in a result set
mysqli_result::fetch_object — Returns the current row of a result set as an object
mysqli_result::fetch_row — Get a result row as an enumerated array
mysqli_result::$field_count — Get the number of fields in a result
mysqli_result::field_seek — Set result pointer to a specified field offset
mysqli_result::free — Frees the memory associated with a result
mysqli_result::$lengths — Returns the lengths of the columns of the current row in the result set
mysqli_result::$num_rows — Gets the number of rows in a result
MySQLi_Driver — MySQLi_Driver类
mysqli_driver::embedded_server_end — Stop embedded server
mysqli_driver::embedded_server_start — Initialize and start embedded server
mysqli_driver::$report_mode — Enables or disables internal report functions
MySQLi_Warning — MySQLi_Warning类
mysqli_warning::__construct — The __construct purpose
mysqli_warning::next — Fetch next warning
mysqli_sql_exception — mysqli异常类
别名和过时的 Mysqli 函数
mysqli_bind_param — mysqli_stmt_bind_param 的别名
mysqli_bind_result — mysqli_stmt_bind_result 的别名
mysqli_client_encoding — mysqli_character_set_name 的别名
mysqli_connect — 别名 mysqli::__construct
mysqli::disable_reads_from_master — 在主从服务器结构中，禁用从主机读取数据
mysqli_disable_rpl_parse — 禁用RPL解析
mysqli_enable_reads_from_master — 开启从主机读取
mysqli_enable_rpl_parse — 开启RPL解析
mysqli_escape_string — 别名 mysqli_real_escape_string
mysqli_execute — mysqli_stmt_execute 的别名
mysqli_fetch — mysqli_stmt_fetch 的别名。
mysqli_get_cache_stats — 返回客户端Zval缓存统计信息
mysqli_get_client_stats — 返回客户端进程统计信息
mysqli_get_links_stats — 返回打开和缓存的链接相关信息
mysqli_get_metadata — mysqli_stmt_result_metadata 的别名
mysqli_master_query — 在主/从机制中强制在主机中执行一个查询
mysqli_param_count — mysqli_stmt_param_count 的别名
mysqli_report — 别名 mysqli_driver->report_mode
mysqli_rpl_parse_enabled — 检查是否开启了 RPL 解析
mysqli_rpl_probe — RPL 探测
mysqli_send_long_data — mysqli_stmt_send_long_data 的别名
mysqli::set_opt — Alias of mysqli_options
mysqli_slave_query — 在主/从机制中强制在从机上执行一个查询
```

### php7
```
[php7新特性](http://www.runoob.com/w3cnote/php7-new-features.html)
PHP 7 新特性
分类 PHP 常用实例
标量类型声明
PHP 7 中的函数的形参类型声明可以是标量了。在 PHP 5 中只能是类名、接口、array 或者 callable (PHP 5.4，即可以是函数，包括匿名函数)，现在也可以使用 string、int、float和 bool 了。

<?php
// 强制模式
function sumOfInts(int ...$ints)
{
    return array_sum($ints);
}

var_dump(sumOfInts(2, '3', 4.1));
以上实例会输出：

int(9)
需要注意的是上文提到的严格模式的问题在这里同样适用：强制模式（默认，既强制类型转换）下还是会对不符合预期的参数进行强制类型转换，严格模式下则触发 TypeError 的致命错误。

返回值类型声明
PHP 7 增加了对返回类型声明的支持。 类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。

<?php

function arraysSum(array ...$arrays): array
{
    return array_map(function(array $array): int {
        return array_sum($array);
    }, $arrays);
}

print_r(arraysSum([1,2,3], [4,5,6], [7,8,9]));
以上实例会输出：

Array
(
    [0] => 6
    [1] => 15
    [2] => 24
)
NULL 合并运算符
由于日常使用中存在大量同时使用三元表达式和 isset()的情况，NULL 合并运算符使得变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。

实例如下：

<?php
// 如果 $_GET['user'] 不存在返回 'nobody'，否则返回 $_GET['user'] 的值
$username = $_GET['user'] ?? 'nobody';
// 类似的三元运算符
$username = isset($_GET['user']) ? $_GET['user'] : 'nobody';
?>
太空船操作符（组合比较符）
太空船操作符用于比较两个表达式。当$a大于、等于或小于$b时它分别返回-1、0或1。

实例如下：

<?php
// 整型
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// 浮点型
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// 字符串
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
?>
通过 define() 定义常量数组
实例如下：

<?php
define('ANIMALS', [
    'dog',
    'cat',
    'bird'
]);

echo ANIMALS[1]; // 输出 "cat"
?>
匿名类
现在支持通过new class 来实例化一个匿名类，实例如下：

<?php
interface Logger {
    public function log(string $msg);
}

class Application {
    private $logger;

    public function getLogger(): Logger {
         return $this->logger;
    }

    public function setLogger(Logger $logger) {
         $this->logger = $logger;
    }
}

$app = new Application;
$app->setLogger(new class implements Logger {
    public function log(string $msg) {
        echo $msg;
    }
});

var_dump($app->getLogger());
?>
以上实例会输出：

object(class@anonymous)#2 (0) {
}
Unicode codepoint 转译语法
这接受一个以16进制形式的 Unicode codepoint，并打印出一个双引号或heredoc包围的 UTF-8 编码格式的字符串。 可以接受任何有效的 codepoint，并且开头的 0 是可以省略的。

echo "\u{aa}";
echo "\u{0000aa}";
echo "\u{9999}";
以上实例会输出：

ª
ª (same as before but with optional leading 0's)
香
Closure::call()
Closure::call() 现在有着更好的性能，简短干练的暂时绑定一个方法到对象上闭包并调用它。

<?php
class A {private $x = 1;}

// Pre PHP 7 代码
$getXCB = function() {return $this->x;};
$getX = $getXCB->bindTo(new A, 'A'); // intermediate closure
echo $getX();

// PHP 7+ 代码
$getX = function() {return $this->x;};
echo $getX->call(new A);
以上实例会输出：

1
1
为unserialize()提供过滤
这个特性旨在提供更安全的方式解包不可靠的数据。它通过白名单的方式来防止潜在的代码注入。

<?php

// 转换对象为 __PHP_Incomplete_Class 对象
$data = unserialize($foo, ["allowed_classes" => false]);

// 转换对象为 __PHP_Incomplete_Class 对象，除了 MyClass 和 MyClass2
$data = unserialize($foo, ["allowed_classes" => ["MyClass", "MyClass2"]);

// 默认接受所有类
$data = unserialize($foo, ["allowed_classes" => true]);
IntlChar
新增加的 IntlChar 类旨在暴露出更多的 ICU 功能。这个类自身定义了许多静态方法用于操作多字符集的 unicode 字符。

<?php
printf('%x', IntlChar::CODEPOINT_MAX);
echo IntlChar::charName('@');
var_dump(IntlChar::ispunct('!'));
以上实例会输出：

10ffff
COMMERCIAL AT
bool(true)
若要使用此类，请先安装Intl扩展

预期
预期是向后兼用并增强之前的 assert() 的方法。 它使得在生产环境中启用断言为零成本，并且提供当断言失败时抛出特定异常的能力。

<?php
ini_set('assert.exception', 1);

class CustomError extends AssertionError {}

assert(false, new CustomError('Some error message'));
?>
以上实例会输出：

Fatal error: Uncaught CustomError: Some error message
use 加强
从同一 namespace 导入的类、函数和常量现在可以通过单个 use 语句 一次性导入了。

<?php

//  PHP 7 之前版本用法
use some\namespace\ClassA;
use some\namespace\ClassB;
use some\namespace\ClassC as C;

use function some\namespace\fn_a;
use function some\namespace\fn_b;
use function some\namespace\fn_c;

use const some\namespace\ConstA;
use const some\namespace\ConstB;
use const some\namespace\ConstC;

// PHP 7+ 用法
use some\namespace\{ClassA, ClassB, ClassC as C};
use function some\namespace\{fn_a, fn_b, fn_c};
use const some\namespace\{ConstA, ConstB, ConstC};
?>
Generator 加强
增强了Generator的功能，这个可以实现很多先进的特性

<?php
<?php

function gen()
{
    yield 1;
    yield 2;

    yield from gen2();
}

function gen2()
{
    yield 3;
    yield 4;
}

foreach (gen() as $val)
{
    echo $val, PHP_EOL;
}

?>
以上实例会输出：

1
2
3
4
整除
新增了整除函数 intdiv(),使用实例：

<?php
var_dump(intdiv(10, 3));
?>
以上实例会输出：

int(3)
```

### PHP 数组底层实现 （HashTable + Linked list）
```
https://zhuanlan.zhihu.com/p/97762122
https://www.jb51.net/article/168406.htm
```

### Copy on write 原理，何时 GC
```
https://www.jb51.net/article/50079.htm
https://segmentfault.com/a/1190000014024336
```

### PHP 进程模型，进程通讯方式，进程线程区别
```
http://www.gxlcms.com/PHPjiqiao-378142.html
```

### yield 核心原理是什么
```
https://www.php.cn/faq/453725.html
```

### PDO prepare 原理
```
https://www.cnblogs.com/DataArt/p/10240829.html
https://www.jb51.net/article/56612.htm
```

### PHP 7 与 PHP 5 有什么区别
```
https://www.cnblogs.com/FLy-1992/p/11647839.html
https://www.jb51.net/article/171609.htm
https://zhuanlan.zhihu.com/p/96785667
```

### Swoole 适用场景，协程实现方式
```
https://blog.csdn.net/assasin0308/article/details/93649725
https://segmentfault.com/a/1190000019089997?utm_source=tag-newest
```

## 前端篇

### 原生获取 DOM 节点，属性
```
https://www.cnblogs.com/zero18/p/10998642.html
```

### 盒子模型
```
https://www.runoob.com/css/css-boxmodel.html
```

### CSS 文件、style 标签、行内 style 属性优先级
```
http://www.liangshunet.com/ca/201705/479457580.htm
```

### HTML 与 JS 运行顺序（页面 JS 从上到下）
```
https://www.cnblogs.com/xiaoxiaoqiang001/p/5331322.html
```

### JS 数组操作
```
https://www.cnblogs.com/lzm1989/p/5967815.html
```

### 类型判断
```
https://www.cnblogs.com/wilfredo/p/10489142.html
```

### this 作用域
```
https://www.cnblogs.com/wxy1233/p/9892264.html
```

### .map() 与 this 具体使用场景分析
```
https://www.cnblogs.com/mhtss/p/11334034.html
https://blog.csdn.net/weixin_42881768/article/details/104648611
```

### Cookie 读写
```
https://www.cnblogs.com/rxbook/p/11773553.html
```

### JQuery 操作
```
https://www.cnblogs.com/gaohuayan/p/11304745.html
```

### Ajax 请求（同步、异步区别）随机数禁止缓存
```
https://www.cnblogs.com/liu-zhao/p/7055250.html
```

### Bootstrap 有什么好处
```
https://www.php.cn/bootstrap/425318.html
```

### 跨域请求 N 种解决方案
```
https://www.cnblogs.com/momo798/p/6164124.html
```

### ES6
```
https://www.runoob.com/w3cnote/es6-tutorial.html
```

### 模块化
```
https://www.jianshu.com/p/8573cdcde863
```

### 打包
```
http://www.fly63.com/article/detial/3628
```

### 构建工具
```
https://www.cnblogs.com/lihuijuan/p/9296315.html
```

### vue、react、webpack、
```
http://www.97yrbl.com/portal.php?mod=view&aid=353
```

### 前端 mvc 
```
https://www.zhihu.com/question/267581572
https://segmentfault.com/a/1190000009127861
```

### 优化
```
https://www.cnblogs.com/tianshu/p/10555921.html
```

### 如何处理负载、高并发
```
从低成本、高性能和高扩张性的角度来说有如下处理方案：
1. HTML静态化
其实大家都知道，效率最高、消耗最小的就是纯静态化的html页面，
所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。
2. 图片服务器分离
把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如骑牛等
3. 数据库集群和库表散列及缓存
数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。
另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。
4. 镜像：
尽量减少下载，可以把不同的请求分发到多个镜像端。
5. 负载均衡：
Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。
当然硬件的成本比较高，我们往往从软件方面着手。
###*负载均衡**建立在现有网络结构之上，
它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力，
同时能够提高网络的灵活性和可用性。目前使用最为广泛的负载均衡软件是Nginx、LVS、HAProxy。
- 知识点： [反向代理](https://www.cnblogs.com/Anker/p/6056540.html)
```

### 浏览器单域名并发数限制
```
https://www.cnblogs.com/sunsky303/p/8862128.html
```

### 静态资源缓存 304 （If-Modified-Since 以及 Etag 原理）
```
https://blog.csdn.net/lihongjun_0204/article/details/84096679
https://blog.csdn.net/weixin_43915587/article/details/95499873
```
### 多个小图标合并使用 position 定位技术 减少请求
```
https://blog.csdn.net/ldl_xz/article/details/84804133
```
### 静态资源合为单次请求 并压缩
```
https://www.cnblogs.com/LO-ME/p/7523596.html
```
### CDN
```
https://www.bejson.com/othertools/libcdn/
```
### 静态资源延迟加载技术、预加载技术
```
https://www.cnblogs.com/leyan/p/6085148.html
```
### keep-alive
```
https://www.jianshu.com/p/9523bb439950
```

### CSS 在头部，JS 在尾部的优化（原理）
```
https://www.cnblogs.com/straybirds/p/11108124.html
```

## 网络篇
### IP 地址转 INT
```
https://www.cnblogs.com/zhshlimi/p/10715911.html
https://www.cnblogs.com/shanyansheng/p/5580232.html
```
### 192.168.0.1/16 是什么意思
```
https://blog.csdn.net/aerchi/article/details/39396423?t=1476605876076
```
### DNS 主要作用是什么？
```
https://www.php.cn/faq/442356.html
```
### IPv4 与 v6 区别
```
https://www.php.cn/windows-414619.html
```

## 网络编程篇

### TCP 三次握手流程
```
https://blog.csdn.net/xuezhiwu001/article/details/78587439
```

### TCP、UDP 区别，分别适用场景
```
https://www.cnblogs.com/liangyc/p/11628208.html
```

### 有什么办法能保证 UDP 高可用性(了解)
```
https://blog.csdn.net/qq_37651267/article/details/93368908
```

### TCP 粘包如何解决？
```
https://blog.csdn.net/feng020a/article/details/60587726
```

### 为什么需要心跳？
```
https://www.cnblogs.com/coderzh/p/WhyHeartBeatNeeded.html
```

### 什么是长连接？
```
https://www.jb51.net/article/135006.htm
```

### HTTPS 是怎么保证安全的？
```
https://www.php.cn/safe/452112.html
```

### 流与数据报的区别
```
https://phpor.net/blog/post/1223
```

### 进程间通信几种方式，最快的是哪种？
```
https://blog.csdn.net/rorntuck7/article/details/84565211
```

### `fork()` 会发生什么？
```
https://zhidao.baidu.com/question/268326157628607205.html
```

## API 篇

### RESTful 是什么
```
https://www.runoob.com/php/php-restful.html
```

### 如何在不支持 `DELETE` 请求的浏览器上兼容 `DELETE` 请求
```
https://www.cnblogs.com/snandy/archive/2012/04/20/2459065.html
```

### 常见 API 的 `APP_ID` `APP_SECRET` 主要作用是什么？阐述下流程 
```
https://blog.csdn.net/qq_24656927/article/details/54910875
```

### API 请求如何保证数据不被篡改？
```
https://www.oschina.net/question/228530_2288017
```

### JSON 和 JSONP 的区别
```
https://www.cnblogs.com/bjfy/p/5461571.html
```

### 数据加密和验签的区别
```
https://www.jb51.net/article/62091.htm
```

### RSA 是什么
```
https://www.cnblogs.com/hzijone/p/6306818.html
```

### API 版本兼容怎么处理
```
https://www.cnblogs.com/vus520/p/3152772.html
```

### 限流（木桶、令牌桶）
```
https://www.jianshu.com/p/9f76dd2757c7
```

### OAuth 2 主要用在哪些场景下
```
https://blog.csdn.net/u33445687/article/details/107655728
```

### JWT
```
https://www.cnblogs.com/heyue0117/p/11917540.html
```

### PHP 中 `json_encode(['key'=>123]);` 与 `return json_encode([]);` 区别，会产生什么问题？如何解决
```
https://www.cnblogs.com/dadiaomengmei/p/11212344.html
```

## 加分项
### 了解常用语言特性，及不同场景适用性。
```
```

### PHP VS Golang
```
https://www.php.cn/be/go/421167.html
```

### PHP VS Python
```
https://blog.csdn.net/csdnnews/article/details/88373787
```

### PHP VS JAVA
```
https://www.cnblogs.com/itplay/p/10727690.html
```

### 了解 PHP 扩展开发
```
https://www.cnblogs.com/tosser/p/11564818.html
```

### 熟练掌握 C/C++
```
```

## Laravel5.8版本安装教程
```
1.安装

方式1：全局安装

通过composer安装 laravel 安装器

composer global require "laravel/installer"

确保将 composer vender bin 目录放置在你的系统环境变量 $PATH 中，以便系统可以找到 Laravel 的可执行文件。该目录根据您的操作系统存在不同的位置中；一些常见的配置包括：

macOS: $HOME/.composer/vendor/bin

GNU / Linux 发行版: $HOME/.config/composer/vendor/bin

安装完后可通过 laravel new 项目名安装laravel

方式二：命令行安装

composer create-project --prefer -dist laravel/laravel 项目名
2.配置公共目录

安装完laravel后必须将web服务器根目录指向public文件夹。如果是本地环境可忽略此操作。
3.配置读写权限

storage和bootstrap/cache 两个文件夹需要写入权限。如果未配置laravel程序将无法运行。如果是本地环境可忽略此操作。
4.创建.env文件

laravel安装完成，如果只有.env.example文件，需要创建.evn文件并将.env.example中的内容复制到.env中。
5.生成应用秘钥

laravel安装完成后，需要在命令行下运行php artisan key:generate，该命令会生成一个32位的随机数，并写入.env文件中
6.修改config/app.php下的timezone

app.php中的timezone默认是UTC,UTC是世界统一时间，需要将时区改成中国时区Asia/Shanghai
7.配置数据库

创建数据库并将数据库配

置信息写入.env文件

DB_CONNECTION=mysql

DB_HOST=127.0.0.1

DB_PORT=3306

DB_DATABASE=homestead

DB_USERNAME=root

DB_PASSWORD=root


参考：https://www.jianshu.com/p/a3cdec31be9b
```

```

### 面试题
```
1. 计算机网络体系结构

- 应用层：应用层协议定义的是应用进程间通信和交互的规则
- 运输层：运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务
- 网络层：把运输层产生的报文段或用户数据报封装成分组或包进行传送
- 数据链路层：将网络层交下来的 IP 数据报组装成帧，并在两个相邻结点间的链路上传送
- 物理层：利用物理媒体以比特形式传送数据

2. UDP 的主要特点

- UDP 是无连接的，即发送数据之前不需要建立连接(发送数据结束时也没有连接可释放)，减少了开销和发送数据之前的时延
- UDP 使用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表
- UDP 是面向报文的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界
- UDP 没有拥塞控制，网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的
- UDP 支持一对一、一对多、多对一和多对多的交互通信
- UDP 的首部开销小，只有8个字节，比 TCP 的20个字节的首部要短

3. TCP 的主要特点

- TCP 是面向连接的运输层协议。应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接
- 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的(一对一)
- TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达
- TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据
- 面向字节流。TCP 中的“流”指的是流入到进程或从进程流出的字节序列

4. 简述三报文握手建立 TCP 连接

- 服务器进程先创建传输控制块 TCB，并处于监听状态，等待客户端的连接请求
- 客户端创建传输控制块 TCB，并向服务器发出连接请求报文段
- 服务器收到连接请求报文段后，如同意建立连接，则发送确认报文段
- 客户端进程收到服务器的确认报文段后，立即回复确认报文段，并进入已建立连接状态
- 服务器收到确认报文段之后，也进入已建立连接状态

> 传输控制块 TCB(Transmission Control Block)存储了每一个连接中的一些重要信息

 5. 建立 TCP 连接为什么最后还要发送确认

这主要是为了防止已失效的连接请求报文段突然又传到了 TCP 服务器，避免产生错误

 6. 简述 TCP 连接的释放

- 客户端应用进程发出连接释放报文段，并停止再发送数据，进入 FIN-WAIT-1(终止等待1)状态，等待服务器确认
- 服务器收到连接释放报文段后即发出确认，进入 CLOSE-WAIT(关闭等待)状态，服务器若发送数据，客户端扔要接收
- 客户端收到来自服务器的确认后，进入 FIN-WAIT-2(终止等待2)状态，等待服务器发出连接释放报文段
- 服务器没有要发送的数据，发出连接释放报文段，进入 LAST-ACK(最后确认)状态，等待客户端确认
- 客户端收到连接释放报文段后，发出确认，进入 TIME-WAIT(时间等待)状态，经过时间等待计时器设置的时间 2MSL 后，进入 CLOSED(关闭) 状态
- 服务器收到客户端报文段后，进入 CLOSED 状态

 7. TIME-WAIT 是什么，为什么必须等待 2MLS

TIME-WAIT 是一种 TCP 状态。等待 2MLS 可以保证客户端最后一个报文段能够到达服务器，如果未到达，服务器则会超时重传连接释放报文段，使得客户端、服务器都可以正常进入到 CLOSE(关闭) 状态

> MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

 8. TCP 粘包问题

在 TCP 这种字节流协议上做应用层分包是网络编程的基本需求。分包指的是在发生一个消息(message)或一帧(frame)数据时，通过一定的处理，让接收方能从字节流中识别并截取(还原)出一个个消息。因此，“粘包问题”是个伪命题

长连接分包: 
- 消息长度固定
- 使用特殊的字符或字符串作为消息的边界，例如 HTTP 协议的 headers 以“\r\n”为字段的分隔符
- 在每条消息的头部加一个长度字段，这恐怕是最常见的做法
- 利用消息本身的格式来分包，例如 XML 格式的消息中 `<root>`...`</root>` 的配对，或者 JSON 格式中的 { ... } 的配对。解析这种消息格式通常会用到状态机(state machine)

 9. UDP、TCP 区别，适用场景

|对比项|UDP|TCP|
|-|-|-|
|连接性|无连接|面向连接|
|可靠性|不可靠|可靠|
|报文|面向报文-数据报模式|面向字节流-流模式|
|双工性|一对一、一对多、多对一、多对多|全双工|
|流量控制|无|有(滑动窗口)|
|拥塞控制|无|有(慢开始、拥塞避免、快重传、快恢复)|
|传输速度|快|慢|
|资源要求|较少|较多|
|首部开销|8字节|20字节|
|数据顺序|不保证|保证|

UDP 适用场景

面向数据报方式、网络数据大多为短消息、拥有大量 Client、对数据安全性无特殊要求、网络负担非常重，但对响应速度要求高

 TCP 适用场景

文件传输(FTP HTTP 对数据准确性要求较高，速度可以相对慢)
发送或接收邮件(POP IMAP SMTP 对数据准确性要求高，非紧急应用)
远程登录(telnet SSH 对数据准确性有要求，有连接的概念)

 10. 建立 socket 需要哪些步骤

- 创建 socket
- 绑定 socket 到指定地址和端口
- 开始监听连接
- 读取客户端输入
- 关闭 socket

 11. DNS 主要作用是什么

计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问

但要让计算机去理解名称，相对而言就变得困难，因为计算机更擅长处理一长串数字

为了解决上述问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务

 12. HTTP 报文组成

HTTP 报文是由简单字符串组成，HTTP 报文都是纯文本，不是二进制代码，可以很方便地对其进行读写

从客户端发往服务器的 HTTP 报文称为请求报文(request message)。从服务器发往客户端的报文称为响应报文(response message)。HTTP 请求和响应报文的格式很类似

HTTP 报文组成部分

- 起始行：报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况
- 首部字段：起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值
- 主体：空行之后就是可选的报文主体了，其中包含了所有类型的数据

 13. HTTP 状态码

> HTTP 状态码用来告诉客户端，发生了什么事情，状态码位于响应的起始行中

 状态码分类

|状态码|整体范围|已定义范围|分类|
|-|-|-|-|
|1XX|100~199|100~101|信息提示|
|2XX|200~299|200~206|成功|
|3XX|300~399|300~305|重定向|
|4XX|400~499|400~415|客户端错误|
|5XX|500~599|500~505|服务器错误|

 常见状态码

|状态码|原因短语|含义|考察概率|
|-|-|-|-|
|200|OK|请求没有问题|###**|
|206|Partial Content|部分或 Range(范围) 请求|###|
|301|Moved Permanently|在请求的链接被移除时使用|###*|
|302|Found|在请求临时的链接使用|###*|
|304|Not Modified|资源未被修改可使用旧资源|###*|
|307|Temporary Redirect|在请求临时的链接使用|###*|
|400|Bad Request|告知客户端发送了错误请求|###**|
|403|Forbidden|请求被服务器拒绝|###**|
|404|Not Found|无法找到所请求的 URL|###**|
|413|Request entiry too large|请求实体过大|###|
|500|Internal Server Error|服务器遇到错误|###**|
|502|Bad Gateway|代理或网关错误(无法连接到其父网关)|###**|
|503|Service Unavailable|无法为请求提供服务|###**|
|504|Gateway Timeout|代理或网关超时(等待另一服务器响应超时)|###**|

 14. 常见的 HTTP 方法

HTTP 请求方法用于告诉服务器要做什么。HTTP 规范中定义了一组常用的请求方法。

 GET 方法

GET 是最常用的方法。通常用于请求服务器发送某个资源。HTTP/1.1 要求服务器实现此方法

 POST 方法

POST 方法起初是用来向服务器输入数据的。实际上，通常会用它来支持 HTML 的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方（比如，送到一个服务器网关程序中，然后由这个程序对其进行处理）

 DELETE

DELETE 方法所做的事情就是请服务器删除请求 URL 所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求

 16. HTTP 优缺点

基于应用级的接口，使用方便

传输速度慢，数据包大；如实现实时交互，服务器性能压力大；数据传输安全性差

 17. HTTPS 通信原理

安全 HTTP 是可选的。因此，对 Web 服务器发起请求时，我们需要有一种方式来告知 Web 服务器去执行 HTTP 的安全协议版本。这是在 URL 的方案中实现的。通常情况下，非安全 HTTP 的 URL 方案前缀为 http，如下所示：

> http://blog.maplemark.cn

在安全 HTTPS 协议中，URL 的方案前缀为 https，如下所示：

> https://blog.maplemark.cn

请求一个客户端（比如 Web 浏览器）对某 Web 资源执行某事务时，它会去检查 URL 的方案

- 如果 URL 的方案为 http，客户端就会打开一条到服务器端口 80（默认情况下）
的连接，并向其发送老的 HTTP 命令
- 如果 URL 的方案为 https，客户端就会打开一条到服务器端口 443（默认情况下）
的连接，然后与服务器“握手”，以二进制格式与服务器交换一些 SSL 安全参数，
附上加密的 HTTP 命令

SSL 是个二进制协议，与 HTTP 完全不同，其流量是承载在另一个端口上的（SSL 通常是由端口 443 承载的）。如果 SSL 和 HTTP 流量都从端口 80 到达，大部分 Web 服务器会将二进制 SSL 流量理解为错误的 HTTP 并关闭连接。将安全服务进一步整合到 HTTP 层中去就无需使用多个目的端口了，在实际中这样不会引发严重的问题

 建立安全传输

在未加密 HTTP 中，客户端会打开一条到 Web 服务器端口 80 的 TCP 连接，发送一条请求报文，接收一条响应报文，关闭连接

由于 SSL 安全层的存在，HTTPS 中这个过程会略微复杂一些。在 HTTPS 中，客户端首先打开一条到 Web 服务器端口 443（安全 HTTP 的默认端口）的连接。一旦建立了 TCP 连接，客户端和服务器就会初始化 SSL 层，对加密参数进行沟通，并交换密钥。握手完成之后，SSL 初始化就完成了，客户端就可以将请求报文发送给安全层了。在将这些报文发送给 TCP 之前，要先对其进行加密

 SSL 握手

在发送已加密的 HTTP 报文之前，客户端和服务器要进行一次 SSL 握手，在这个握手过程中，它们要完成以下工作

- 交换协议版本号
- 选择一个两端都了解的密码
- 对两端的身份进行认证
- 生成临时的会话密钥，以便加密信道

在通过网络传输任何已加密的 HTTP 数据之前，SSL 已经发送了一组握手数据来建立通信连接了

这是 SSL 握手的简化版本。根据 SSL 的使用方式，握手过程可能会复杂一些，但总
的思想就是这样

 服务器证书

SSL 支持双向认证，将服务器证书承载回客户端，再将客户端的证书回送给服务器。而现在，浏览时并不经常使用客户端证书。大部分用户甚至都没有自己的客户端证书。服务器可以要求使用客户端证书，但实际中很少出现这种情况。

另一方面，安全 HTTPS 事务总是要求使用服务器证书的。在一个 Web 服务器上执行安全事务，比如提交信用卡信息时，你总是希望是在与你所认为的那个组织对话。由知名权威机构签发的服务器证书可以帮助你在发送信用卡或私人信息之前评估你对服务器的信任度。

服务器证书是一个显示了组织的名称、地址、服务器 DNS 域名以及其他信息的 X.509 v3 派生证书。你和你所用的客户端软件可以检查证书，以确保所有的信息都是可信的

 站点证书的有效性

SSL 自身不要求用户检查 Web 服务器证书，但大部分现代浏览器都会对证书进行简单的完整性检查，并为用户提供进行进一步彻查的手段。网景公司提出的一种 Web 服务器证书有效性算法是大部分浏览器有效性验证技术的基础。

- 日期检测

首先，浏览器检查证书的起始日期和结束日期，以确保证书仍然有效。如果证书过期了，或者还未被激活，则证书有效性验证失败，浏览器显示一条错误信息

- 签名颁发者可信度检测

每个证书都是由某些证书颁发机构（CA）签发的，它们负责为服务器担保。证书有不同的等级，每种证书都要求不同级别的背景验证。比如，如果申请某个电子商务服务器证书，通常需要提供一个营业的合法证明

任何人都可以生成证书，但有些 CA 是非常著名的组织，它们通过非常清晰的流程来验证证书申请人的身份及商业行为的合法性。因此，浏览器会附带一个签名颁发机构的受信列表。如果浏览器收到了某未知（可能是恶意的）颁发机构签发的证书，那它通常会显示一条警告信息。有些证书会携带到受信 CA 的有效签名路径，浏览器可能会选择接受所有此类证书。换句话说，如果某受信 CA 为“Sam 的签名商店”签发了一个证书，而 Sam 的签名商店也签发了一个站点证书，浏览器可能会将其作为从有效 CA 路径导出的证书接受

- 签名检测

一旦判定签名授权是可信的，浏览器就要对签名使用签名颁发机构的公开密钥，并将其与校验码进行比较，以查看证书的完整性

- 站点身份检测

为防止服务器复制其他人的证书，或拦截其他人的流量，大部分浏览器都会试着去验证证书中的域名与它们所对话的服务器的域名是否匹配。服务器证书中通常都包含一个域名，但有些 CA 会为一组或一群服务器创建一些包含了服务器名称列表或通配域名的证书。如果主机名与证书中的标识符不匹配，面向用户的客户端要么就去通知用户，要么就以表示证书不正确的差错报文来终止连接

 18. HTTP 2.0

多路复用、客户端拉拽/服务器推送、流量控制、WebSocket

 19. WebSocket

WebSocket 是一种通信协议，定义了一个全双工通信信道，仅通过 Web 上的一个 Socket 即可进行通信

 主要特点

- 推送功能：支持由服务器向客户端推送数据的推送功能
- 减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态

 20. IPv6 与 IPv4 有什么变化

更大的地址空间、扩展的地址层次结构、灵活的首部格式、改进的选项、允许协议继续扩充、支持资源的预分配

 21. 什么是心跳机制

心跳机制是定时发送一个自定义的结构体(心跳包)，让对方知道自己还活着，以确保连接的有效性的机制

 22. 什么是长连接

长连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包
```