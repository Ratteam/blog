(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{300:function(e,s,n){"use strict";n.r(s);var t=n(17),a=Object(t.a)({},(function(){var e=this,s=e.$createElement,n=e._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("TOC"),e._v(" "),n("h1",{attrs:{id:"redis使用教程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis使用教程"}},[e._v("#")]),e._v(" redis使用教程")]),e._v(" "),n("blockquote",[n("p",[e._v("REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。")])]),e._v(" "),n("h2",{attrs:{id:"redis-简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-简介"}},[e._v("#")]),e._v(" Redis 简介")]),e._v(" "),n("blockquote",[n("p",[e._v("Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。")])]),e._v(" "),n("p",[e._v("Redis 与其他 key - value 缓存产品有以下三个特点：")]),e._v(" "),n("ul",[n("li",[e._v("Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。")]),e._v(" "),n("li",[e._v("Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。")]),e._v(" "),n("li",[e._v("Redis支持数据的备份，即master-slave模式的数据备份。")])]),e._v(" "),n("p",[n("strong",[e._v("Redis 优势")])]),e._v(" "),n("p",[e._v("性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。")]),e._v(" "),n("p",[e._v("丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。")]),e._v(" "),n("p",[e._v("原子性 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。")]),e._v(" "),n("p",[e._v("丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。")]),e._v(" "),n("p",[n("strong",[e._v("Redis与其他key-value存储有什么不同？")])]),e._v(" "),n("p",[e._v("Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。")]),e._v(" "),n("p",[e._v("Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。")]),e._v(" "),n("h2",{attrs:{id:"redis-安装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-安装"}},[e._v("#")]),e._v(" Redis 安装")]),e._v(" "),n("p",[n("strong",[e._v("Window 下安装")])]),e._v(" "),n("p",[e._v("下载地址：https://github.com/tporadowski/redis/releases。")]),e._v(" "),n("p",[e._v("Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 Redis-x64-xxx.zip压缩包到 C 盘，解压后，将文件夹重新命名为 redis。")]),e._v(" "),n("p",[e._v("打开一个 cmd 窗口 使用 cd 命令切换目录到 C:\\redis 运行：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis-server.exe redis.windows.conf\n")])])]),n("p",[e._v("如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。")]),e._v(" "),n("p",[n("strong",[e._v("Redis 安装")])]),e._v(" "),n("p",[e._v("这时候另启一个 cmd 窗口，原来的不要关闭，不然就无法访问服务端了。")]),e._v(" "),n("p",[e._v("切换到 redis 目录下运行:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis-cli.exe -h 127.0.0.1 -p 6379\n")])])]),n("p",[e._v("设置键值对:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("set myKey abc\n")])])]),n("p",[e._v("取出键值对:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("get myKey\n")])])]),n("p",[n("strong",[e._v("Linux 下安装")])]),e._v(" "),n("p",[e._v("下载地址：http://redis.io/download，下载最新稳定版本。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz\n$ tar xzf redis-2.8.17.tar.gz\n$ cd redis-2.8.17\n$ make\n")])])]),n("p",[e._v("make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：")]),e._v(" "),n("p",[e._v("下面启动redis服务.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ cd src\n$ ./redis-server\n")])])]),n("p",[e._v("注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ cd src\n$ ./redis-server ../redis.conf\n")])])]),n("p",[e._v("redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。")]),e._v(" "),n("p",[e._v("启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('$ cd src\n$ ./redis-cli\nredis> set foo bar\nOK\nredis> get foo\n"bar"\n')])])]),n("p",[n("strong",[e._v("Ubuntu 下安装")]),e._v("\n在 Ubuntu 系统安装 Redis 可以使用以下命令:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$sudo apt-get update\n$sudo apt-get install redis-server\n")])])]),n("p",[e._v("启动 Redis")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ redis-server\n")])])]),n("p",[e._v("查看 redis 是否启动？")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ redis-cli\n")])])]),n("p",[e._v("以上命令将打开以下终端：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis 127.0.0.1:6379>\n")])])]),n("p",[e._v("127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis 127.0.0.1:6379> ping\nPONG\n")])])]),n("p",[e._v("以上说明我们已经成功安装了redis。")]),e._v(" "),n("h2",{attrs:{id:"redis-配置"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-配置"}},[e._v("#")]),e._v(" Redis 配置")]),e._v(" "),n("p",[e._v("Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf(Windows 名为 redis.windows.conf)。")]),e._v(" "),n("p",[e._v("你可以通过 CONFIG 命令查看或设置配置项。")]),e._v(" "),n("p",[e._v("Redis CONFIG 命令格式如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis 127.0.0.1:6379> CONFIG GET CONFIG_SETTING_NAME\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> CONFIG GET loglevel\n\n1) "loglevel"\n2) "notice"\n')])])]),n("p",[e._v("使用 * 号获取所有配置项：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> CONFIG GET *\n\n  1) "dbfilename"\n  2) "dump.rdb"\n  3) "requirepass"\n  4) ""\n  5) "masterauth"\n  6) ""\n  7) "unixsocket"\n  8) ""\n  9) "logfile"\n 10) ""\n 11) "pidfile"\n 12) "/var/run/redis.pid"\n 13) "maxmemory"\n 14) "0"\n 15) "maxmemory-samples"\n 16) "3"\n 17) "timeout"\n 18) "0"\n 19) "tcp-keepalive"\n 20) "0"\n 21) "auto-aof-rewrite-percentage"\n 22) "100"\n 23) "auto-aof-rewrite-min-size"\n 24) "67108864"\n 25) "hash-max-ziplist-entries"\n 26) "512"\n 27) "hash-max-ziplist-value"\n 28) "64"\n 29) "list-max-ziplist-entries"\n 30) "512"\n 31) "list-max-ziplist-value"\n 32) "64"\n 33) "set-max-intset-entries"\n 34) "512"\n 35) "zset-max-ziplist-entries"\n 36) "128"\n 37) "zset-max-ziplist-value"\n 38) "64"\n 39) "hll-sparse-max-bytes"\n 40) "3000"\n 41) "lua-time-limit"\n 42) "5000"\n 43) "slowlog-log-slower-than"\n 44) "10000"\n 45) "latency-monitor-threshold"\n 46) "0"\n 47) "slowlog-max-len"\n 48) "128"\n 49) "port"\n 50) "6379"\n 51) "tcp-backlog"\n 52) "511"\n 53) "databases"\n 54) "16"\n 55) "repl-ping-slave-period"\n 56) "10"\n 57) "repl-timeout"\n 58) "60"\n 59) "repl-backlog-size"\n 60) "1048576"\n 61) "repl-backlog-ttl"\n 62) "3600"\n 63) "maxclients"\n 64) "4064"\n 65) "watchdog-period"\n 66) "0"\n 67) "slave-priority"\n 68) "100"\n 69) "min-slaves-to-write"\n 70) "0"\n 71) "min-slaves-max-lag"\n 72) "10"\n 73) "hz"\n 74) "10"\n 75) "no-appendfsync-on-rewrite"\n 76) "no"\n 77) "slave-serve-stale-data"\n 78) "yes"\n 79) "slave-read-only"\n 80) "yes"\n 81) "stop-writes-on-bgsave-error"\n 82) "yes"\n 83) "daemonize"\n 84) "no"\n 85) "rdbcompression"\n 86) "yes"\n 87) "rdbchecksum"\n 88) "yes"\n 89) "activerehashing"\n 90) "yes"\n 91) "repl-disable-tcp-nodelay"\n 92) "no"\n 93) "aof-rewrite-incremental-fsync"\n 94) "yes"\n 95) "appendonly"\n 96) "no"\n 97) "dir"\n 98) "/home/deepak/Downloads/redis-2.8.13/src"\n 99) "maxmemory-policy"\n100) "volatile-lru"\n101) "appendfsync"\n102) "everysec"\n103) "save"\n104) "3600 1 300 100 60 10000"\n105) "loglevel"\n106) "notice"\n107) "client-output-buffer-limit"\n108) "normal 0 0 0 slave 268435456 67108864 60 pubsub 33554432 8388608 60"\n109) "unixsocketperm"\n110) "0"\n111) "slaveof"\n112) ""\n113) "notify-keyspace-events"\n114) ""\n115) "bind"\n116) ""\n')])])]),n("p",[n("strong",[e._v("编辑配置")])]),e._v(" "),n("p",[e._v("你可以通过修改 redis.conf 文件或使用 CONFIG set 命令来修改配置。")]),e._v(" "),n("p",[e._v("CONFIG SET 命令基本语法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis 127.0.0.1:6379> CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> CONFIG SET loglevel "notice"\nOK\nredis 127.0.0.1:6379> CONFIG GET loglevel\n\n1) "loglevel"\n2) "notice"\n')])])]),n("p",[n("strong",[e._v("参数说明")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis.conf 配置项说明如下：\n\ndaemonize no\tRedis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）\n\npidfile /var/run/redis.pid\t当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定\n\nport 6379\t指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字\n\nbind 127.0.0.1\t绑定的主机地址\n\ntimeout 300\t当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能\n\nloglevel notice\t指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice\n\nlogfile stdout\t日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null\n\ndatabases 16\t设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id\n\nsave <seconds> <changes>\nRedis 默认配置文件中提供了三个条件：\n\nsave 900 1\n\nsave 300 10\n\nsave 60 10000\n\n分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。\n\n指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n\nrdbcompression yes\t指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大\n\ndbfilename dump.rdb\t指定本地数据库文件名，默认值为 dump.rdb\n\ndir ./\t指定本地数据库存放目录\n\nslaveof <masterip> <masterport>\t设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步\n\nmasterauth <master-password>\t当 master 服务设置了密码保护时，slav 服务连接 master 的密码\n\nrequirepass foobared\t设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭\n\nmaxclients 128\t设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息\n\nmaxmemory <bytes>\t指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区\n\nappendonly no\t指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no\n\nappendfilename appendonly.aof\t指定更新日志文件名，默认为 appendonly.aof\n\nappendfsync everysec\t\n指定更新日志条件，共有 3 个可选值：\n\nno：表示等操作系统进行数据缓存同步到磁盘（快）\nalways：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）\neverysec：表示每秒同步一次（折中，默认值）\n\nvm-enabled no\t指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）\n\nvm-swap-file /tmp/redis.swap\t虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享\n\nvm-max-memory 0\t将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0\n\nvm-page-size 32\tRedis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值\n\nvm-pages 134217728\t设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。\n\nvm-max-threads 4\t设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4\n\nglueoutputbuf yes\t设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\n\nhash-max-zipmap-entries 64\nhash-max-zipmap-value 512\t指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\n\nactiverehashing yes\t指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）\n\ninclude /path/to/local.conf\t指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件\n")])])]),n("h2",{attrs:{id:"redis-数据类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-数据类型"}},[e._v("#")]),e._v(" Redis 数据类型")]),e._v(" "),n("blockquote",[n("p",[e._v("Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。")])]),e._v(" "),n("p",[n("strong",[e._v("String（字符串）")])]),e._v(" "),n("p",[e._v("string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。")]),e._v(" "),n("p",[e._v("string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。")]),e._v(" "),n("p",[e._v("string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> SET runoob "菜鸟教程"\nOK\nredis 127.0.0.1:6379> GET runoob\n"菜鸟教程"\n')])])]),n("p",[e._v("在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 runoob，对应的值为 菜鸟教程。")]),e._v(" "),n("blockquote",[n("p",[e._v("注意：一个键最大能存储 512MB。")])]),e._v(" "),n("p",[n("strong",[e._v("Hash（哈希）")])]),e._v(" "),n("p",[e._v("Redis hash 是一个键值(key=>value)对集合。")]),e._v(" "),n("p",[e._v("Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('DEL runoob 用于删除前面测试用过的 key，不然会报错：(error) WRONGTYPE Operation against a key holding the wrong kind of value\n\nredis 127.0.0.1:6379> DEL runoob\nredis 127.0.0.1:6379> HMSET runoob field1 "Hello" field2 "World"\n"OK"\nredis 127.0.0.1:6379> HGET runoob field1\n"Hello"\nredis 127.0.0.1:6379> HGET runoob field2\n"World"\n')])])]),n("p",[e._v("实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=>value 对, HGET 获取对应 field 对应的 value。")]),e._v(" "),n("p",[e._v("每个 hash 可以存储 232 -1 键值对（40多亿）。")]),e._v(" "),n("p",[n("strong",[e._v("List（列表）")])]),e._v(" "),n("p",[e._v("Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> DEL runoob\nredis 127.0.0.1:6379> lpush runoob redis\n(integer) 1\nredis 127.0.0.1:6379> lpush runoob mongodb\n(integer) 2\nredis 127.0.0.1:6379> lpush runoob rabitmq\n(integer) 3\nredis 127.0.0.1:6379> lrange runoob 0 10\n1) "rabitmq"\n2) "mongodb"\n3) "redis"\nredis 127.0.0.1:6379>\n')])])]),n("p",[e._v("列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。")]),e._v(" "),n("p",[n("strong",[e._v("Set（集合）")])]),e._v(" "),n("p",[e._v("Redis 的 Set 是 string 类型的无序集合。")]),e._v(" "),n("p",[e._v("集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。")]),e._v(" "),n("p",[n("strong",[e._v("sadd 命令")])]),e._v(" "),n("p",[e._v("添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('sadd key member\nredis 127.0.0.1:6379> DEL runoob\nredis 127.0.0.1:6379> sadd runoob redis\n(integer) 1\nredis 127.0.0.1:6379> sadd runoob mongodb\n(integer) 1\nredis 127.0.0.1:6379> sadd runoob rabitmq\n(integer) 1\nredis 127.0.0.1:6379> sadd runoob rabitmq\n(integer) 0\nredis 127.0.0.1:6379> smembers runoob\n\n1) "redis"\n2) "rabitmq"\n3) "mongodb"\n')])])]),n("blockquote",[n("p",[e._v("注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。")])]),e._v(" "),n("blockquote",[n("p",[e._v("集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。")])]),e._v(" "),n("p",[n("strong",[e._v("zset(sorted set：有序集合)")])]),e._v(" "),n("p",[e._v("Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。\n不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。")]),e._v(" "),n("p",[e._v("zset的成员是唯一的,但分数(score)却可以重复。")]),e._v(" "),n("p",[n("strong",[e._v("zadd 命令")])]),e._v(" "),n("p",[e._v("添加元素到集合，元素在集合中存在则更新对应score")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('zadd key score member \nredis 127.0.0.1:6379> DEL runoob\nredis 127.0.0.1:6379> zadd runoob 0 redis\n(integer) 1\nredis 127.0.0.1:6379> zadd runoob 0 mongodb\n(integer) 1\nredis 127.0.0.1:6379> zadd runoob 0 rabitmq\n(integer) 1\nredis 127.0.0.1:6379> zadd runoob 0 rabitmq\n(integer) 0\nredis 127.0.0.1:6379> > ZRANGEBYSCORE runoob 0 1000\n1) "mongodb"\n2) "rabitmq"\n3) "redis"\n')])])]),n("h2",{attrs:{id:"redis-命令"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-命令"}},[e._v("#")]),e._v(" Redis 命令")]),e._v(" "),n("blockquote",[n("p",[e._v("Redis 命令用于在 redis 服务上执行操作。")])]),e._v(" "),n("p",[e._v("要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。")]),e._v(" "),n("p",[e._v("Redis 客户端的基本语法为：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ redis-cli\n$ redis-cli --raw 避免中文乱码\n")])])]),n("p",[e._v("以下实例讲解了如何启动 redis 客户端：")]),e._v(" "),n("p",[e._v("启动 redis 客户端，打开终端并输入命令 redis-cli。该命令会连接本地的 redis 服务。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$redis-cli\nredis 127.0.0.1:6379>\nredis 127.0.0.1:6379> PING\n\nPONG\n")])])]),n("p",[e._v("在以上实例中我们连接到本地的 redis 服务并执行 PING 命令，该命令用于检测 redis 服务是否启动。")]),e._v(" "),n("p",[n("strong",[e._v("在远程服务上执行命令")])]),e._v(" "),n("p",[e._v("如果需要在远程 redis 服务上执行命令，同样我们使用的也是 redis-cli 命令。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ redis-cli -h host -p port -a password\n")])])]),n("p",[e._v("以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('$redis-cli -h 127.0.0.1 -p 6379 -a "mypass"\nredis 127.0.0.1:6379>\nredis 127.0.0.1:6379> PING\n\nPONG\n')])])]),n("h2",{attrs:{id:"redis-键-key"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-键-key"}},[e._v("#")]),e._v(" Redis 键(key)")]),e._v(" "),n("p",[e._v("Redis 键命令用于管理 redis 的键。")]),e._v(" "),n("p",[e._v("Redis 键命令的基本语法如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis 127.0.0.1:6379> COMMAND KEY_NAME\nredis 127.0.0.1:6379> SET runoobkey redis\nOK\nredis 127.0.0.1:6379> DEL runoobkey\n(integer) 1\n")])])]),n("p",[e._v("在以上实例中 DEL 是一个命令， runoobkey 是一个键。 如果键被删除成功，命令执行后输出 (integer) 1，否则将输出 (integer) 0")]),e._v(" "),n("p",[n("strong",[e._v("Redis keys 命令")])]),e._v(" "),n("p",[e._v("下表给出了与 Redis 键相关的基本命令：")]),e._v(" "),n("p",[e._v("DEL key 该命令用于在 key 存在时删除 key。")]),e._v(" "),n("p",[e._v("DUMP key 序列化给定 key ，并返回被序列化的值。")]),e._v(" "),n("p",[e._v("EXISTS key 检查给定 key 是否存在。")]),e._v(" "),n("p",[e._v("EXPIRE key seconds 为给定 key 设置过期时间，以秒计。")]),e._v(" "),n("p",[e._v("EXPIREAT key timestamp EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。")]),e._v(" "),n("p",[e._v("PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计。")]),e._v(" "),n("p",[e._v("PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计")]),e._v(" "),n("p",[e._v("KEYS pattern 查找所有符合给定模式( pattern)的 key 。")]),e._v(" "),n("p",[e._v("MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中。")]),e._v(" "),n("p",[e._v("PERSIST key 移除 key 的过期时间，key 将持久保持。")]),e._v(" "),n("p",[e._v("PTTL key 以毫秒为单位返回 key 的剩余的过期时间。")]),e._v(" "),n("p",[e._v("TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。")]),e._v(" "),n("p",[e._v("RANDOMKEY 从当前数据库中随机返回一个 key 。")]),e._v(" "),n("p",[e._v("RENAME key newkey 修改 key 的名称")]),e._v(" "),n("p",[e._v("RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。")]),e._v(" "),n("p",[e._v("SCAN cursor [MATCH pattern] [COUNT count] 迭代数据库中的数据库键。")]),e._v(" "),n("p",[e._v("TYPE key 返回 key 所储存的值的类型。")]),e._v(" "),n("h2",{attrs:{id:"redis-字符串-string"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-字符串-string"}},[e._v("#")]),e._v(" Redis 字符串(String)")]),e._v(" "),n("p",[e._v("Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> COMMAND KEY_NAME\nredis 127.0.0.1:6379> SET runoobkey redis\nOK\nredis 127.0.0.1:6379> GET runoobkey\n"redis"\n')])])]),n("p",[e._v("在以上实例中我们使用了 SET 和 GET 命令，键为 runoobkey。")]),e._v(" "),n("p",[n("strong",[e._v("Redis 字符串命令")])]),e._v(" "),n("p",[e._v("下表列出了常用的 redis 字符串命令：")]),e._v(" "),n("p",[e._v("SET key value 设置指定 key 的值")]),e._v(" "),n("p",[e._v("GET key 获取指定 key 的值。")]),e._v(" "),n("p",[e._v("GETRANGE key start end 返回 key 中字符串值的子字符")]),e._v(" "),n("p",[e._v("GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。")]),e._v(" "),n("p",[e._v("GETBIT key offset 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。")]),e._v(" "),n("p",[e._v("MGET key1 [key2..] 获取所有(一个或多个)给定 key 的值。")]),e._v(" "),n("p",[e._v("SETBIT key offset value 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。")]),e._v(" "),n("p",[e._v("SETEX key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。")]),e._v(" "),n("p",[e._v("SETNX key value 只有在 key 不存在时设置 key 的值。")]),e._v(" "),n("p",[e._v("SETRANGE key offset value 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。")]),e._v(" "),n("p",[e._v("STRLEN key 返回 key 所储存的字符串值的长度。")]),e._v(" "),n("p",[e._v("MSET key value [key value ...] 同时设置一个或多个 key-value 对。")]),e._v(" "),n("p",[e._v("MSETNX key value [key value ...] 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。")]),e._v(" "),n("p",[e._v("PSETEX key milliseconds value 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。")]),e._v(" "),n("p",[e._v("INCR key 将 key 中储存的数字值增一。")]),e._v(" "),n("p",[e._v("INCRBY key increment 将 key 所储存的值加上给定的增量值（increment） 。")]),e._v(" "),n("p",[e._v("INCRBYFLOAT key increment 将 key 所储存的值加上给定的浮点增量值（increment） 。")]),e._v(" "),n("p",[e._v("DECR key 将 key 中储存的数字值减一。")]),e._v(" "),n("p",[e._v("DECRBY key decrement key 所储存的值减去给定的减量值（decrement） 。")]),e._v(" "),n("p",[e._v("APPEND key value 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。")]),e._v(" "),n("h2",{attrs:{id:"redis-哈希-hash"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-哈希-hash"}},[e._v("#")]),e._v(" Redis 哈希(Hash)")]),e._v(" "),n("p",[e._v("Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。")]),e._v(" "),n("p",[e._v("Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('127.0.0.1:6379>  HMSET runoobkey name "redis tutorial" description "redis basic commands for caching" likes 20 visitors 23000\nOK\n127.0.0.1:6379>  HGETALL runoobkey\n1) "name"\n2) "redis tutorial"\n3) "description"\n4) "redis basic commands for caching"\n5) "likes"\n6) "20"\n7) "visitors"\n8) "23000"\n')])])]),n("p",[e._v("在以上实例中，我们设置了 redis 的一些描述信息(name, description, likes, visitors) 到哈希表的 runoobkey 中。")]),e._v(" "),n("p",[n("strong",[e._v("Redis hash 命令")])]),e._v(" "),n("p",[e._v("下表列出了 redis hash 基本的相关命令：")]),e._v(" "),n("p",[e._v("HDEL key field1 [field2] 删除一个或多个哈希表字段")]),e._v(" "),n("p",[e._v("HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。")]),e._v(" "),n("p",[e._v("HGET key field 获取存储在哈希表中指定字段的值。")]),e._v(" "),n("p",[e._v("HGETALL key 获取在哈希表中指定 key 的所有字段和值")]),e._v(" "),n("p",[e._v("HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。")]),e._v(" "),n("p",[e._v("HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。")]),e._v(" "),n("p",[e._v("HKEYS key 获取所有哈希表中的字段")]),e._v(" "),n("p",[e._v("HLEN key 获取哈希表中字段的数量")]),e._v(" "),n("p",[e._v("HMGET key field1 [field2] 获取所有给定字段的值")]),e._v(" "),n("p",[e._v("HMSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中。")]),e._v(" "),n("p",[e._v("HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。")]),e._v(" "),n("p",[e._v("HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。")]),e._v(" "),n("p",[e._v("HVALS key 获取哈希表中所有值。")]),e._v(" "),n("p",[e._v("HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。")]),e._v(" "),n("h2",{attrs:{id:"redis-列表-list"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-列表-list"}},[e._v("#")]),e._v(" Redis 列表(List)")]),e._v(" "),n("p",[e._v("Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）")]),e._v(" "),n("p",[e._v("一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> LPUSH runoobkey redis\n(integer) 1\nredis 127.0.0.1:6379> LPUSH runoobkey mongodb\n(integer) 2\nredis 127.0.0.1:6379> LPUSH runoobkey mysql\n(integer) 3\nredis 127.0.0.1:6379> LRANGE runoobkey 0 10\n\n1) "mysql"\n2) "mongodb"\n3) "redis"\n')])])]),n("p",[e._v("在以上实例中我们使用了 LPUSH 将三个值插入了名为 runoobkey 的列表当中。")]),e._v(" "),n("p",[n("strong",[e._v("Redis 列表命令")])]),e._v(" "),n("p",[e._v("下表列出了列表相关的基本命令：")]),e._v(" "),n("p",[e._v("BLPOP key1 [key2 ] timeout 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。")]),e._v(" "),n("p",[e._v("BRPOP key1 [key2 ] timeout 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。")]),e._v(" "),n("p",[e._v("BRPOPLPUSH source destination timeout 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。")]),e._v(" "),n("p",[e._v("LINDEX key index 通过索引获取列表中的元素")]),e._v(" "),n("p",[e._v("LINSERT key BEFORE|AFTER pivot value 在列表的元素前或者后插入元素")]),e._v(" "),n("p",[e._v("LLEN key 获取列表长度")]),e._v(" "),n("p",[e._v("LPOP key 移出并获取列表的第一个元素")]),e._v(" "),n("p",[e._v("LPUSH key value1 [value2] 将一个或多个值插入到列表头部")]),e._v(" "),n("p",[e._v("LPUSHX key value 将一个值插入到已存在的列表头部")]),e._v(" "),n("p",[e._v("LRANGE key start stop 获取列表指定范围内的元素")]),e._v(" "),n("p",[e._v("LREM key count value 移除列表元素")]),e._v(" "),n("p",[e._v("LSET key index value 通过索引设置列表元素的值")]),e._v(" "),n("p",[e._v("LTRIM key start stop 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。")]),e._v(" "),n("p",[e._v("RPOP key 移除列表的最后一个元素，返回值为移除的元素。")]),e._v(" "),n("p",[e._v("RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回")]),e._v(" "),n("p",[e._v("RPUSH key value1 [value2] 在列表中添加一个或多个值")]),e._v(" "),n("p",[e._v("RPUSHX key value 为已存在的列表添加值")]),e._v(" "),n("h2",{attrs:{id:"redis-集合-set"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-集合-set"}},[e._v("#")]),e._v(" Redis 集合(Set)")]),e._v(" "),n("p",[e._v("Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。")]),e._v(" "),n("p",[e._v("Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。")]),e._v(" "),n("p",[e._v("集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> SADD runoobkey redis\n(integer) 1\nredis 127.0.0.1:6379> SADD runoobkey mongodb\n(integer) 1\nredis 127.0.0.1:6379> SADD runoobkey mysql\n(integer) 1\nredis 127.0.0.1:6379> SADD runoobkey mysql\n(integer) 0\nredis 127.0.0.1:6379> SMEMBERS runoobkey\n\n1) "mysql"\n2) "mongodb"\n3) "redis"\n')])])]),n("p",[e._v("在以上实例中我们通过 SADD 命令向名为 runoobkey 的集合插入的三个元素。")]),e._v(" "),n("p",[n("strong",[e._v("Redis 集合命令")])]),e._v(" "),n("p",[e._v("下表列出了 Redis 集合基本命令：")]),e._v(" "),n("p",[e._v("SADD key member1 [member2] 向集合添加一个或多个成员")]),e._v(" "),n("p",[e._v("SCARD key 获取集合的成员数")]),e._v(" "),n("p",[e._v("SDIFF key1 [key2] 返回给定所有集合的差集")]),e._v(" "),n("p",[e._v("SDIFFSTORE destination key1 [key2] 返回给定所有集合的差集并存储在 destination 中")]),e._v(" "),n("p",[e._v("SINTER key1 [key2] 返回给定所有集合的交集")]),e._v(" "),n("p",[e._v("SINTERSTORE destination key1 [key2] 返回给定所有集合的交集并存储在 destination 中")]),e._v(" "),n("p",[e._v("SISMEMBER key member 判断 member 元素是否是集合 key 的成员")]),e._v(" "),n("p",[e._v("SMEMBERS key 返回集合中的所有成员")]),e._v(" "),n("p",[e._v("SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合")]),e._v(" "),n("p",[e._v("SPOP key 移除并返回集合中的一个随机元素")]),e._v(" "),n("p",[e._v("SRANDMEMBER key [count] 返回集合中一个或多个随机数")]),e._v(" "),n("p",[e._v("SREM key member1 [member2] 移除集合中一个或多个成员")]),e._v(" "),n("p",[e._v("SUNION key1 [key2] 返回所有给定集合的并集")]),e._v(" "),n("p",[e._v("SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中")]),e._v(" "),n("p",[e._v("SSCAN key cursor [MATCH pattern] [COUNT count] 迭代集合中的元素")]),e._v(" "),n("h2",{attrs:{id:"redis-有序集合-sorted-set"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-有序集合-sorted-set"}},[e._v("#")]),e._v(" Redis 有序集合(sorted set)")]),e._v(" "),n("p",[e._v("Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。")]),e._v(" "),n("p",[e._v("不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。")]),e._v(" "),n("p",[e._v("有序集合的成员是唯一的,但分数(score)却可以重复。")]),e._v(" "),n("p",[e._v("集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> ZADD runoobkey 1 redis\n(integer) 1\nredis 127.0.0.1:6379> ZADD runoobkey 2 mongodb\n(integer) 1\nredis 127.0.0.1:6379> ZADD runoobkey 3 mysql\n(integer) 1\nredis 127.0.0.1:6379> ZADD runoobkey 3 mysql\n(integer) 0\nredis 127.0.0.1:6379> ZADD runoobkey 4 mysql\n(integer) 0\nredis 127.0.0.1:6379> ZRANGE runoobkey 0 10 WITHSCORES\n\n1) "redis"\n2) "1"\n3) "mongodb"\n4) "2"\n5) "mysql"\n6) "4"\n')])])]),n("p",[e._v("在以上实例中我们通过命令 ZADD 向 redis 的有序集合中添加了三个值并关联上分数。")]),e._v(" "),n("p",[n("strong",[e._v("Redis 有序集合命令")])]),e._v(" "),n("p",[e._v("下表列出了 redis 有序集合的基本命令:")]),e._v(" "),n("p",[e._v("ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数")]),e._v(" "),n("p",[e._v("ZCARD key 获取有序集合的成员数")]),e._v(" "),n("p",[e._v("ZCOUNT key min max 计算在有序集合中指定区间分数的成员数")]),e._v(" "),n("p",[e._v("ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 increment")]),e._v(" "),n("p",[e._v("ZINTERSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中")]),e._v(" "),n("p",[e._v("ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量")]),e._v(" "),n("p",[e._v("ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合指定区间内的成员")]),e._v(" "),n("p",[e._v("ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员")]),e._v(" "),n("p",[e._v("ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员")]),e._v(" "),n("p",[e._v("ZRANK key member 返回有序集合中指定成员的索引")]),e._v(" "),n("p",[e._v("ZREM key member [member ...] 移除有序集合中的一个或多个成员")]),e._v(" "),n("p",[e._v("ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员")]),e._v(" "),n("p",[e._v("ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员")]),e._v(" "),n("p",[e._v("ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员")]),e._v(" "),n("p",[e._v("ZREVRANGE key start stop [WITHSCORES] 返回有序集中指定区间内的成员，通过索引，分数从高到低")]),e._v(" "),n("p",[e._v("ZREVRANGEBYSCORE key max min [WITHSCORES] 返回有序集中指定分数区间内的成员，分数从高到低排序")]),e._v(" "),n("p",[e._v("ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序")]),e._v(" "),n("p",[e._v("ZSCORE key member 返回有序集中，成员的分数值")]),e._v(" "),n("p",[e._v("ZUNIONSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的并集，并存储在新的 key 中")]),e._v(" "),n("p",[e._v("ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值）")]),e._v(" "),n("h2",{attrs:{id:"redis-hyperloglog"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-hyperloglog"}},[e._v("#")]),e._v(" Redis HyperLogLog")]),e._v(" "),n("p",[e._v("Redis 在 2.8.9 版本添加了 HyperLogLog 结构。")]),e._v(" "),n("p",[e._v("Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。")]),e._v(" "),n("p",[e._v("在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。")]),e._v(" "),n("p",[e._v("但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。")]),e._v(" "),n("p",[n("strong",[e._v("什么是基数?")])]),e._v(" "),n("p",[e._v("比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。")]),e._v(" "),n("p",[e._v("以下实例演示了 HyperLogLog 的工作过程：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> PFADD runoobkey "redis"\n\n1) (integer) 1\n\nredis 127.0.0.1:6379> PFADD runoobkey "mongodb"\n\n1) (integer) 1\n\nredis 127.0.0.1:6379> PFADD runoobkey "mysql"\n\n1) (integer) 1\n\nredis 127.0.0.1:6379> PFCOUNT runoobkey\n\n(integer) 3\n')])])]),n("p",[n("strong",[e._v("Redis HyperLogLog 命令")])]),e._v(" "),n("p",[e._v("下表列出了 redis HyperLogLog 的基本命令：")]),e._v(" "),n("p",[e._v("PFADD key element [element ...] 添加指定元素到 HyperLogLog 中。")]),e._v(" "),n("p",[e._v("PFCOUNT key [key ...] 返回给定 HyperLogLog 的基数估算值。")]),e._v(" "),n("p",[e._v("PFMERGE destkey sourcekey [sourcekey ...] 将多个 HyperLogLog 合并为一个 HyperLogLog")]),e._v(" "),n("h2",{attrs:{id:"redis-发布订阅"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-发布订阅"}},[e._v("#")]),e._v(" Redis 发布订阅")]),e._v(" "),n("p",[e._v("Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。")]),e._v(" "),n("p",[e._v("Redis 客户端可以订阅任意数量的频道。")]),e._v(" "),n("p",[e._v("下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：")]),e._v(" "),n("p",[e._v("当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：")]),e._v(" "),n("p",[e._v("以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> SUBSCRIBE redisChat\n\nReading messages... (press Ctrl-C to quit)\n1) "subscribe"\n2) "redisChat"\n3) (integer) 1\n')])])]),n("p",[e._v("现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> PUBLISH redisChat "Redis is a great caching technique"\n\n(integer) 1\n\nredis 127.0.0.1:6379> PUBLISH redisChat "Learn redis by runoob.com"\n\n(integer) 1\n\n订阅者的客户端会显示如下消息\n1) "message"\n2) "redisChat"\n3) "Redis is a great caching technique"\n1) "message"\n2) "redisChat"\n3) "Learn redis by runoob.com"\n')])])]),n("p",[n("strong",[e._v("Redis 发布订阅命令")])]),e._v(" "),n("p",[e._v("下表列出了 redis 发布订阅常用命令：")]),e._v(" "),n("p",[e._v("PSUBSCRIBE pattern [pattern ...] 订阅一个或多个符合给定模式的频道。")]),e._v(" "),n("p",[e._v("PUBSUB subcommand [argument [argument ...]] 查看订阅与发布系统状态。")]),e._v(" "),n("p",[e._v("PUBLISH channel message 将信息发送到指定的频道。")]),e._v(" "),n("p",[e._v("PUNSUBSCRIBE [pattern [pattern ...]] 退订所有给定模式的频道。")]),e._v(" "),n("p",[e._v("SUBSCRIBE channel [channel ...] 订阅给定的一个或多个频道的信息。")]),e._v(" "),n("p",[e._v("UNSUBSCRIBE [channel [channel ...]] 指退订给定的频道。")]),e._v(" "),n("h2",{attrs:{id:"redis-事务"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-事务"}},[e._v("#")]),e._v(" Redis 事务")]),e._v(" "),n("p",[e._v("Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：")]),e._v(" "),n("p",[e._v("批量操作在发送 EXEC 命令前被放入队列缓存。")]),e._v(" "),n("p",[e._v("收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。")]),e._v(" "),n("p",[e._v("在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。")]),e._v(" "),n("p",[e._v("一个事务从开始到执行会经历以下三个阶段：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("开始事务。\n命令入队。\n执行事务。\n")])])]),n("p",[e._v("以下是一个事务的例子， 它先以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> MULTI\nOK\n\nredis 127.0.0.1:6379> SET book-name "Mastering C++ in 21 days"\nQUEUED\n\nredis 127.0.0.1:6379> GET book-name\nQUEUED\n\nredis 127.0.0.1:6379> SADD tag "C++" "Programming" "Mastering Series"\nQUEUED\n\nredis 127.0.0.1:6379> SMEMBERS tag\nQUEUED\n\nredis 127.0.0.1:6379> EXEC\n1) OK\n2) "Mastering C++ in 21 days"\n3) (integer) 3\n4) 1) "Mastering Series"\n   2) "C++"\n   3) "Programming"\n')])])]),n("p",[e._v("单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。")]),e._v(" "),n("p",[e._v("事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。")]),e._v(" "),n("p",[e._v("这是官网上的说明 From redis docs on transactions:")]),e._v(" "),n("p",[e._v("It's important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands.")]),e._v(" "),n("p",[e._v("比如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis 127.0.0.1:7000> multi\nOK\nredis 127.0.0.1:7000> set a aaa\nQUEUED\nredis 127.0.0.1:7000> set b bbb\nQUEUED\nredis 127.0.0.1:7000> set c ccc\nQUEUED\nredis 127.0.0.1:7000> exec\n1) OK\n2) OK\n3) OK\n")])])]),n("p",[e._v("如果在 set b bbb 处失败，set a 已成功不会回滚，set c 还会继续执行。")]),e._v(" "),n("p",[n("strong",[e._v("Redis 事务命令")])]),e._v(" "),n("p",[e._v("下表列出了 redis 事务的相关命令：")]),e._v(" "),n("p",[e._v("DISCARD 取消事务，放弃执行事务块内的所有命令。")]),e._v(" "),n("p",[e._v("EXEC 执行所有事务块内的命令。")]),e._v(" "),n("p",[e._v("MULTI 标记一个事务块的开始。")]),e._v(" "),n("p",[e._v("UNWATCH 取消 WATCH 命令对所有 key 的监视。")]),e._v(" "),n("p",[e._v("WATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。")]),e._v(" "),n("h2",{attrs:{id:"redis-脚本"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-脚本"}},[e._v("#")]),e._v(" Redis 脚本")]),e._v(" "),n("p",[e._v("Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。")]),e._v(" "),n("p",[e._v("Eval 命令的基本语法如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis 127.0.0.1:6379> EVAL script numkeys key [key ...] arg [arg ...]\n")])])]),n("p",[e._v("以下实例演示了 redis 脚本工作过程：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> EVAL "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}" 2 key1 key2 first second\n\n1) "key1"\n2) "key2"\n3) "first"\n4) "second"\n')])])]),n("p",[n("strong",[e._v("Redis 脚本命令")])]),e._v(" "),n("p",[e._v("下表列出了 redis 脚本常用命令：")]),e._v(" "),n("p",[e._v("EVAL script numkeys key [key ...] arg [arg ...] 执行 Lua 脚本。")]),e._v(" "),n("p",[e._v("EVALSHA sha1 numkeys key [key ...] arg [arg ...] 执行 Lua 脚本。")]),e._v(" "),n("p",[e._v("SCRIPT EXISTS script [script ...] 查看指定的脚本是否已经被保存在缓存当中。")]),e._v(" "),n("p",[e._v("SCRIPT FLUSH 从脚本缓存中移除所有脚本。")]),e._v(" "),n("p",[e._v("SCRIPT KILL 杀死当前正在运行的 Lua 脚本。")]),e._v(" "),n("p",[e._v("SCRIPT LOAD script 将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。")]),e._v(" "),n("h2",{attrs:{id:"redis-连接"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-连接"}},[e._v("#")]),e._v(" Redis 连接")]),e._v(" "),n("p",[e._v("Redis 连接命令主要是用于连接 redis 服务。")]),e._v(" "),n("p",[e._v("以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> AUTH "password"\nOK\nredis 127.0.0.1:6379> PING\nPONG\n')])])]),n("p",[n("strong",[e._v("Redis 连接命令")])]),e._v(" "),n("p",[e._v("下表列出了 redis 连接的基本命令：")]),e._v(" "),n("p",[e._v("AUTH password 验证密码是否正确")]),e._v(" "),n("p",[e._v("ECHO message 打印字符串")]),e._v(" "),n("p",[e._v("PING 查看服务是否运行")]),e._v(" "),n("p",[e._v("QUIT 关闭当前连接")]),e._v(" "),n("p",[e._v("SELECT index 切换到指定的数据库")]),e._v(" "),n("h2",{attrs:{id:"redis-服务器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-服务器"}},[e._v("#")]),e._v(" Redis 服务器")]),e._v(" "),n("p",[e._v("Redis 服务器命令主要是用于管理 redis 服务。")]),e._v(" "),n("p",[e._v("以下实例演示了如何获取 redis 服务器的统计信息：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis 127.0.0.1:6379> INFO\n\n# Server\nredis_version:2.8.13\nredis_git_sha1:00000000\nredis_git_dirty:0\nredis_build_id:c2238b38b1edb0e2\nredis_mode:standalone\nos:Linux 3.5.0-48-generic x86_64\narch_bits:64\nmultiplexing_api:epoll\ngcc_version:4.7.2\nprocess_id:3856\nrun_id:0e61abd297771de3fe812a3c21027732ac9f41fe\ntcp_port:6379\nuptime_in_seconds:11554\nuptime_in_days:0\nhz:10\nlru_clock:16651447\nconfig_file:\n\n# Clients\nconnected_clients:1\nclient-longest_output_list:0\nclient-biggest_input_buf:0\nblocked_clients:0\n\n# Memory\nused_memory:589016\nused_memory_human:575.21K\nused_memory_rss:2461696\nused_memory_peak:667312\nused_memory_peak_human:651.67K\nused_memory_lua:33792\nmem_fragmentation_ratio:4.18\nmem_allocator:jemalloc-3.6.0\n\n# Persistence\nloading:0\nrdb_changes_since_last_save:3\nrdb_bgsave_in_progress:0\nrdb_last_save_time:1409158561\nrdb_last_bgsave_status:ok\nrdb_last_bgsave_time_sec:0\nrdb_current_bgsave_time_sec:-1\naof_enabled:0\naof_rewrite_in_progress:0\naof_rewrite_scheduled:0\naof_last_rewrite_time_sec:-1\naof_current_rewrite_time_sec:-1\naof_last_bgrewrite_status:ok\naof_last_write_status:ok\n\n# Stats\ntotal_connections_received:24\ntotal_commands_processed:294\ninstantaneous_ops_per_sec:0\nrejected_connections:0\nsync_full:0\nsync_partial_ok:0\nsync_partial_err:0\nexpired_keys:0\nevicted_keys:0\nkeyspace_hits:41\nkeyspace_misses:82\npubsub_channels:0\npubsub_patterns:0\nlatest_fork_usec:264\n\n# Replication\nrole:master\nconnected_slaves:0\nmaster_repl_offset:0\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n\n# CPU\nused_cpu_sys:10.49\nused_cpu_user:4.96\nused_cpu_sys_children:0.00\nused_cpu_user_children:0.01\n\n# Keyspace\ndb0:keys=94,expires=1,avg_ttl=41638810\ndb1:keys=1,expires=0,avg_ttl=0\ndb3:keys=1,expires=0,avg_ttl=0\n")])])]),n("p",[n("strong",[e._v("Redis 服务器命令")])]),e._v(" "),n("p",[e._v("下表列出了 redis 服务器的相关命令:")]),e._v(" "),n("p",[e._v("BGREWRITEAOF 异步执行一个 AOF（AppendOnly File） 文件重写操作")]),e._v(" "),n("p",[e._v("BGSAVE 在后台异步保存当前数据库的数据到磁盘")]),e._v(" "),n("p",[e._v("CLIENT KILL [ip:port] [ID client-id] 关闭客户端连接")]),e._v(" "),n("p",[e._v("CLIENT LIST 获取连接到服务器的客户端连接列表")]),e._v(" "),n("p",[e._v("CLIENT GETNAME 获取连接的名称")]),e._v(" "),n("p",[e._v("CLIENT PAUSE timeout 在指定时间内终止运行来自客户端的命令")]),e._v(" "),n("p",[e._v("CLIENT SETNAME connection-name 设置当前连接的名称")]),e._v(" "),n("p",[e._v("CLUSTER SLOTS 获取集群节点的映射数组")]),e._v(" "),n("p",[e._v("COMMAND 获取 Redis 命令详情数组")]),e._v(" "),n("p",[e._v("COMMAND COUNT 获取 Redis 命令总数")]),e._v(" "),n("p",[e._v("COMMAND GETKEYS 获取给定命令的所有键")]),e._v(" "),n("p",[e._v("TIME 返回当前服务器时间")]),e._v(" "),n("p",[e._v("COMMAND INFO command-name [command-name ...] 获取指定 Redis 命令描述的数组")]),e._v(" "),n("p",[e._v("CONFIG GET parameter 获取指定配置参数的值")]),e._v(" "),n("p",[e._v("CONFIG REWRITE 对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写")]),e._v(" "),n("p",[e._v("CONFIG SET parameter value 修改 redis 配置参数，无需重启")]),e._v(" "),n("p",[e._v("CONFIG RESETSTAT 重置 INFO 命令中的某些统计数据")]),e._v(" "),n("p",[e._v("DBSIZE 返回当前数据库的 key 的数量")]),e._v(" "),n("p",[e._v("DEBUG OBJECT key 获取 key 的调试信息")]),e._v(" "),n("p",[e._v("DEBUG SEGFAULT 让 Redis 服务崩溃")]),e._v(" "),n("p",[e._v("FLUSHALL 删除所有数据库的所有key")]),e._v(" "),n("p",[e._v("FLUSHDB 删除当前数据库的所有key")]),e._v(" "),n("p",[e._v("INFO [section] 获取 Redis 服务器的各种信息和统计数值")]),e._v(" "),n("p",[e._v("LASTSAVE 返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示")]),e._v(" "),n("p",[e._v("MONITOR 实时打印出 Redis 服务器接收到的命令，调试用")]),e._v(" "),n("p",[e._v("ROLE 返回主从实例所属的角色")]),e._v(" "),n("p",[e._v("SAVE 同步保存数据到硬盘")]),e._v(" "),n("p",[e._v("SHUTDOWN [NOSAVE] [SAVE] 异步保存数据到硬盘，并关闭服务器")]),e._v(" "),n("p",[e._v("SLAVEOF host port 将当前服务器转变为指定服务器的从属服务器(slave server)")]),e._v(" "),n("p",[e._v("SLOWLOG subcommand [argument] 管理 redis 的慢日志")]),e._v(" "),n("p",[e._v("SYNC 用于复制功能(replication)的内部命令")]),e._v(" "),n("h2",{attrs:{id:"redis-数据备份与恢复"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-数据备份与恢复"}},[e._v("#")]),e._v(" Redis 数据备份与恢复")]),e._v(" "),n("p",[e._v("Redis SAVE 命令用于创建当前数据库的备份。")]),e._v(" "),n("p",[e._v("redis Save 命令基本语法如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis 127.0.0.1:6379> SAVE \n\nredis 127.0.0.1:6379> SAVE \nOK\n")])])]),n("p",[e._v("该命令将在 redis 安装目录中创建dump.rdb文件。")]),e._v(" "),n("p",[n("strong",[e._v("恢复数据")])]),e._v(" "),n("p",[e._v("如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令，如下所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('redis 127.0.0.1:6379> CONFIG GET dir\n1) "dir"\n2) "/usr/local/redis/bin"\n')])])]),n("p",[e._v("以上命令 CONFIG GET dir 输出的 redis 安装目录为 /usr/local/redis/bin。")]),e._v(" "),n("p",[n("strong",[e._v("Bgsave")])]),e._v(" "),n("p",[e._v("创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("127.0.0.1:6379> BGSAVE\n\nBackground saving started\n")])])]),n("h2",{attrs:{id:"redis-安全"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-安全"}},[e._v("#")]),e._v(" Redis 安全")]),e._v(" "),n("p",[e._v("我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。")]),e._v(" "),n("p",[e._v("我们可以通过以下命令查看是否设置了密码验证：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('127.0.0.1:6379> CONFIG get requirepass\n1) "requirepass"\n2) ""\n')])])]),n("p",[e._v("默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。")]),e._v(" "),n("p",[e._v("你可以通过以下命令来修改该参数：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('127.0.0.1:6379> CONFIG set requirepass "runoob"\nOK\n127.0.0.1:6379> CONFIG get requirepass\n1) "requirepass"\n2) "runoob"\n')])])]),n("p",[e._v("设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。")]),e._v(" "),n("p",[e._v("AUTH 命令基本语法格式如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('127.0.0.1:6379> AUTH password\n127.0.0.1:6379> AUTH "runoob"\nOK\n127.0.0.1:6379> SET mykey "Test value"\nOK\n127.0.0.1:6379> GET mykey\n"Test value"\n')])])]),n("h2",{attrs:{id:"redis-性能测试"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-性能测试"}},[e._v("#")]),e._v(" Redis 性能测试")]),e._v(" "),n("p",[e._v("Redis 性能测试是通过同时执行多个命令实现的。")]),e._v(" "),n("p",[e._v("redis 性能测试的基本命令如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis-benchmark [option] [option value]\n")])])]),n("p",[e._v("注意：该命令是在 redis 的目录下执行的，而不是 redis 客户端的内部指令。")]),e._v(" "),n("p",[e._v("以下实例同时执行 10000 个请求来检测性能：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ redis-benchmark -n 10000  -q\n\nPING_INLINE: 141043.72 requests per second\nPING_BULK: 142857.14 requests per second\nSET: 141442.72 requests per second\nGET: 145348.83 requests per second\nINCR: 137362.64 requests per second\nLPUSH: 145348.83 requests per second\nLPOP: 146198.83 requests per second\nSADD: 146198.83 requests per second\nSPOP: 149253.73 requests per second\nLPUSH (needed to benchmark LRANGE): 148588.42 requests per second\nLRANGE_100 (first 100 elements): 58411.21 requests per second\nLRANGE_300 (first 300 elements): 21195.42 requests per second\nLRANGE_500 (first 450 elements): 14539.11 requests per second\nLRANGE_600 (first 600 elements): 10504.20 requests per second\nMSET (10 keys): 93283.58 requests per second\n")])])]),n("p",[e._v("redis 性能测试工具可选参数如下所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("序号\t选项\t描述\t默认值\n1\t-h\t指定服务器主机名\t127.0.0.1\n2\t-p\t指定服务器端口\t6379\n3\t-s\t指定服务器 socket\t\n4\t-c\t指定并发连接数\t50\n5\t-n\t指定请求数\t10000\n6\t-d\t以字节的形式指定 SET/GET 值的数据大小\t2\n7\t-k\t1=keep alive 0=reconnect\t1\n8\t-r\tSET/GET/INCR 使用随机 key, SADD 使用随机值\t\n9\t-P\t通过管道传输 <numreq> 请求\t1\n10\t-q\t强制退出 redis。仅显示 query/sec 值\t\n11\t--csv\t以 CSV 格式输出\t\n12\t-l\t生成循环，永久执行测试\t\n13\t-t\t仅运行以逗号分隔的测试命令列表。\t\n14\t-I\tIdle 模式。仅打开 N 个 idle 连接并等待。\t\n")])])]),n("p",[e._v("以下实例我们使用了多个参数来测试 redis 性能：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -q\n\nSET: 146198.83 requests per second\nLPUSH: 145560.41 requests per second\n")])])]),n("p",[e._v("以上实例中主机为 127.0.0.1，端口号为 6379，执行的命令为 set,lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。")]),e._v(" "),n("h2",{attrs:{id:"redis-客户端连接"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-客户端连接"}},[e._v("#")]),e._v(" Redis 客户端连接")]),e._v(" "),n("p",[e._v("Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：")]),e._v(" "),n("p",[e._v("首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。")]),e._v(" "),n("p",[e._v("然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法")]),e._v(" "),n("p",[e._v("然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送")]),e._v(" "),n("p",[n("strong",[e._v("最大连接数")])]),e._v(" "),n("p",[e._v("在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。")]),e._v(" "),n("p",[e._v("maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('config get maxclients\n\n1) "maxclients"\n2) "10000"\n')])])]),n("p",[e._v("以下实例我们在服务启动时设置最大连接数为 100000：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis-server --maxclients 100000\n客户端命令\nS.N.\t命令\t描述\n1\tCLIENT LIST\t返回连接到 redis 服务的客户端列表\n2\tCLIENT SETNAME\t设置当前连接的名称\n3\tCLIENT GETNAME\t获取通过 CLIENT SETNAME 命令设置的服务名称\n4\tCLIENT PAUSE\t挂起客户端连接，指定挂起的时间以毫秒计\n5\tCLIENT KILL\t关闭客户端连接\n")])])]),n("h2",{attrs:{id:"redis-管道技术"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-管道技术"}},[e._v("#")]),e._v(" Redis 管道技术")]),e._v(" "),n("p",[e._v("Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：")]),e._v(" "),n("p",[e._v("客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。")]),e._v(" "),n("p",[e._v("服务端处理命令，并将结果返回给客户端。")]),e._v(" "),n("p",[n("strong",[e._v("Redis 管道技术")])]),e._v(" "),n("p",[e._v("Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。")]),e._v(" "),n("p",[e._v("查看 redis 管道，只需要启动 redis 实例并输入以下命令：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('$(echo -en "PING\\r\\n SET runoobkey redis\\r\\nGET runoobkey\\r\\nINCR visitor\\r\\nINCR visitor\\r\\nINCR visitor\\r\\n"; sleep 10) | nc localhost 6379\n\n+PONG\n+OK\nredis\n:1\n:2\n:3\n')])])]),n("p",[e._v("以上实例中我们通过使用 PING 命令查看redis服务是否可用， 之后我们设置了 runoobkey 的值为 redis，然后我们获取 runoobkey 的值并使得 visitor 自增 3 次。")]),e._v(" "),n("p",[e._v("在返回的结果中我们可以看到这些命令一次性向 redis 服务提交，并最终一次性读取所有服务端的响应")]),e._v(" "),n("p",[n("strong",[e._v("管道技术的优势")])]),e._v(" "),n("p",[e._v("管道技术最显著的优势是提高了 redis 服务的性能。")]),e._v(" "),n("p",[e._v("一些测试数据\n在下面的测试中，我们将使用Redis的Ruby客户端，支持管道技术特性，测试管道技术对速度的提升效果。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('require \'rubygems\' \nrequire \'redis\'\ndef bench(descr) \nstart = Time.now \nyield \nputs "#{descr} #{Time.now-start} seconds" \nend\ndef without_pipelining \nr = Redis.new \n10000.times { \n    r.ping \n} \nend\ndef with_pipelining \nr = Redis.new \nr.pipelined { \n    10000.times { \n        r.ping \n    } \n} \nend\nbench("without pipelining") { \n    without_pipelining \n} \nbench("with pipelining") { \n    with_pipelining \n}\n')])])]),n("p",[e._v("从处于局域网中的Mac OS X系统上执行上面这个简单脚本的数据表明，开启了管道操作后，往返延时已经被改善得相当低了。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("without pipelining 1.185238 seconds \nwith pipelining 0.250783 seconds\n")])])]),n("p",[e._v("如你所见，开启管道后，我们的速度效率提升了5倍。")]),e._v(" "),n("h2",{attrs:{id:"redis-分区"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#redis-分区"}},[e._v("#")]),e._v(" Redis 分区")]),e._v(" "),n("p",[e._v("分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。")]),e._v(" "),n("p",[n("strong",[e._v("分区的优势")])]),e._v(" "),n("p",[e._v("通过利用多台计算机内存的和值，允许我们构造更大的数据库。")]),e._v(" "),n("p",[e._v("通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。")]),e._v(" "),n("p",[n("strong",[e._v("分区的不足")])]),e._v(" "),n("p",[e._v("redis的一些特性在分区方面表现的不是很好：")]),e._v(" "),n("p",[e._v("涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。")]),e._v(" "),n("p",[e._v("涉及多个key的redis事务不能使用。")]),e._v(" "),n("p",[e._v("当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。")]),e._v(" "),n("p",[e._v("增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。")]),e._v(" "),n("p",[n("strong",[e._v("分区类型")])]),e._v(" "),n("p",[e._v("Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。")]),e._v(" "),n("p",[n("strong",[e._v("范围分区")])]),e._v(" "),n("p",[e._v("最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。")]),e._v(" "),n("p",[e._v("比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。")]),e._v(" "),n("p",[e._v("这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对Redis来说并非是好的方法。")]),e._v(" "),n("p",[n("strong",[e._v("哈希分区")])]),e._v(" "),n("p",[e._v("另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：")]),e._v(" "),n("p",[e._v("用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。")]),e._v(" "),n("p",[e._v("对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。")]),e._v(" "),n("h2",{attrs:{id:"java-使用-redis"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java-使用-redis"}},[e._v("#")]),e._v(" Java 使用 Redis")]),e._v(" "),n("p",[n("strong",[e._v("安装")])]),e._v(" "),n("p",[e._v("开始在 Java 中使用 Redis 前， 我们需要确保已经安装了 redis 服务及 Java redis 驱动，且你的机器上能正常使用 Java。 Java的安装配置可以参考我们的 Java开发环境配置 接下来让我们安装 Java redis 驱动：")]),e._v(" "),n("p",[e._v("首先你需要下载驱动包 下载 jedis.jar，确保下载最新驱动包。\n在你的 classpath 中包含该驱动包。\n本站提供了 2.9.0 jar 版本下载： jedis-2.9.0.jar")]),e._v(" "),n("p",[n("strong",[e._v("连接到 redis 服务")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import redis.clients.jedis.Jedis;\n \npublic class RedisJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis("localhost");\n        System.out.println("连接成功");\n        //查看服务是否运行\n        System.out.println("服务正在运行: "+jedis.ping());\n    }\n}\n')])])]),n("p",[e._v("编译以上 Java 程序，确保驱动包的路径是正确的。")]),e._v(" "),n("p",[e._v("连接成功\n服务正在运行: PONG")]),e._v(" "),n("p",[n("strong",[e._v("Redis Java String(字符串) 实例")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import redis.clients.jedis.Jedis;\n \npublic class RedisStringJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis("localhost");\n        System.out.println("连接成功");\n        //设置 redis 字符串数据\n        jedis.set("runoobkey", "www.runoob.com");\n        // 获取存储的数据并输出\n        System.out.println("redis 存储的字符串为: "+ jedis.get("runoobkey"));\n    }\n}\n')])])]),n("p",[e._v("编译以上程序。")]),e._v(" "),n("p",[e._v("连接成功\nredis 存储的字符串为: www.runoob.com")]),e._v(" "),n("p",[n("strong",[e._v("Redis Java List(列表) 实例")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import java.util.List;\nimport redis.clients.jedis.Jedis;\n \npublic class RedisListJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis("localhost");\n        System.out.println("连接成功");\n        //存储数据到列表中\n        jedis.lpush("site-list", "Runoob");\n        jedis.lpush("site-list", "Google");\n        jedis.lpush("site-list", "Taobao");\n        // 获取存储的数据并输出\n        List<String> list = jedis.lrange("site-list", 0 ,2);\n        for(int i=0; i<list.size(); i++) {\n            System.out.println("列表项为: "+list.get(i));\n        }\n    }\n}\n')])])]),n("p",[e._v("编译以上程序。")]),e._v(" "),n("p",[e._v("连接成功\n列表项为: Taobao\n列表项为: Google\n列表项为: Runoob")]),e._v(" "),n("p",[n("strong",[e._v("Redis Java Keys 实例")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import java.util.Iterator;\nimport java.util.Set;\nimport redis.clients.jedis.Jedis;\n \npublic class RedisKeyJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis("localhost");\n        System.out.println("连接成功");\n \n        // 获取数据并输出\n        Set<String> keys = jedis.keys("*"); \n        Iterator<String> it=keys.iterator() ;   \n        while(it.hasNext()){   \n            String key = it.next();   \n            System.out.println(key);   \n        }\n    }\n}\n')])])]),n("p",[e._v("编译以上程序。")]),e._v(" "),n("p",[e._v("连接成功\nrunoobkey\nsite-list")]),e._v(" "),n("h2",{attrs:{id:"php-使用-redis"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#php-使用-redis"}},[e._v("#")]),e._v(" PHP 使用 Redis")]),e._v(" "),n("p",[n("strong",[e._v("安装")])]),e._v(" "),n("p",[e._v("开始在 PHP 中使用 Redis 前， 我们需要确保已经安装了 redis 服务及 PHP redis 驱动，且你的机器上能正常使用 PHP。 接下来让我们安装 PHP redis 驱动：下载地址为:https://github.com/phpredis/phpredis/releases。")]),e._v(" "),n("p",[n("strong",[e._v("PHP安装redis扩展")])]),e._v(" "),n("p",[e._v("以下操作需要在下载的 phpredis 目录中完成：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$ wget https://github.com/phpredis/phpredis/archive/3.1.4.tar.gz\n$ cd phpredis-3.1.4                      # 进入 phpredis 目录\n$ /usr/local/php/bin/phpize              # php安装后的路径\n$ ./configure --with-php-config=/usr/local/php/bin/php-config\n$ make && make install\n")])])]),n("p",[e._v("修改php.ini文件")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("vi /usr/local/php/lib/php.ini\n")])])]),n("p",[e._v("增加如下内容:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('extension_dir = "/usr/local/php/lib/php/extensions/no-debug-zts-20090626"\n\nextension=redis.so\n')])])]),n("p",[e._v("安装完成后重启php-fpm 或 apache。查看phpinfo信息，就能看到redis扩展。")]),e._v(" "),n("p",[n("strong",[e._v("PHP 使用 Redis")])]),e._v(" "),n("p",[e._v("连接到 redis 服务")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<?php\n    //连接本地的 Redis 服务\n   $redis = new Redis();\n   $redis->connect(\'127.0.0.1\', 6379);\n   echo "Connection to server successfully";\n         //查看服务是否运行\n   echo "Server is running: " . $redis->ping();\n?>\n')])])]),n("p",[e._v("执行脚本，输出结果为：")]),e._v(" "),n("p",[e._v("Connection to server sucessfully\nServer is running: PONG")]),e._v(" "),n("p",[n("strong",[e._v("Redis PHP String(字符串) 实例")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<?php\n   //连接本地的 Redis 服务\n   $redis = new Redis();\n   $redis->connect(\'127.0.0.1\', 6379);\n   echo "Connection to server successfully";\n   //设置 redis 字符串数据\n   $redis->set("tutorial-name", "Redis tutorial");\n   // 获取存储的数据并输出\n   echo "Stored string in redis:: " . $redis->get("tutorial-name");\n?>\n')])])]),n("p",[e._v("执行脚本，输出结果为：")]),e._v(" "),n("p",[e._v("Connection to server sucessfully\nStored string in redis:: Redis tutorial")]),e._v(" "),n("p",[n("strong",[e._v("Redis PHP List(列表) 实例")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<?php\n   //连接本地的 Redis 服务\n   $redis = new Redis();\n   $redis->connect(\'127.0.0.1\', 6379);\n   echo "Connection to server successfully";\n   //存储数据到列表中\n   $redis->lpush("tutorial-list", "Redis");\n   $redis->lpush("tutorial-list", "Mongodb");\n   $redis->lpush("tutorial-list", "Mysql");\n   // 获取存储的数据并输出\n   $arList = $redis->lrange("tutorial-list", 0 ,5);\n   echo "Stored string in redis";\n   print_r($arList);\n?>\n')])])]),n("p",[e._v("执行脚本，输出结果为：")]),e._v(" "),n("p",[e._v("Connection to server sucessfully\nStored string in redis\nMysql\nMongodb\nRedis")]),e._v(" "),n("p",[n("strong",[e._v("Redis PHP Keys 实例")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<?php\n   //连接本地的 Redis 服务\n   $redis = new Redis();\n   $redis->connect(\'127.0.0.1\', 6379);\n   echo "Connection to server successfully";\n   // 获取数据并输出\n   $arList = $redis->keys("*");\n   echo "Stored keys in redis:: ";\n   print_r($arList);\n?>\n')])])]),n("p",[e._v("执行脚本，输出结果为：")]),e._v(" "),n("p",[e._v("Connection to server sucessfully\nStored string in redis::\ntutorial-name\ntutorial-list")])],1)}),[],!1,null,null,null);s.default=a.exports}}]);