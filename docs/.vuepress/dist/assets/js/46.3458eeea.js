(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{298:function(n,e,a){"use strict";a.r(e);var t=a(17),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("TOC"),n._v(" "),a("h1",{attrs:{id:"typescript语法使用指南"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript语法使用指南"}},[n._v("#")]),n._v(" typescript语法使用指南")]),n._v(" "),a("h2",{attrs:{id:"typescript-教程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-教程"}},[n._v("#")]),n._v(" TypeScript 教程")]),n._v(" "),a("p",[n._v("TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。")]),n._v(" "),a("p",[n._v("TypeScript 由微软开发的自由和开源的编程语言。")]),n._v(" "),a("p",[n._v("TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。")]),n._v(" "),a("p",[a("strong",[n._v("语言特性")])]),n._v(" "),a("p",[n._v("TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括：")]),n._v(" "),a("p",[n._v("类型批注和编译时类型检查\n类型推断\n类型擦除\n接口\n枚举\nMixin\n泛型编程\n名字空间\n元组\nAwait\n以下功能是从 ECMA 2015 反向移植而来：")]),n._v(" "),a("p",[n._v("类\n模块\nlambda 函数的箭头语法\n可选参数以及默认参数")]),n._v(" "),a("p",[a("strong",[n._v("JavaScript 与 TypeScript 的区别")])]),n._v(" "),a("p",[n._v("TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。")]),n._v(" "),a("p",[n._v("TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。")]),n._v(" "),a("p",[a("strong",[n._v("第一个 TypeScript 实例")])]),n._v(" "),a("p",[n._v("以下实例我们使用 TypeScript 来输出 Hello World!:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('const hello : string = "Hello World!"\nconsole.log(hello)\n')])])]),a("h2",{attrs:{id:"typescript-安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-安装"}},[n._v("#")]),n._v(" TypeScript 安装")]),n._v(" "),a("p",[n._v("本文介绍 TypeScript 环境的安装。")]),n._v(" "),a("p",[n._v("我们需要使用到 npm 工具安装，如果你还不了解 npm，可以参考我们的NPM 使用介绍。")]),n._v(" "),a("p",[a("strong",[n._v("NPM 安装 TypeScript")])]),n._v(" "),a("p",[n._v("如果你的本地环境已经安装了 npm 工具，可以使用以下命令来安装：\n"),a("code",[n._v("npm install -g typescript")]),n._v("\n安装完成后我们可以使用 tsc 命令来执行 TypeScript 的相关代码，以下是查看版本号：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("$ tsc -v\nVersion 3.2.2\n")])])]),a("p",[n._v("然后我们新建一个 test.ts 的文件，代码如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var message:string = "Hello World" \nconsole.log(message)\n')])])]),a("p",[n._v("通常我们使用 .ts 作为 TypeScript 代码文件的扩展名。")]),n._v(" "),a("p",[n._v("然后执行以下命令将 TypeScript 转换为 JavaScript 代码：")]),n._v(" "),a("p",[n._v("tsc test.ts\n这时候再当前目录下（与 test.ts 同一目录）就会生成一个 test.js 文件，代码如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var message = "Hello World";\nconsole.log(message);\n')])])]),a("p",[n._v("使用 node 命令来执行 test.js 文件：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("$ node test.js \nHello World\n")])])]),a("p",[a("strong",[n._v("TypeScript 基础语法")])]),n._v(" "),a("p",[n._v("TypeScript 程序由以下几个部分组成：")]),n._v(" "),a("p",[n._v("模块\n函数\n变量\n语句和表达式\n注释")]),n._v(" "),a("p",[a("strong",[n._v("第一个 TypeScript 程序")])]),n._v(" "),a("p",[n._v('我们可以使用以下 TypeScript 程序来输出 "Hello World" ：')]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('const hello : string = "Hello World!"\nconsole.log(hello)\n')])])]),a("p",[n._v('以上代码首先通过 tsc 命令编译：\ntsc Test.ts\n得到如下 js 代码：\nvar hello = "Hello World!";\nconsole.log(hello);\n最后我们使用 node 命令来执行该 js 代码。\n$ node Test.js\nHello World\n我们可以同时编译多个 ts 文件：\ntsc file1.ts file2.ts file3.ts')]),n._v(" "),a("p",[n._v("tsc 常用编译参数如下表所示：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("--help\n显示帮助信息\n\n--module\n载入扩展模块\n\n--target\n设置 ECMA 版本\n\n--declaration\n额外生成一个 .d.ts 扩展名的文件。\n\ntsc ts-hw.ts --declaration\n以上命令会生成 ts-hw.d.ts、ts-hw.js 两个文件。\n\n--removeComments\n删除文件的注释\n\n--out\n编译多个文件并合并到一个输出的文件\n\n--sourcemap\n生成一个 sourcemap (.map) 文件。\n\nsourcemap 是一个存储源代码与编译代码对应位置映射的信息文件。\n\n--module noImplicitAny\n在表达式和声明上有隐含的 any 类型时报错\n\n--watch\n在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。\n")])])]),a("p",[a("strong",[n._v("TypeScript 保留关键字")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("break\tas\tcatch\tswitch\ncase\tif\tthrow\telse\nvar\tnumber\tstring\tget\nmodule\ttype\tinstanceof\ttypeof\npublic\tprivate\tenum\texport\nfinally\tfor\twhile\tvoid\nnull\tsuper\tthis\tnew\nin\treturn\ttrue\tfalse\nany\textends\tstatic\tlet\npackage\timplements\tinterface\tfunction\nnew\ttry\tyield\tconst\ncontinue\tdo\t \t \n")])])]),a("p",[a("strong",[n._v("空白和换行")])]),n._v(" "),a("p",[n._v("TypeScript 会忽略程序中出现的空格、制表符和换行符。")]),n._v(" "),a("p",[n._v("空格、制表符通常用来缩进代码，使代码易于阅读和理解。")]),n._v(" "),a("p",[a("strong",[n._v("TypeScript 区分大小写")])]),n._v(" "),a("p",[n._v("TypeScript 区分大写和小写字符。")]),n._v(" "),a("p",[a("strong",[n._v("分号是可选的")])]),n._v(" "),a("p",[n._v("每行指令都是一段语句，你可以使用分号或不使用， 分号在 TypeScript 中是可选的，建议使用。")]),n._v(" "),a("p",[n._v("以下代码都是合法的：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('console.log("Runoob")\nconsole.log("Google");\n如果语句写在同一行则一定需要使用分号来分隔，否则会报错，如：\n\nconsole.log("Runoob");console.log("Google");\n')])])]),a("p",[a("strong",[n._v("TypeScript 注释")])]),n._v(" "),a("p",[n._v("注释是一个良好的习惯，虽然很多程序员讨厌注释，但还是建议你在每段代码写上文字说明。")]),n._v(" "),a("p",[n._v("注释可以提高程序的可读性。")]),n._v(" "),a("p",[n._v("注释可以包含有关程序一些信息，如代码的作者，有关函数的说明等。")]),n._v(" "),a("p",[n._v("编译器会忽略注释。")]),n._v(" "),a("p",[n._v("TypeScript 支持两种类型的注释\n单行注释 ( // ) − 在 // 后面的文字都是注释内容。")]),n._v(" "),a("p",[n._v("多行注释 (/* */) − 这种注释可以跨越多行。")]),n._v(" "),a("p",[n._v("注释实例：")]),n._v(" "),a("p",[n._v("// 这是一个单行注释")]),n._v(" "),a("p",[n._v("/*\n这是一个多行注释\n这是一个多行注释\n这是一个多行注释\n*/")]),n._v(" "),a("p",[a("strong",[n._v("TypeScript 与面向对象")])]),n._v(" "),a("p",[n._v("面向对象是一种对现实世界理解和抽象的方法。")]),n._v(" "),a("p",[n._v("TypeScript 是一种面向对象的编程语言。")]),n._v(" "),a("p",[n._v("面向对象主要有两个概念：对象和类。")]),n._v(" "),a("p",[n._v("对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n类：类是一个模板，它描述一类对象的行为和状态。\n方法：方法是类的操作的实现步骤。\n下图中 girl、boy 为类，而具体的每个人为该类的对象：")]),n._v(" "),a("p",[n._v("TypeScript 面向对象编程实例：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('class Site { \n   name():void { \n      console.log("Runoob") \n   } \n} \nvar obj = new Site(); \nobj.name();\n以上实例定义了一个类 Site，该类有一个方法 name()，该方法在终端上输出字符串 Runoob。\n\nnew 关键字创建类的对象，该对象调用方法 name()。\n\n编译后生成的 JavaScript 代码如下：\n\nvar Site = /** @class */ (function () {\n    function Site() {\n    }\n    Site.prototype.name = function () {\n        console.log("Runoob");\n    };\n    return Site;\n}());\nvar obj = new Site();\nobj.name();\n执行以上 JavaScript 代码，输出结果如下:\n\nRunoob\n')])])]),a("h2",{attrs:{id:"typescript-基础类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-基础类型"}},[n._v("#")]),n._v(" TypeScript 基础类型")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("TypeScript 包含的数据类型如下表:\n数据类型\t关键字\t描述\n任意类型\tany\t声明为 any 的变量可以赋予任意类型的值。\n数字类型\tnumber\t\n")])])]),a("p",[a("strong",[n._v("双精度 64 位浮点值")])]),n._v(" "),a("p",[n._v("它可以用来表示整数和分数。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let binaryLiteral: number = 0b1010; // 二进制\nlet octalLiteral: number = 0o744;    // 八进制\nlet decLiteral: number = 6;    // 十进制\nlet hexLiteral: number = 0xf00d;    // 十六进制\n")])])]),a("p",[a("strong",[n._v("字符串类型\tstring")])]),n._v(" "),a("p",[n._v("一个字符系列，使用单引号（'）或双引号（\"）来表示字符串类型。反引号（`）来定义多行文本和内嵌表达式。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('let name: string = "Runoob";\nlet years: number = 5;\nlet words: string = `您好，今年是 ${ name } 发布 ${ years + 1} 周年`;\n')])])]),a("p",[a("strong",[n._v("布尔类型\tboolean")])]),n._v(" "),a("p",[n._v("表示逻辑值：true 和 false。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let flag: boolean = true;\n")])])]),a("p",[a("strong",[n._v("数组类型\t无")])]),n._v(" "),a("p",[n._v("声明变量为数组。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 在元素类型后面加上[]\nlet arr: number[] = [1, 2];\n\n// 或者使用数组泛型\nlet arr: Array<number> = [1, 2];\n")])])]),a("p",[a("strong",[n._v("元组\t无")])]),n._v(" "),a("p",[n._v("元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let x: [string, number];\nx = ['Runoob', 1];    // 运行正常\nx = [1, 'Runoob'];    // 报错\nconsole.log(x[0]);    // 输出 Runoob\n")])])]),a("p",[a("strong",[n._v("枚举\tenum")])]),n._v(" "),a("p",[n._v("枚举类型用于定义数值集合。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("enum Color {Red, Green, Blue};\nlet c: Color = Color.Blue;\nconsole.log(c);    // 输出 2\n")])])]),a("p",[a("strong",[n._v("void\tvoid")])]),n._v(" "),a("p",[n._v("用于标识方法返回值的类型，表示该方法没有返回值。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('function hello(): void {\n    alert("Hello Runoob");\n}\n')])])]),a("p",[a("strong",[n._v("null\tnull")])]),n._v(" "),a("p",[n._v("表示对象值缺失。")]),n._v(" "),a("p",[a("strong",[n._v("undefined\tundefined")])]),n._v(" "),a("p",[n._v("用于初始化变量为一个未定义的值")]),n._v(" "),a("p",[a("strong",[n._v("never\tnever")])]),n._v(" "),a("p",[n._v("never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。")]),n._v(" "),a("p",[n._v("注意：TypeScript 和 JavaScript 没有整数类型。")]),n._v(" "),a("p",[a("strong",[n._v("Any 类型")])]),n._v(" "),a("p",[n._v("任意值是 TypeScript 针对编程时类型不明确的变量使用的一种数据类型，它常用于以下三种情况。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("<p>1、变量的值会动态改变时，比如来自用户的输入，任意值类型可以让这些变量跳过编译阶段的类型检查，示例代码如下：</p>\nlet x: any = 1;    // 数字类型\nx = 'I am who I am';    // 字符串类型\nx = false;    // 布尔类型\n改写现有代码时，任意值允许在编译时可选择地包含或移除类型检查，示例代码如下：\n\nlet x: any = 4;\nx.ifItExists();    // 正确，ifItExists方法在运行时可能存在，但这里并不会检查\nx.toFixed();    // 正确\n定义存储各种类型数据的数组时，示例代码如下：\n\nlet arrayList: any[] = [1, false, 'fine'];\narrayList[1] = 100;\n")])])]),a("p",[a("strong",[n._v("Null 和 Undefined")])]),n._v(" "),a("p",[n._v('null\n在 JavaScript 中 null 表示 "什么都没有"。')]),n._v(" "),a("p",[n._v("null是一个只有一个值的特殊类型。表示一个空对象引用。")]),n._v(" "),a("p",[n._v("用 typeof 检测 null 返回是 object。")]),n._v(" "),a("p",[n._v("undefined\n在 JavaScript 中, undefined 是一个没有设置值的变量。")]),n._v(" "),a("p",[n._v("typeof 一个没有值的变量会返回 undefined。")]),n._v(" "),a("p",[n._v("Null 和 Undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。而在TypeScript中启用严格的空校验（--strictNullChecks）特性，就可以使得null 和 undefined 只能被赋值给 void 或本身对应的类型，示例代码如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 启用 --strictNullChecks\nlet x: number;\nx = 1; // 运行正确\nx = undefined;    // 运行错误\nx = null;    // 运行错误\n上面的例子中变量 x 只能是数字类型。如果一个类型可能出现 null 或 undefined， 可以用 | 来支持多种类型，示例代码如下：\n\n// 启用 --strictNullChecks\nlet x: number | null | undefined;\nx = 1; // 运行正确\nx = undefined;    // 运行正确\nx = null;    // 运行正确\n更多内容可以查看：JavaScript typeof, null, 和 undefined\n")])])]),a("p",[a("strong",[n._v("never 类型")])]),n._v(" "),a("p",[n._v("never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。这意味着声明为 never 类型的变量只能被 never 类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环），示例代码如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let x: never;\nlet y: number;\n\n// 运行错误，数字类型不能转为 never 类型\nx = 123;\n\n// 运行正确，never 类型可以赋值给 never类型\nx = (()=>{ throw new Error('exception')})();\n\n// 运行正确，never 类型可以赋值给 数字类型\ny = (()=>{ throw new Error('exception')})();\n\n// 返回值为 never 的函数可以是抛出异常的情况\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// 返回值为 never 的函数可以是无法被执行到的终止点的情况\nfunction loop(): never {\n    while (true) {}\n}\n")])])]),a("h2",{attrs:{id:"typescript-变量声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-变量声明"}},[n._v("#")]),n._v(" TypeScript 变量声明")]),n._v(" "),a("p",[n._v("变量是一种使用方便的占位符，用于引用计算机内存地址。\n我们可以把变量看做存储数据的容器。")]),n._v(" "),a("p",[a("strong",[n._v("TypeScript 变量的命名规则：")])]),n._v(" "),a("p",[n._v("变量名称可以包含数字和字母。\n除了下划线 _ 和美元 $ 符号外，不能包含其他特殊字符，包括空格。\n变量名不能以数字开头。\n变量使用前必须先声明，我们可以使用 var 来声明变量。")]),n._v(" "),a("p",[n._v("我们可以使用以下四种方式来声明变量：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('声明变量的类型及初始值：\nvar [变量名] : [类型] = 值;\n例如：\nvar uname:string = "Runoob";\n声明变量的类型，但没有初始值，变量值会设置为 undefined：\nvar [变量名] : [类型];\n例如：\nvar uname:string;\n声明变量并初始值，但不设置类型，该变量可以是任意类型：\nvar [变量名] = 值;\n例如：\nvar uname = "Runoob";\n声明变量没有设置类型和初始值，类型可以是任意类型，默认初始值为 undefined：\nvar [变量名];\n例如：\nvar uname;\nvar uname:string = "Runoob";\nvar score1:number = 50;\nvar score2:number = 42.50\nvar sum = score1 + score2\nconsole.log("名字: "+uname)\nconsole.log("第一个科目成绩: "+score1)\nconsole.log("第二个科目成绩: "+score2)\nconsole.log("总成绩: "+sum)\n')])])]),a("blockquote",[a("p",[n._v("注意：变量不要使用 name 否则会与 DOM 中的全局 window 对象下的 name 属性出现了重名。")])]),n._v(" "),a("p",[n._v("使用 tsc 命令编译以上代码，得到如下 JavaScript 代码：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var uname = "Runoob";\nvar score1 = 50;\nvar score2 = 42.50;\nvar sum = score1 + score2;\nconsole.log("名字: " + uname);\nconsole.log("第一个科目成绩: " + score1);\nconsole.log("第二个科目成绩: " + score2);\nconsole.log("总成绩: " + sum);\n执行该 JavaScript 代码输出结果为：\n\n名字: Runoob\n第一个科目成绩: 50\n第二个科目成绩: 42.5\n总成绩: 92.5\n')])])]),a("p",[n._v("TypeScript 遵循强类型，如果将不同的类型赋值给变量会编译错误，如下实例：")]),n._v(" "),a("p",[n._v('var num:number = "hello"     // 这个代码会编译错误')]),n._v(" "),a("p",[a("strong",[n._v("类型断言（Type Assertion）")])]),n._v(" "),a("p",[n._v("类型断言可以用来手动指定一个值的类型，即允许变量从一种类型更改为另一种类型。")]),n._v(" "),a("p",[n._v("语法格式：")]),n._v(" "),a("p",[n._v("<类型>值\n或:")]),n._v(" "),a("p",[n._v("值 as 类型")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var str = '1' \nvar str2:number = <number> <any> str   //str、str2 是 string 类型\nconsole.log(str2)\n")])])]),a("p",[a("strong",[n._v("TypeScript 是怎么确定单个断言是否足够")])]),n._v(" "),a("p",[n._v("当 S 类型是 T 类型的子集，或者 T 类型是 S 类型的子集时，S 能被成功断言成 S。这是为了在进行类型断言时提供额外的安全性，完全毫无根据的断言是危险的，如果你想这么做，你可以使用 any。\n它之所以不被称为类型转换，是因为转换通常意味着某种运行时的支持。但是，类型断言纯粹是一个编译时语法，同时，它也是一种为编译器提供关于如何分析代码的方法。\n编译后，以上代码会生成如下 JavaScript 代码：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var str = '1';\nvar str2 = str;  //str、str2 是 string 类型\nconsole.log(str2);\n执行输出结果为：\n\n1\n")])])]),a("p",[a("strong",[n._v("类型推断")])]),n._v(" "),a("p",[n._v("当类型没有给出时，TypeScript 编译器利用类型推断来推断类型。\n如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态 any 类型。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var num = 2;    // 类型推断为 number\nconsole.log("num 变量的值为 "+num); \nnum = "12";    // 编译错误\nconsole.log(num);\n')])])]),a("p",[n._v("第一行代码声明了变量 num 并=设置初始值为 2。 注意变量声明没有指定类型。因此，程序使用类型推断来确定变量的数据类型，第一次赋值为 2，num 设置为 number 类型。\n第三行代码，当我们再次为变量设置字符串类型的值时，这时编译会错误。因为变量已经设置为了 number 类型。\nerror TS2322: Type '\"12\"' is not assignable to type 'number'.")]),n._v(" "),a("p",[a("strong",[n._v("变量作用域")])]),n._v(" "),a("p",[n._v("变量作用域指定了变量定义的位置。")]),n._v(" "),a("p",[n._v("程序中变量的可用性由变量作用域决定。")]),n._v(" "),a("p",[n._v("TypeScript 有以下几种作用域：")]),n._v(" "),a("p",[n._v("全局作用域 − 全局变量定义在程序结构的外部，它可以在你代码的任何位置使用。")]),n._v(" "),a("p",[n._v("类作用域 − 这个变量也可以称为 字段。类变量声明在一个类里头，但在类的方法外面。 该变量可以通过类的对象来访问。类变量也可以是静态的，静态的变量可以通过类名直接访问。")]),n._v(" "),a("p",[n._v("局部作用域 − 局部变量，局部变量只能在声明它的一个代码块（如：方法）中使用。")]),n._v(" "),a("p",[n._v("以下实例说明了三种作用域的使用：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var global_num = 12          // 全局变量\nclass Numbers { \n   num_val = 13;             // 实例变量\n   static sval = 10;         // 静态变量\n   \n   storeNum():void { \n      var local_num = 14;    // 局部变量\n   } \n} \nconsole.log("全局变量为: "+global_num)  \nconsole.log(Numbers.sval)   // 静态变量\nvar obj = new Numbers(); \nconsole.log("实例变量: "+obj.num_val)\n以上代码使用 tsc 命令编译为 JavaScript 代码为：\n\nvar global_num = 12; // 全局变量\nvar Numbers = /** @class */ (function () {\n    function Numbers() {\n        this.num_val = 13; // 实例变量\n    }\n    Numbers.prototype.storeNum = function () {\n        var local_num = 14; // 局部变量\n    };\n    Numbers.sval = 10; // 静态变量\n    return Numbers;\n}());\nconsole.log("全局变量为: " + global_num);\nconsole.log(Numbers.sval); // 静态变量\nvar obj = new Numbers();\nconsole.log("实例变量: " + obj.num_val);\n执行以上 JavaScript 代码，输出结果为：\n\n全局变量为: 12\n10\n实例变量: 13\n')])])]),a("p",[n._v("如果我们在方法外部调用局部变量 local_num，会报错：")]),n._v(" "),a("p",[n._v("error TS2322: Could not find symbol 'local_num'.")]),n._v(" "),a("h2",{attrs:{id:"typescript-运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-运算符"}},[n._v("#")]),n._v(" TypeScript 运算符")]),n._v(" "),a("p",[n._v("运算符用于执行程序代码运算，会针对一个以上操作数项目来进行运算。")]),n._v(" "),a("p",[n._v("TypeScript 主要包含以下几种运算：")]),n._v(" "),a("p",[n._v("算术运算符\n逻辑运算符\n关系运算符\n按位运算符\n赋值运算符\n三元/条件运算符\n字符串运算符\n类型运算符\n算术运算符")]),n._v(" "),a("h2",{attrs:{id:"typescript-条件语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-条件语句"}},[n._v("#")]),n._v(" TypeScript 条件语句")]),n._v(" "),a("p",[n._v("条件语句用于基于不同的条件来执行不同的动作。")]),n._v(" "),a("p",[n._v("TypeScript 条件语句是通过一条或多条语句的执行结果（True 或 False）来决定执行的代码块。")]),n._v(" "),a("p",[a("strong",[n._v("条件语句")])]),n._v(" "),a("p",[n._v("通常在写代码时，您总是需要为不同的决定来执行不同的动作。您可以在代码中使用条件语句来完成该任务。")]),n._v(" "),a("p",[n._v("在 TypeScript 中，我们可使用以下条件语句：")]),n._v(" "),a("p",[n._v("if 语句 - 只有当指定条件为 true 时，使用该语句来执行代码\nif...else 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码\nif...else if....else 语句- 使用该语句来选择多个代码块之一来执行\nswitch 语句 - 使用该语句来选择多个代码块之一来执行")]),n._v(" "),a("h2",{attrs:{id:"typescript-循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-循环"}},[n._v("#")]),n._v(" TypeScript 循环")]),n._v(" "),a("p",[n._v("有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。\n编程语言提供了更为复杂执行路径的多种控制结构。")]),n._v(" "),a("p",[a("strong",[n._v("for 循环")])]),n._v(" "),a("p",[n._v("TypeScript for 循环用于多次执行一个语句序列，简化管理循环变量的代码。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("for ( init; condition; increment ){\n    statement(s);\n}\n")])])]),a("p",[n._v("下面是 for 循环的控制流程解析：\ninit 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。\n接下来，会判断 condition。如果为 true，则执行循环主体。如果为 false，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。\n在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。\n条件再次被判断。如果为 true，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为 false 时，for 循环终止。\n在这里，statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。")]),n._v(" "),a("p",[n._v("condition 可以是任意的表达式，当条件为 true 时执行循环，当条件为 false 时，退出循环。")]),n._v(" "),a("p",[n._v("以下实例计算 5 的阶乘， for 循环生成从 5 到 1 的数字，并计算每次循环数字的乘积。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("TypeScript\nvar num:number = 5; \nvar i:number; \nvar factorial = 1; \n \nfor(i = num;i>=1;i--) {\n   factorial *= i;\n}\nconsole.log(factorial)\n编译以上代码得到如下 JavaScript 代码：\n\nJavaScript\nvar i;\nvar factorial = 1;\nfor (i = num; i >= 1; i--) {\n    factorial *= i;\n}\nconsole.log(factorial);\n执行以上 JavaScript 代码，输出结果为：\n\n120\n")])])]),a("p",[a("strong",[n._v("for...in 循环")])]),n._v(" "),a("p",[n._v("for...in 语句用于一组值的集合或列表进行迭代输出。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('for (var val in list) { \n    //语句 \n}\nval 需要为 string 或 any 类型。\nTypeScript\nvar j:any; \nvar n:any = "a b c" \n \nfor(j in n) {\n    console.log(n[j])  \n}\n编译以上代码得到如下 JavaScript 代码：\n\nJavaScript\nvar num = 5;\nvar j;\nvar n = "a b c";\nfor (j in n) {\n    console.log(n[j]);\n}\n执行以上 JavaScript 代码，输出结果为：\na\nb\nc\n')])])]),a("p",[a("strong",[n._v("for…of 、forEach、every 和 some 循环")])]),n._v(" "),a("p",[n._v("此外，TypeScript 还支持 for…of 、forEach、every 和 some 循环。\nfor...of 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 for...of 循环，以替代 for...in 和 forEach() ，并支持新的迭代协议。for...of 允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript for...of 循环\nlet someArray = [1, "string", false];\n \nfor (let entry of someArray) {\n    console.log(entry); // 1, "string", false\n}\n')])])]),a("p",[n._v("forEach、every 和 some 是 JavaScript 的循环语法，TypeScript 作为 JavaScript 的语法超集，当然默认也是支持的。")]),n._v(" "),a("p",[n._v("因为 forEach 在 iteration 中是无法返回的，所以可以使用 every 和 some 来取代 forEach。")]),n._v(" "),a("p",[a("strong",[n._v("TypeScript forEach 循环")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let list = [4, 5, 6];\nlist.forEach((val, idx, array) => {\n    // val: 当前值\n    // idx：当前index\n    // array: Array\n});\nTypeScript every 循环\nlet list = [4, 5, 6];\nlist.every((val, idx, array) => {\n    // val: 当前值\n    // idx：当前index\n    // array: Array\n    return true; // Continues\n    // Return false will quit the iteration\n});\n")])])]),a("p",[a("strong",[n._v("while 循环")])]),n._v(" "),a("p",[n._v("while 语句在给定条件为 true 时，重复执行语句或语句组。循环主体执行之前会先测试条件。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("while(condition)\n{\n   statement(s);\n}\n")])])]),a("p",[n._v("在这里，statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。\ncondition 可以是任意的表达式，当条件为 true 时执行循环。 当条件为 false 时，程序流将退出循环。\n图表中，while 循环的关键点是循环可能一次都不会执行。当条件为 false 时，会跳过循环主体，直接执行紧接着 while 循环的下一条语句。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nvar num:number = 5; \nvar factorial:number = 1; \n \nwhile(num >=1) { \n    factorial = factorial * num; \n    num--; \n} \nconsole.log("5 的阶乘为："+factorial);\n编译以上代码得到如下 JavaScript 代码：\n\nJavaScript\nvar num = 5;\nvar factorial = 1;\nwhile (num >= 1) {\n    factorial = factorial * num;\n    num--;\n}\nconsole.log("5 的阶乘为：" + factorial);\n执行以上 JavaScript 代码，输出结果为：\n\n5 的阶乘为：120\n')])])]),a("p",[a("strong",[n._v("do...while 循环")])]),n._v(" "),a("p",[n._v("不像 for 和 while 循环，它们是在循环头部测试循环条件。do...while 循环是在循环的尾部检查它的条件。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("do\n{\n   statement(s);\n}while( condition );\n")])])]),a("p",[n._v("请注意，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。\n如果条件为 true，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为 false 为止。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("TypeScript\nvar n:number = 10;\ndo { \n    console.log(n); \n    n--; \n} while(n>=0);\n编译以上代码得到如下 JavaScript 代码：\n\nJavaScript\nvar num = 5;\nvar n = 10;\ndo {\n    console.log(n);\n    n--;\n} while (n >= 0);\n执行以上 JavaScript 代码，输出结果为：\n")])])]),a("p",[a("strong",[n._v("break 语句")])]),n._v(" "),a("p",[n._v("break 语句有以下两种用法：")]),n._v(" "),a("p",[n._v("当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。\n它可用于终止 switch 语句中的一个 case。\n如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nvar i:number = 1 \nwhile(i<=10) { \n    if (i % 5 == 0) {   \n        console.log ("在 1~10 之间第一个被 5 整除的数为 : "+i) \n        break     // 找到一个后退出循环\n    } \n    i++ \n}  // 输出 5 然后程序执行结束\n编译以上代码得到如下 JavaScript 代码：\n\nJavaScript\nvar i = 1;\nwhile (i <= 10) {\n    if (i % 5 == 0) {\n        console.log("在 1~10 之间第一个被 5 整除的数为 : " + i);\n        break; // 找到一个后退出循环\n    }\n    i++;\n} // 输出 5 然后程序执行结束\n执行以上 JavaScript 代码，输出结果为：\n\n在 1~10 之间第一个被 5 整除的数为 : 5\n')])])]),a("p",[a("strong",[n._v("continue 语句")])]),n._v(" "),a("p",[n._v("continue 语句有点像 break 语句。但它不是强制终止，continue 会跳过当前循环中的代码，强迫开始下一次循环。")]),n._v(" "),a("p",[n._v("对于 for 循环，continue 语句执行后自增语句仍然会执行。对于 while 和 do...while 循环，continue 语句\b重新执行条件判断语句。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nvar num:number = 0\nvar count:number = 0;\n \nfor(num=0;num<=20;num++) {\n    if (num % 2==0) {\n        continue\n    }\n    count++\n}\nconsole.log ("0 ~20 之间的奇数个数为: "+count)    //输出10个偶数\n编译以上代码得到如下 JavaScript 代码：\n\nJavaScript\nvar num = 0;\nvar count = 0;\nfor (num = 0; num <= 20; num++) {\n    if (num % 2 == 0) {\n        continue;\n    }\n    count++;\n}\nconsole.log("0 ~20 之间的奇数个数为: " + count); //输出 10\n执行以上 JavaScript 代码，输出结果为：\n\n0 ~20 之间的奇数个数为: 10\n')])])]),a("p",[a("strong",[n._v("无限循环")])]),n._v(" "),a("p",[n._v("无限循环就是一直在运行不会停止的循环。 for 和 while 循环都可以创建无限循环。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('for(;;) { \n   // 语句\n}\n\nfor(;;) { \n   console.log("这段代码会不停的执行") \n}\nwhile 创建无限循环语法格式：\n\nwhile(true) { \n   // 语句\n} \n\nwhile(true) { \n   console.log("这段代码会不停的执行") \n}\n')])])]),a("h2",{attrs:{id:"typescript-函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-函数"}},[n._v("#")]),n._v(" TypeScript 函数")]),n._v(" "),a("p",[n._v("函数是一组一起执行一个任务的语句。")]),n._v(" "),a("p",[n._v("您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。")]),n._v(" "),a("p",[n._v("函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。")]),n._v(" "),a("p",[a("strong",[n._v("函数定义")])]),n._v(" "),a("p",[n._v("函数就是包裹在花括号中的代码块，前面使用了关键词 function：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('function function_name() {   \n    // 函数定义\n    console.log("调用函数") \n}\n')])])]),a("p",[a("strong",[n._v("调用函数")])]),n._v(" "),a("p",[n._v("函数只有通过调用才可以执行函数内的代码。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('function test() {   // 函数定义\n    console.log("调用函数") \n} \ntest()              // 调用函数\n')])])]),a("p",[a("strong",[n._v("函数返回值")])]),n._v(" "),a("p",[n._v("有时，我们会希望函数将执行的结果返回到调用它的地方。")]),n._v(" "),a("p",[n._v("通过使用 return 语句就可以实现。")]),n._v(" "),a("p",[n._v("在使用 return 语句时，函数会停止执行，并返回指定的值。")]),n._v(" "),a("p",[n._v("语法格式如下所示：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function function_name():return_type { \n    // 语句\n    return value; \n}\n")])])]),a("p",[n._v("return_type 是返回值的类型。")]),n._v(" "),a("p",[n._v("return 关键词后跟着要返回的结果。")]),n._v(" "),a("p",[n._v("一个函数只能有一个 return 语句。")]),n._v(" "),a("p",[n._v("返回值的类型需要与函数定义的返回类型(return_type)一致。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 函数定义\nfunction greet():string { // 返回一个字符串\n    return "Hello World" \n} \n \nfunction caller() { \n    var msg = greet() // 调用 greet() 函数 \n    console.log(msg) \n} \n \n// 调用函数\ncaller()\n实例中定义了函数 greet()，返回值的类型为 string。\n\ngreet() 函数通过 return 语句返回给调用它的地方，即变量 msg，之后输出该返回值。。\n\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\n// 函数定义\nfunction greet() {\n    return "Hello World";\n}\nfunction caller() {\n    var msg = greet(); // 调用 greet() 函数 \n    console.log(msg);\n}\n// 调用函数\ncaller();\n')])])]),a("p",[a("strong",[n._v("带参数函数")])]),n._v(" "),a("p",[n._v("在调用函数时，您可以向其传递值，这些值被称为参数。")]),n._v(" "),a("p",[n._v("这些参数可以在函数中使用。")]),n._v(" "),a("p",[n._v("您可以向函数发送多个参数，每个参数使用逗号 , 分隔：")]),n._v(" "),a("p",[n._v("语法格式如下所示：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function func_name( param1 [:datatype], param2 [:datatype]) {   \n}\nparam1、param2 为参数名。\n\ndatatype 为参数类型。\n\n实例\nTypeScript\nfunction add(x: number, y: number): number {\n    return x + y;\n}\nconsole.log(add(1,2))\n实例中定义了函数 add()，返回值的类型为 number。\n\nadd() 函数中定义了两个 number 类型的参数，函数内将两个参数相加并返回。\n\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nfunction add(x, y) {\n    return x + y;\n}\nconsole.log(add(1, 2));\n输出结果为：\n\n3\n")])])]),a("p",[a("strong",[n._v("可选参数和默认参数")])]),n._v(" "),a("p",[n._v("可选参数\n在 TypeScript 函数里，如果我们定义了参数，则我们必须传入这些参数，除非将这些参数设置为可选，可选参数使用问号标识 ？。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nfunction buildName(firstName: string, lastName: string) {\n    return firstName + " " + lastName;\n}\n \nlet result1 = buildName("Bob");                  // 错误，缺少参数\nlet result2 = buildName("Bob", "Adams", "Sr.");  // 错误，参数太多了\nlet result3 = buildName("Bob", "Adams");         // 正确\n以下实例，我么将 lastName 设置为可选参数：\n\nTypeScript\nfunction buildName(firstName: string, lastName?: string) {\n    if (lastName)\n        return firstName + " " + lastName;\n    else\n        return firstName;\n}\n \nlet result1 = buildName("Bob");  // 正确\nlet result2 = buildName("Bob", "Adams", "Sr.");  // 错误，参数太多了\nlet result3 = buildName("Bob", "Adams");  // 正确\n')])])]),a("p",[n._v("可选参数必须跟在必需参数后面。 如果上例我们想让 firstName 是可选的，lastName 必选，那么就要调整它们的位置，把 firstName 放在后面。")]),n._v(" "),a("p",[n._v("如果都是可选参数就没关系。")]),n._v(" "),a("p",[n._v("默认参数\n我们也可以设置参数的默认值，这样在调用函数的时候，如果不传入该参数的值，则使用默认参数，语法格式为：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('function function_name(param1[:type],param2[:type] = default_value) { \n}注意：参数不能同时设置为可选和默认。\n\n以下实例函数的参数 rate 设置了默认值为 0.50，调用该函数时如果未传入参数则使用该默认值：\n\nTypeScript\nfunction calculate_discount(price:number,rate:number = 0.50) { \n    var discount = price * rate; \n    console.log("计算结果: ",discount); \n} \ncalculate_discount(1000) \ncalculate_discount(1000,0.30)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nfunction calculate_discount(price, rate) {\n    if (rate === void 0) { rate = 0.50; }\n    var discount = price * rate;\n    console.log("计算结果: ", discount);\n}\ncalculate_discount(1000);\ncalculate_discount(1000, 0.30);\n输出结果为：\n\n计算结果:  500\n计算结果:  300\n')])])]),a("p",[a("strong",[n._v("剩余参数")])]),n._v(" "),a("p",[n._v("有一种情况，我们不知道要向函数传入多少个参数，这时候我们就可以使用剩余参数来定义。")]),n._v(" "),a("p",[n._v("剩余参数语法允许我们将一个不确定数量的参数作为一个数组传入。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nfunction buildName(firstName: string, ...restOfName: string[]) {\n    return firstName + " " + restOfName.join(" ");\n}\n  \nlet employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie");\n函数的最后一个命名参数 restOfName 以 ... 为前缀，它将成为一个由剩余参数组成的数组，索引值从0（包括）到 restOfName.length（不包括）。\n\nTypeScript\nfunction addNumbers(...nums:number[]) {  \n    var i;   \n    var sum:number = 0; \n    \n    for(i = 0;i<nums.length;i++) { \n       sum = sum + nums[i]; \n    } \n    console.log("和为：",sum) \n } \n addNumbers(1,2,3) \n addNumbers(10,10,10,10,10)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nfunction addNumbers() {\n    var nums = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nums[_i] = arguments[_i];\n    }\n    var i;\n    var sum = 0;\n    for (i = 0; i < nums.length; i++) {\n        sum = sum + nums[i];\n    }\n    console.log("和为：", sum);\n}\naddNumbers(1, 2, 3);\naddNumbers(10, 10, 10, 10, 10);\n输出结果为：\n\n和为： 6\n和为： 50\n')])])]),a("p",[a("strong",[n._v("匿名函数")])]),n._v(" "),a("p",[n._v("匿名函数是一个没有函数名的函数。")]),n._v(" "),a("p",[n._v("匿名函数在程序运行时动态声明，除了没有函数名外，其他的与标准函数一样。")]),n._v(" "),a("p",[n._v("我们可以将匿名函数赋值给一个变量，这种表达式就成为函数表达式。")]),n._v(" "),a("p",[n._v("语法格式如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('不带参数匿名函数：\n\nTypeScript\nvar msg = function() { \n    return "hello world";  \n} \nconsole.log(msg())\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar msg = function () {\n    return "hello world";\n};\nconsole.log(msg());\n输出结果为：\n\nhello world\n带参数匿名函数：\n\nTypeScript\nvar res = function(a:number,b:number) { \n    return a*b;  \n}; \nconsole.log(res(12,2))\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar res = function (a, b) {\n    return a * b;\n};\nconsole.log(res(12, 2));\n输出结果为：\n\n24\n')])])]),a("p",[a("strong",[n._v("匿名函数自调用")])]),n._v(" "),a("p",[n._v("匿名函数自调用在函数后使用 () 即可：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\n(function () { \n    var x = "Hello!!";   \n    console.log(x)     \n })()\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\n(function () { \n    var x = "Hello!!";   \n    console.log(x)    \n})()\n输出结果为：\n\nHello!!\n')])])]),a("p",[a("strong",[n._v("构造函数")])]),n._v(" "),a("p",[n._v("TypeScript 也支持使用 JavaScript 内置的构造函数 Function() 来定义函数：")]),n._v(" "),a("p",[n._v("语法格式如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var res = new Function( [arguments] ) { ... })\n实例\nTypeScript\nvar myFunction = new Function("a", "b", "return a * b"); \nvar x = myFunction(4, 3); \nconsole.log(x);\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar myFunction = new Function("a", "b", "return a * b"); \nvar x = myFunction(4, 3); \nconsole.log(x);\n输出结果为：\n\n12\n')])])]),a("p",[a("strong",[n._v("递归函数")])]),n._v(" "),a("p",[n._v("递归函数即在函数内调用函数本身。\n举个例子：\n从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？\"从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？'从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……'\"")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("TypeScript\nfunction factorial(number) {\n    if (number <= 0) {         // 停止执行\n        return 1; \n    } else {     \n        return (number * factorial(number - 1));     // 调用自身\n    } \n}; \nconsole.log(factorial(6));      // 输出 720\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nfunction factorial(number) {\n    if (number <= 0) { // 停止执行\n        return 1;\n    }\n    else {\n        return (number * factorial(number - 1)); // 调用自身\n    }\n}\n;\nconsole.log(factorial(6)); // 输出 720\n输出结果为：\n\n720\n")])])]),a("p",[a("strong",[n._v("Lambda 函数")])]),n._v(" "),a("p",[n._v("Lambda 函数也称之为箭头函数。")]),n._v(" "),a("p",[n._v("箭头函数表达式的语法比函数表达式更短。")]),n._v(" "),a("p",[n._v("函数只有一行语句：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('( [param1, parma2,…param n] )=>statement;\n实例\n以下实例声明了 lambda 表达式函数，函数返回两个数的和：\nTypeScript\nvar foo = (x:number)=>10 + x \nconsole.log(foo(100))      //输出结果为 110\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar foo = function (x) { return 10 + x; };\nconsole.log(foo(100)); //输出结果为 110\n输出结果为：\n\n110\n函数是一个语句块：\n\n( [param1, parma2,…param n] )=> {\n \n    // 代码块\n}\n以下实例声明了 lambda 表达式函数，函数返回两个数的和：\n\nTypeScript\nvar foo = (x:number)=> {    \n    x = 10 + x \n    console.log(x)  \n} \nfoo(100)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar foo = function (x) {\n    x = 10 + x;\n    console.log(x);\n};\nfoo(100);\n输出结果为：\n\n110我们可以不指定函数的参数类型，通过函数内来推断参数类型:\nTypeScript\nvar func = (x)=> { \n    if(typeof x=="number") { \n        console.log(x+" 是一个数字") \n    } else if(typeof x=="string") { \n        console.log(x+" 是一个字符串") \n    }  \n} \nfunc(12) \nfunc("Tom")\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar func = function (x) {\n    if (typeof x == "number") {\n        console.log(x + " 是一个数字");\n    }\n    else if (typeof x == "string") {\n        console.log(x + " 是一个字符串");\n    }\n};\nfunc(12);\nfunc("Tom");\n输出结果为：\n\n12 是一个数字\nTom 是一个字符串\n单个参数 () 是可选的：\n\nTypeScript\nvar display = x => { \n    console.log("输出为 "+x) \n} \ndisplay(12)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar display = function (x) {\n    console.log("输出为 " + x);\n};\ndisplay(12);\n输出结果为：\n\n输出为 12\n无参数时可以设置空括号：\n\nTypeScript\nvar disp =()=> { \n    console.log("Function invoked"); \n} \ndisp();\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar disp = function () {\n    console.log("调用函数");\n};\ndisp();\n输出结果为：\n\n调用函数\n')])])]),a("p",[a("strong",[n._v("函数重载")])]),n._v(" "),a("p",[n._v("重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。")]),n._v(" "),a("p",[n._v("每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('参数类型不同：\n\nfunction disp(string):void; \nfunction disp(number):void;\n参数数量不同：\n\nfunction disp(n1:number):void; \nfunction disp(x:number,y:number):void;\n参数类型顺序不同：\n\nfunction disp(n1:number,s1:string):void; \nfunction disp(s:string,n:number):void;\n如果参数类型不同，则参数类型应设置为 any。\n\n参数数量不同你可以将不同的参数设置为可选。\n\n以下实例定义了参数类型与参数数量不同：\n\nTypeScript\nfunction disp(s1:string):void; \nfunction disp(n1:number,s1:string):void; \n \nfunction disp(x:any,y?:any):void { \n    console.log(x); \n    console.log(y); \n} \ndisp("abc") \ndisp(1,"xyz");\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nfunction disp(x, y) {\n    console.log(x);\n    console.log(y);\n}\ndisp("abc");\ndisp(1, "xyz");\n输出结果为：\n\nabc\nundefined\n1\nxyz\n')])])]),a("h2",{attrs:{id:"typescript-number"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-number"}},[n._v("#")]),n._v(" TypeScript Number")]),n._v(" "),a("p",[n._v("TypeScript 与 JavaScript 类似，支持 Number 对象。")]),n._v(" "),a("p",[n._v("Number 对象是原始数值的包装对象。\n"),a("code",[n._v("var num = new Number(value);")]),n._v("\n注意： 如果一个参数值不能转换为一个数字将返回 NaN (非数字值)。")]),n._v(" "),a("p",[a("strong",[n._v("Number 对象属性")])]),n._v(" "),a("p",[n._v('MAX_VALUE\n可表示的最大的数，MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 "Infinity"。')]),n._v(" "),a("p",[n._v('MIN_VALUE\n可表示的最小的数，即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE，MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE ("underflow values") 的值将会转换为 0。')]),n._v(" "),a("p",[n._v("NaN\n非数字值（Not-A-Number）。")]),n._v(" "),a("p",[n._v("NEGATIVE_INFINITY\n负无穷大，溢出时返回该值。该值小于 MIN_VALUE。")]),n._v(" "),a("p",[n._v("POSITIVE_INFINITY\n正无穷大，溢出时返回该值。该值大于 MAX_VALUE。")]),n._v(" "),a("p",[n._v("prototype\nNumber 对象的静态属性。使您有能力向对象添加属性和方法。")]),n._v(" "),a("p",[n._v("constructor\n返回对创建此对象的 Number 函数的引用。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nconsole.log("TypeScript Number 属性: "); \nconsole.log("最大值为: " + Number.MAX_VALUE); \nconsole.log("最小值为: " + Number.MIN_VALUE); \nconsole.log("负无穷大: " + Number.NEGATIVE_INFINITY); \nconsole.log("正无穷大:" + Number.POSITIVE_INFINITY);\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nconsole.log("TypeScript Number 属性: ");\nconsole.log("最大值为: " + Number.MAX_VALUE);\nconsole.log("最小值为: " + Number.MIN_VALUE);\nconsole.log("负无穷大: " + Number.NEGATIVE_INFINITY);\nconsole.log("正无穷大:" + Number.POSITIVE_INFINITY);\n输出结果为：\n\nTypeScript Number 属性:\n最大值为: 1.7976931348623157e+308\n最小值为: 5e-324\n负无穷大: -Infinity\n正无穷大:Infinity\nNaN 实例\nTypeScript\nvar month = 0 \nif( month<=0 || month >12) { \n    month = Number.NaN \n    console.log("月份是："+ month) \n} else { \n    console.log("输入月份数值正确。") \n}\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar month = 0;\nif (month <= 0 || month > 12) {\n    month = Number.NaN;\n    console.log("月份是：" + month);\n}\nelse {\n    console.log("输入月份数值正确。");\n}\n输出结果为：\n\n月份是：NaN\nprototype 实例\nTypeScript\nfunction employee(id:number,name:string) { \n    this.id = id \n    this.name = name \n} \n \nvar emp = new employee(123,"admin") \nemployee.prototype.email = "admin@runoob.com" \n \nconsole.log("员工号: "+emp.id) \nconsole.log("员工姓名: "+emp.name) \nconsole.log("员工邮箱: "+emp.email)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nfunction employee(id, name) {\n    this.id = id;\n    this.name = name;\n}\nvar emp = new employee(123, "admin");\nemployee.prototype.email = "admin@runoob.com";\nconsole.log("员工号: " + emp.id);\nconsole.log("员工姓名: " + emp.name);\nconsole.log("员工邮箱: " + emp.email);\n输出结果为：\n\n员工号: 123\n员工姓名: admin\n员工邮箱: admin@runoob.com\n')])])]),a("p",[a("strong",[n._v("Number 对象方法")])]),n._v(" "),a("p",[n._v("Number对象 支持以下方法：")]),n._v(" "),a("p",[n._v("toExponential()\n把对象的值转换为指数计数法。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("//toExponential() \nvar num1 = 1225.30 \nvar val = num1.toExponential(); \nconsole.log(val) // 输出： 1.2253e+3\n")])])]),a("p",[n._v("toFixed()\n把数字转换为字符串，并对小数点指定位数。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var num3 = 177.234 \nconsole.log("num3.toFixed() 为 "+num3.toFixed())    // 输出：177\nconsole.log("num3.toFixed(2) 为 "+num3.toFixed(2))  // 输出：177.23\nconsole.log("num3.toFixed(6) 为 "+num3.toFixed(6))  // 输出：177.234000\n')])])]),a("p",[n._v("toLocaleString()\n把数字转换为字符串，使用本地数字格式顺序。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var num = new Number(177.1234); \nconsole.log( num.toLocaleString());  // 输出：177.1234\n")])])]),a("p",[n._v("toPrecision()\n把数字格式化为指定的长度。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var num = new Number(7.123456); \nconsole.log(num.toPrecision());  // 输出：7.123456 \nconsole.log(num.toPrecision(1)); // 输出：7\nconsole.log(num.toPrecision(2)); // 输出：7.1\n")])])]),a("p",[n._v("toString()\n把数字转换为字符串，使用指定的基数。数字的基数是 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var num = new Number(10); \nconsole.log(num.toString());  // 输出10进制：10\nconsole.log(num.toString(2)); // 输出2进制：1010\nconsole.log(num.toString(8)); // 输出8进制：12\n")])])]),a("p",[n._v("valueOf()\n返回一个 Number 对象的原始数字值。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var num = new Number(10); \nconsole.log(num.valueOf()); // 输出：10\n")])])]),a("h2",{attrs:{id:"typescript-string（字符串）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-string（字符串）"}},[n._v("#")]),n._v(" TypeScript String（字符串）")]),n._v(" "),a("p",[n._v("String 对象用于处理文本（字符串）。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var txt = new String("string");\n或者更简单方式：\nvar txt = "string";\n')])])]),a("p",[a("strong",[n._v("String 对象属性")])]),n._v(" "),a("p",[n._v("下表列出了 String 对象支持的属性：")]),n._v(" "),a("p",[n._v("constructor\n对创建该对象的函数的引用。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str = new String( "This is string" ); \nconsole.log("str.constructor is:" + str.constructor)\n输出结果：\n\nstr.constructor is:function String() { [native code] }\n')])])]),a("p",[n._v("length\n返回字符串的长度。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var uname = new String("Hello World") \nconsole.log("Length "+uname.length)  // 输出 11\n')])])]),a("p",[n._v("prototype\n允许您向对象添加属性和方法。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('function employee(id:number,name:string) { \n    this.id = id \n    this.name = name \n } \n var emp = new employee(123,"admin") \n employee.prototype.email="admin@runoob.com" // 添加属性 email\n console.log("员工号: "+emp.id) \n console.log("员工姓名: "+emp.name) \n console.log("员工邮箱: "+emp.email)\n')])])]),a("p",[a("strong",[n._v("String 方法")])]),n._v(" "),a("p",[n._v("下表列出了 String 对象支持的方法：")]),n._v(" "),a("p",[n._v("charAt()\n返回在指定位置的字符。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str = new String("RUNOOB"); \nconsole.log("str.charAt(0) 为:" + str.charAt(0)); // R\nconsole.log("str.charAt(1) 为:" + str.charAt(1)); // U \nconsole.log("str.charAt(2) 为:" + str.charAt(2)); // N \nconsole.log("str.charAt(3) 为:" + str.charAt(3)); // O \nconsole.log("str.charAt(4) 为:" + str.charAt(4)); // O \nconsole.log("str.charAt(5) 为:" + str.charAt(5)); // B\n')])])]),a("p",[n._v("charCodeAt()\n返回在指定的位置的字符的 Unicode 编码。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str = new String("RUNOOB"); \nconsole.log("str.charCodeAt(0) 为:" + str.charCodeAt(0)); // 82\nconsole.log("str.charCodeAt(1) 为:" + str.charCodeAt(1)); // 85 \nconsole.log("str.charCodeAt(2) 为:" + str.charCodeAt(2)); // 78 \nconsole.log("str.charCodeAt(3) 为:" + str.charCodeAt(3)); // 79 \nconsole.log("str.charCodeAt(4) 为:" + str.charCodeAt(4)); // 79\nconsole.log("str.charCodeAt(5) 为:" + str.charCodeAt(5)); // 66\n')])])]),a("p",[n._v("concat()\n连接两个或更多字符串，并返回新的字符串。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str1 = new String( "RUNOOB" ); \nvar str2 = new String( "GOOGLE" ); \nvar str3 = str1.concat( str2 ); \nconsole.log("str1 + str2 : "+str3) // RUNOOBGOOGLE\n')])])]),a("p",[n._v("indexOf()\n返回某个指定的字符串值在字符串中首次出现的位置。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str1 = new String( "RUNOOB" ); \n\nvar index = str1.indexOf( "OO" ); \nconsole.log("查找的字符串位置 :" + index );  // 3\n')])])]),a("p",[n._v("lastIndexOf()\n从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str1 = new String( "This is string one and again string" ); \nvar index = str1.lastIndexOf( "string" );\nconsole.log("lastIndexOf 查找到的最后字符串位置 :" + index ); // 29\n    \nindex = str1.lastIndexOf( "one" ); \nconsole.log("lastIndexOf 查找到的最后字符串位置 :" + index ); // 15\n')])])]),a("p",[n._v("localeCompare()\n用本地特定的顺序来比较两个字符串。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str1 = new String( "This is beautiful string" );\n  \nvar index = str1.localeCompare( "This is beautiful string");  \n\nconsole.log("localeCompare first :" + index );  // 0\n')])])]),a("p",[n._v("match()\n查找找到一个或多个正则表达式的匹配。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str="The rain in SPAIN stays mainly in the plain"; \nvar n=str.match(/ain/g);  // ain,ain,ain\n')])])]),a("p",[n._v("replace()\n替换与正则表达式匹配的子串")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var re = /(\\w+)\\s(\\w+)/; \nvar str = "zara ali"; \nvar newstr = str.replace(re, "$2, $1"); \nconsole.log(newstr); // ali, zara\n')])])]),a("p",[n._v("search()\n检索与正则表达式相匹配的值")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var re = /apples/gi; \nvar str = "Apples are round, and apples are juicy.";\nif (str.search(re) == -1 ) { \n   console.log("Does not contain Apples" ); \n} else { \n   console.log("Contains Apples" ); \n} \n')])])]),a("p",[n._v("slice()\n提取字符串的片断，并在新的字符串中返回被提取的部分。")]),n._v(" "),a("p",[n._v("split()\n把字符串分割为子字符串数组。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var str = \"Apples are round, and apples are juicy.\"; \nvar splitted = str.split(\" \", 3); \nconsole.log(splitted)  // [ 'Apples', 'are', 'round,' ]\n")])])]),a("p",[n._v("substr()\n从起始索引号提取字符串中指定数目的字符。")]),n._v(" "),a("p",[n._v("substring()\n提取字符串中两个指定的索引号之间的字符。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str = "RUNOOB GOOGLE TAOBAO FACEBOOK"; \nconsole.log("(1,2): "    + str.substring(1,2));   // U\nconsole.log("(0,10): "   + str.substring(0, 10)); // RUNOOB GOO\nconsole.log("(5): "      + str.substring(5));     // B GOOGLE TAOBAO FACEBOOK\n')])])]),a("p",[n._v("toLocaleLowerCase()\n根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str = "Runoob Google"; \nconsole.log(str.toLocaleLowerCase( ));  // runoob google\n')])])]),a("p",[n._v("toLocaleUpperCase()\n据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str = "Runoob Google"; \nconsole.log(str.toLocaleUpperCase( ));  // RUNOOB GOOGLE\n')])])]),a("p",[n._v("toLowerCase()\n把字符串转换为小写。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str = "Runoob Google"; \nconsole.log(str.toLowerCase( ));  // runoob google\n')])])]),a("p",[n._v("toString()\n返回字符串。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str = "Runoob"; \nconsole.log(str.toString( )); // Runoob\n')])])]),a("p",[n._v("toUpperCase()\n把字符串转换为大写。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str = "Runoob Google"; \nconsole.log(str.toUpperCase( ));  // RUNOOB GOOGLE\n')])])]),a("p",[n._v("valueOf()\n返回指定字符串对象的原始值。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var str = new String("Runoob"); \nconsole.log(str.valueOf( ));  // Runoob\n')])])]),a("p",[a("strong",[n._v("TypeScript Array(数组)")])]),n._v(" "),a("p",[n._v("数组对象是使用单独的变量名来存储一系列的值。")]),n._v(" "),a("p",[n._v("TypeScript 声明数组的语法格式如下所示：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var array_name[:datatype];        //声明 \narray_name = [val1,val2,valn..]   //初始化\n或者直接在声明时初始化：\n\nvar array_name[:data type] = [val1,val2…valn]\n如果数组声明时未设置类型，则会被认为是 any 类型，在初始化时根据第一个元素的类型来推断数组的类型。\n\n创建一个 number 类型的数组：\n\nvar numlist:number[] = [2,4,6,8]\n整个数组结构如下所示：\n索引值第一个为 0，我们可以根据索引值来访问数组元素：\n\nTypeScript\nvar sites:string[]; \nsites = ["Google","Runoob","Taobao"] \nconsole.log(sites[0]); \nconsole.log(sites[1]);\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar sites;\nsites = ["Google", "Runoob", "Taobao"];\nconsole.log(sites[0]);\nconsole.log(sites[1]);\n输出结果为：\n\nGoogle\nRunoob\n以下实例我们在声明时直接初始化：\n\nTypeScript\nvar nums:number[] = [1,2,3,4] \nconsole.log(nums[0]); \nconsole.log(nums[1]); \nconsole.log(nums[2]); \nconsole.log(nums[3]);\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar nums = [1, 2, 3, 4];\nconsole.log(nums[0]);\nconsole.log(nums[1]);\nconsole.log(nums[2]);\nconsole.log(nums[3]);\n输出结果为：\n\n1 \n2 \n3 \n4 \n')])])]),a("p",[a("strong",[n._v("Array 对象")])]),n._v(" "),a("p",[n._v("我们也可以使用 Array 对象创建数组。")]),n._v(" "),a("p",[n._v("Array 对象的构造函数接受以下两种值：")]),n._v(" "),a("p",[n._v("表示数组大小的数值。\n初始化的数组列表，元素使用逗号分隔值。\n实例\n指定数组初始化大小：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nvar arr_names:number[] = new Array(4)  \n \nfor(var i = 0; i<arr_names.length; i++) { \n        arr_names[i] = i * 2 \n        console.log(arr_names[i]) \n}\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar arr_names = new Array(4);\nfor (var i = 0; i < arr_names.length; i++) {\n        arr_names[i] = i * 2;\n        console.log(arr_names[i]);\n}\n输出结果为：\n\n0\n2\n4\n6\n以下实例我们直接初始化数组元素：\n\nTypeScript\nvar sites:string[] = new Array("Google","Runoob","Taobao","Facebook") \n \nfor(var i = 0;i<sites.length;i++) { \n        console.log(sites[i]) \n}\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar sites = new Array("Google", "Runoob", "Taobao", "Facebook");\nfor (var i = 0; i < sites.length; i++) {\n        console.log(sites[i]);\n}\n输出结果为：\n\nGoogle\nRunoob\nTaobao\nFacebook\n')])])]),a("p",[a("strong",[n._v("数组解构")])]),n._v(" "),a("p",[n._v("我们也可以把数组元素赋值给变量，如下所示：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("TypeScript\nvar arr:number[] = [12,13] \nvar[x,y] = arr // 将数组的两个元素赋值给变量 x 和 y\nconsole.log(x) \nconsole.log(y)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar arr = [12, 13];\nvar x = arr[0], y = arr[1]; // 将数组的两个元素赋值给变量 x 和 y\nconsole.log(x);\nconsole.log(y);\n输出结果为：\n\n12\n13\n")])])]),a("p",[a("strong",[n._v("数组迭代")])]),n._v(" "),a("p",[n._v("我们可以使用 for 语句来循环输出数组的各个元素：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("TypeScript\nvar j:any; \nvar nums:number[] = [1001,1002,1003,1004] \n \nfor(j in nums) { \n    console.log(nums[j]) \n}\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar j;\nvar nums = [1001, 1002, 1003, 1004];\nfor (j in nums) {\n    console.log(nums[j]);\n}\n输出结果为：\n\n1001\n1002\n1003\n1004\n")])])]),a("p",[a("strong",[n._v("多维数组")])]),n._v(" "),a("p",[n._v("一个数组的元素可以是另外一个数组，这样就构成了多维数组（Multi-dimensional Array）。")]),n._v(" "),a("p",[n._v("最简单的多维数组是二维数组，定义方式如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var arr_name:datatype[][]=[ [val1,val2,val3],[v1,v2,v3] ]\n实例\n定义一个二维数组，每一个维度的数组有三个元素。\n\nTypeScript\nvar multi:number[][] = [[1,2,3],[23,24,25]]  \nconsole.log(multi[0][0]) \nconsole.log(multi[0][1]) \nconsole.log(multi[0][2]) \nconsole.log(multi[1][0]) \nconsole.log(multi[1][1]) \nconsole.log(multi[1][2])\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar multi = [[1, 2, 3], [23, 24, 25]];\nconsole.log(multi[0][0]);\nconsole.log(multi[0][1]);\nconsole.log(multi[0][2]);\nconsole.log(multi[1][0]);\nconsole.log(multi[1][1]);\nconsole.log(multi[1][2]);\n输出结果为：\n\n1\n2\n3\n23\n24\n25\n")])])]),a("p",[a("strong",[n._v("数组在函数中的使用")])]),n._v(" "),a("p",[n._v("作为参数传递给函数")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nvar sites:string[] = new Array("Google","Runoob","Taobao","Facebook") \n \nfunction disp(arr_sites:string[]) {\n        for(var i = 0;i<arr_sites.length;i++) { \n                console.log(arr_sites[i]) \n        }  \n}  \ndisp(sites);\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar sites = new Array("Google", "Runoob", "Taobao", "Facebook");\nfunction disp(arr_sites) {\n        for (var i = 0; i < arr_sites.length; i++) {\n                console.log(arr_sites[i]);\n        }\n}\ndisp(sites);\n输出结果为：\n\nGoogle\nRunoob\nTaobao\nFacebook\n')])])]),a("p",[n._v("作为函数的返回值")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nfunction disp():string[] { \n        return new Array("Google", "Runoob", "Taobao", "Facebook");\n} \n \nvar sites:string[] = disp() \nfor(var i in sites) { \n        console.log(sites[i]) \n}\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nfunction disp() {\n        return new Array("Google", "Runoob", "Taobao", "Facebook");\n}\nvar sites = disp();\nfor (var i in sites) {\n        console.log(sites[i]);\n}\n输出结果为：\n\nGoogle\nRunoob\nTaobao\nFacebook\n')])])]),a("p",[a("strong",[n._v("数组方法")])]),n._v(" "),a("p",[n._v("下表列出了一些常用的数组方法：")]),n._v(" "),a("p",[n._v("concat()\n连接两个或更多的数组，并返回结果。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var alpha = ["a", "b", "c"]; \nvar numeric = [1, 2, 3];\n\nvar alphaNumeric = alpha.concat(numeric); \nconsole.log("alphaNumeric : " + alphaNumeric );    // a,b,c,1,2,3   \n')])])]),a("p",[n._v("every()\n检测数值元素的每个元素是否都符合条件。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('function isBigEnough(element, index, array) { \n        return (element >= 10); \n} \n        \nvar passed = [12, 5, 8, 130, 44].every(isBigEnough); \nconsole.log("Test Value : " + passed ); // false\n')])])]),a("p",[n._v("filter()\n检测数值元素，并返回符合条件所有元素的数组。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('function isBigEnough(element, index, array) { \n   return (element >= 10); \n} \n          \nvar passed = [12, 5, 8, 130, 44].filter(isBigEnough); \nconsole.log("Test Value : " + passed ); // 12,130,44\n')])])]),a("p",[n._v("forEach()\n数组每个元素都执行一次回调函数。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let num = [7, 8, 9];\nnum.forEach(function (value) {\n    console.log(value);\n}); \n编译成 JavaScript 代码：\n\nvar num = [7, 8, 9];\nnum.forEach(function (value) {\n    console.log(value);  // 7   8   9\n});\n")])])]),a("p",[n._v("indexOf()\n搜索数组中的元素，并返回它所在的位置。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var index = [12, 5, 8, 130, 44].indexOf(8); \nconsole.log("index is : " + index );  // 2\n')])])]),a("p",[n._v("join()\n把数组的所有元素放入一个字符串。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var arr = new Array("First","Second","Third"); \n          \nvar str = arr.join(); \nconsole.log("str : " + str );  // First,Second,Third \n          \nvar str = arr.join(", "); \nconsole.log("str : " + str );  // First, Second, Third\n          \nvar str = arr.join(" + "); \nconsole.log("str : " + str );  // First + Second + Third\n')])])]),a("p",[n._v("lastIndexOf()\n返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var index = [12, 5, 8, 130, 44].lastIndexOf(8); \nconsole.log("index is : " + index );  // 2\n')])])]),a("p",[n._v("map()\n通过指定函数处理数组的每个元素，并返回处理后的数组。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var numbers = [1, 4, 9]; \nvar roots = numbers.map(Math.sqrt); \nconsole.log("roots is : " + roots );  // 1,2,3\n')])])]),a("p",[n._v("pop()\n删除数组的最后一个元素并返回删除的元素。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var numbers = [1, 4, 9]; \n          \nvar element = numbers.pop(); \nconsole.log("element is : " + element );  // 9\n          \nvar element = numbers.pop(); \nconsole.log("element is : " + element );  // 4\n')])])]),a("p",[n._v("push()\n向数组的末尾添加一个或更多元素，并返回新的长度。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var numbers = new Array(1, 4, 9); \nvar length = numbers.push(10); \nconsole.log("new numbers is : " + numbers );  // 1,4,9,10 \nlength = numbers.push(20); \nconsole.log("new numbers is : " + numbers );  // 1,4,9,10,20\n')])])]),a("p",[n._v("reduce()\n将数组元素计算为一个值（从左到右）。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var total = [0, 1, 2, 3].reduce(function(a, b){ return a + b; }); \nconsole.log("total is : " + total );  // 6\n')])])]),a("p",[n._v("reduceRight()\n将数组元素计算为一个值（从右到左）。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var total = [0, 1, 2, 3].reduceRight(function(a, b){ return a + b; }); \nconsole.log("total is : " + total );  // 6\n')])])]),a("p",[n._v("reverse()\n反转数组的元素顺序。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var arr = [0, 1, 2, 3].reverse(); \nconsole.log("Reversed array is : " + arr );  // 3,2,1,0\n')])])]),a("p",[n._v("shift()\n删除并返回数组的第一个元素。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var arr = [10, 1, 2, 3].shift(); \nconsole.log("Shifted value is : " + arr );  // 10\n')])])]),a("p",[n._v("slice()\n选取数组的的一部分，并返回一个新数组。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var arr = ["orange", "mango", "banana", "sugar", "tea"]; \nconsole.log("arr.slice( 1, 2) : " + arr.slice( 1, 2) );  // mango\nconsole.log("arr.slice( 1, 3) : " + arr.slice( 1, 3) );  // mango,banana\n')])])]),a("p",[n._v("some()\n检测数组元素中是否有元素符合指定条件。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('function isBigEnough(element, index, array) { \n   return (element >= 10); \n          \n} \n          \nvar retval = [2, 5, 8, 1, 4].some(isBigEnough);\nconsole.log("Returned value is : " + retval );  // false\n          \nvar retval = [12, 5, 8, 1, 4].some(isBigEnough); \nconsole.log("Returned value is : " + retval );  // true\n')])])]),a("p",[n._v("sort()\n对数组的元素进行排序。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var arr = new Array("orange", "mango", "banana", "sugar"); \nvar sorted = arr.sort(); \nconsole.log("Returned string is : " + sorted );  // banana,mango,orange,sugar\n')])])]),a("p",[n._v("splice()\n从数组中添加或删除元素。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var arr = ["orange", "mango", "banana", "sugar", "tea"];  \nvar removed = arr.splice(2, 0, "water");  \nconsole.log("After adding 1: " + arr );    // orange,mango,water,banana,sugar,tea \nconsole.log("removed is: " + removed); \n          \nremoved = arr.splice(3, 1);  \nconsole.log("After removing 1: " + arr );  // orange,mango,water,sugar,tea \nconsole.log("removed is: " + removed);  // banana\n')])])]),a("p",[n._v("toString()\n把数组转换为字符串，并返回结果。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var arr = new Array("orange", "mango", "banana", "sugar");         \nvar str = arr.toString(); \nconsole.log("Returned string is : " + str );  // orange,mango,banana,sugar\n')])])]),a("p",[n._v("unshift()\n向数组的开头添加一个或更多元素，并返回新的长度。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var arr = new Array("orange", "mango", "banana", "sugar"); \nvar length = arr.unshift("water"); \nconsole.log("Returned array is : " + arr );  // water,orange,mango,banana,sugar \nconsole.log("Length of the array is : " + length ); // 5\n')])])]),a("h2",{attrs:{id:"typescript-元组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-元组"}},[n._v("#")]),n._v(" TypeScript 元组")]),n._v(" "),a("p",[n._v("我们知道数组中元素的数据类型都一般是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组。")]),n._v(" "),a("p",[n._v("元组中允许存储不同类型的元素，元组可以作为参数传递给函数。")]),n._v(" "),a("p",[n._v("创建元组的语法格式如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var tuple_name = [value1,value2,value3,…value n]\n声明一个元组并初始化：\n\nvar mytuple = [10,"Runoob"];\n或者我们可以先声明一个空元组，然后再初始化：\n\nvar mytuple = []; \nmytuple[0] = 120 \nmytuple[1] = 234\n\n')])])]),a("p",[a("strong",[n._v("访问元组")])]),n._v(" "),a("p",[n._v("元组中元素使用索引来访问，第一个元素的索引值为 0，第二个为 1，以此类推第 n 个为 n-1，语法格式如下:")]),n._v(" "),a("p",[a("code",[n._v("tuple_name[index]")]),n._v("\n以下实例定义了元组，包含了数字和字符串两种类型的元素：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nvar mytuple = [10,"Runoob"]; // 创建元组\nconsole.log(mytuple[0]) \nconsole.log(mytuple[1])\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar mytuple = [10, "Runoob"]; // 创建元组\nconsole.log(mytuple[0]);\nconsole.log(mytuple[1]);\n输出结果为：\n\n10\nRunoob\n')])])]),a("p",[a("strong",[n._v("元组运算")])]),n._v(" "),a("p",[n._v("我们可以使用以下两个函数向元组添加新元素或者删除元素：")]),n._v(" "),a("p",[n._v("push() 向元组添加元素，添加在最后面。")]),n._v(" "),a("p",[n._v("pop() 从元组中移除元素（最后一个），并返回移除的元素。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nvar mytuple = [10,"Hello","World","typeScript"]; \nconsole.log("添加前元素个数："+mytuple.length)    // 返回元组的大小\n \nmytuple.push(12)                                    // 添加到元组中\nconsole.log("添加后元素个数："+mytuple.length) \nconsole.log("删除前元素个数："+mytuple.length) \nconsole.log(mytuple.pop()+" 元素从元组中删除") // 删除并返回删除的元素\n        \nconsole.log("删除后元素个数："+mytuple.length)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar mytuple = [10, "Hello", "World", "typeScript"];\nconsole.log("添加前元素个数：" + mytuple.length); // 返回元组的大小\nmytuple.push(12); // 添加到元组中\nconsole.log("添加后元素个数：" + mytuple.length);\nconsole.log("删除前元素个数：" + mytuple.length);\nconsole.log(mytuple.pop() + " 元素从元组中删除"); // 删除并返回删除的元素\nconsole.log("删除后元素个数：" + mytuple.length);\n输出结果为：\n\n添加前元素个数：4\n添加后元素个数：5\n删除前元素个数：5\n12 元素从元组中删除\n删除后元素个数：4\n')])])]),a("p",[a("strong",[n._v("更新元组")])]),n._v(" "),a("p",[n._v("元组是可变的，这意味着我们可以对元组进行更新操作：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nvar mytuple = [10, "Runoob", "Taobao", "Google"]; // 创建一个元组\nconsole.log("元组的第一个元素为：" + mytuple[0]) \n \n// 更新元组元素\nmytuple[0] = 121     \nconsole.log("元组中的第一个元素更新为："+ mytuple[0])\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar mytuple = [10, "Runoob", "Taobao", "Google"]; // 创建一个元组\nconsole.log("元组的第一个元素为：" + mytuple[0]);\n// 更新元组元素\nmytuple[0] = 121;\nconsole.log("元组中的第一个元素更新为：" + mytuple[0]);\n输出结果为：\n\n元组的第一个元素为：10\n元组中的第一个元素更新为：121\n解构元组\n我们也可以把元组元素赋值给变量，如下所示：\n\nTypeScript\nvar a =[10,"Runoob"] \nvar [b,c] = a \nconsole.log( b )    \nconsole.log( c )\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar a = [10, "Runoob"];\nvar b = a[0], c = a[1];\nconsole.log(b);\nconsole.log(c);\n输出结果为：\n\n10\nRunoob\n')])])]),a("h2",{attrs:{id:"typescript-联合类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-联合类型"}},[n._v("#")]),n._v(" TypeScript 联合类型")]),n._v(" "),a("p",[n._v("联合类型（Union Types）可以通过管道(|)将变量设置多种类型，赋值时可以根据设置的类型来赋值。")]),n._v(" "),a("p",[n._v("注意：只能赋值指定的类型，如果赋值其它类型就会报错。")]),n._v(" "),a("p",[n._v("创建联合类型的语法格式如下：")]),n._v(" "),a("p",[n._v("Type1|Type2|Type3\n声明一个联合类型：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nvar val:string|number \nval = 12 \nconsole.log("数字为 "+ val) \nval = "Runoob" \nconsole.log("字符串为 " + val)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar val;\nval = 12;\nconsole.log("数字为 " + val);\nval = "Runoob";\nconsole.log("字符串为 " + val);\n输出结果为：\n\n数字为 12\n字符串为 Runoob\n如果赋值其它类型就会报错：\n\nvar val:string|number \nval = true \n也可以将联合类型作为函数参数使用：\n\nTypeScript\nfunction disp(name:string|string[]) { \n        if(typeof name == "string") { \n                console.log(name) \n        } else { \n                var i; \n                for(i = 0;i<name.length;i++) { \n                console.log(name[i])\n                } \n        } \n} \ndisp("Runoob") \nconsole.log("输出数组....") \ndisp(["Runoob","Google","Taobao","Facebook"])\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nfunction disp(name) {\n        if (typeof name == "string") {\n                console.log(name);\n        }\n        else {\n                var i;\n                for (i = 0; i < name.length; i++) {\n                console.log(name[i]);\n                }\n        }\n}\ndisp("Runoob");\nconsole.log("输出数组....");\ndisp(["Runoob", "Google", "Taobao", "Facebook"]);\n输出结果为：\n\nRunoob\n输出数组....\nRunoob\nGoogle\nTaobao\nFacebook\n')])])]),a("p",[a("strong",[n._v("联合类型数组")])]),n._v(" "),a("p",[n._v("我们也可以将数组声明为联合类型：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nvar arr:number[]|string[]; \nvar i:number; \narr = [1,2,4] \nconsole.log("**数字数组**")  \n \nfor(i = 0;i<arr.length;i++) { \n   console.log(arr[i]) \n}  \n \narr = ["Runoob","Google","Taobao"] \nconsole.log("**字符串数字**")  \n \nfor(i = 0;i<arr.length;i++) { \n   console.log(arr[i]) \n}\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar arr;\nvar i;\narr = [1, 2, 4];\nconsole.log("**数字数组**");\nfor (i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}\narr = ["Runoob", "Google", "Taobao"];\nconsole.log("**字符串数字**");\nfor (i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}\n输出结果为：\n\n**数字数组**\n1\n2\n4\n**字符串数字**\nRunoob\nGoogle\nTaobao\n')])])]),a("h2",{attrs:{id:"typescript-接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-接口"}},[n._v("#")]),n._v(" TypeScript 接口")]),n._v(" "),a("p",[n._v("接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。")]),n._v(" "),a("p",[n._v("TypeScript 接口定义如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('interface interface_name { \n}\n以下实例中，我们定义了一个接口 IPerson，接着定义了一个变量 customer，它的类型是 IPerson。\n\ncustomer 实现了接口 IPerson 的属性和方法。\n\nTypeScript\ninterface IPerson { \n    firstName:string, \n    lastName:string, \n    sayHi: ()=>string \n} \n \nvar customer:IPerson = { \n    firstName:"Tom",\n    lastName:"Hanks", \n    sayHi: ():string =>{return "Hi there"} \n} \n \nconsole.log("Customer 对象 ") \nconsole.log(customer.firstName) \nconsole.log(customer.lastName) \nconsole.log(customer.sayHi())  \n \nvar employee:IPerson = { \n    firstName:"Jim",\n    lastName:"Blakes", \n    sayHi: ():string =>{return "Hello!!!"} \n} \n \nconsole.log("Employee  对象 ") \nconsole.log(employee.firstName) \nconsole.log(employee.lastName)\n需要注意接口不能转换为 JavaScript。 它只是 TypeScript 的一部分。\n\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar customer = {\n    firstName: "Tom",\n    lastName: "Hanks",\n    sayHi: function () { return "Hi there"; }\n};\nconsole.log("Customer 对象 ");\nconsole.log(customer.firstName);\nconsole.log(customer.lastName);\nconsole.log(customer.sayHi());\nvar employee = {\n    firstName: "Jim",\n    lastName: "Blakes",\n    sayHi: function () { return "Hello!!!"; }\n};\nconsole.log("Employee  对象 ");\nconsole.log(employee.firstName);\nconsole.log(employee.lastName);\n输出结果为：\n\nCustomer 对象\nTom\nHanks\nHi there\nEmployee  对象\nJim\nBlakes\n')])])]),a("p",[a("strong",[n._v("联合类型和接口")])]),n._v(" "),a("p",[n._v("以下实例演示了如何在接口中使用联合类型：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\ninterface RunOptions { \n    program:string; \n    commandline:string[]|string|(()=>string); \n} \n \n// commandline 是字符串\nvar options:RunOptions = {program:"test1",commandline:"Hello"}; \nconsole.log(options.commandline)  \n \n// commandline 是字符串数组\noptions = {program:"test1",commandline:["Hello","World"]}; \nconsole.log(options.commandline[0]); \nconsole.log(options.commandline[1]);  \n \n// commandline 是一个函数表达式\noptions = {program:"test1",commandline:()=>{return "**Hello World**";}}; \n \nvar fn:any = options.commandline; \nconsole.log(fn());\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\n// commandline 是字符串\nvar options = { program: "test1", commandline: "Hello" };\nconsole.log(options.commandline);\n// commandline 是字符串数组\noptions = { program: "test1", commandline: ["Hello", "World"] };\nconsole.log(options.commandline[0]);\nconsole.log(options.commandline[1]);\n// commandline 是一个函数表达式\noptions = { program: "test1", commandline: function () { return "**Hello World**"; } };\nvar fn = options.commandline;\nconsole.log(fn());\n输出结果为：\n\nHello\nHello\nWorld\n**Hello World**\n')])])]),a("p",[a("strong",[n._v("接口和数组")])]),n._v(" "),a("p",[n._v("接口中我们可以将数组的索引值和元素设置为不同类型，索引值可以是数字或字符串。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\ninterface namelist { \n   [index:number]:string \n} \n \nvar list2:namelist = ["John",1,"Bran"] / 错误元素 1 不是 string 类型\ninterface ages { \n   [index:string]:number \n} \n \nvar agelist:ages; \nagelist["John"] = 15   // 正确 \nagelist[2] = "nine"   // 错误\n')])])]),a("p",[a("strong",[n._v("接口继承")])]),n._v(" "),a("p",[n._v("接口继承就是说接口可以通过其他接口来扩展自己。")]),n._v(" "),a("p",[n._v("Typescript 允许接口继承多个接口。")]),n._v(" "),a("p",[n._v("继承使用关键字 extends。")]),n._v(" "),a("p",[n._v("单接口继承语法格式：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('Child_interface_name extends super_interface_name\n多接口继承语法格式：\n\nChild_interface_name extends super_interface1_name, super_interface2_name,…,super_interfaceN_name\n继承的各个接口使用逗号 , 分隔。\n\nTypeScript\ninterface Person { \n   age:number \n} \n \ninterface Musician extends Person { \n   instrument:string \n} \n \nvar drummer = <Musician>{}; \ndrummer.age = 27 \ndrummer.instrument = "Drums" \nconsole.log("年龄:  "+drummer.age)\nconsole.log("喜欢的乐器:  "+drummer.instrument)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar drummer = {};\ndrummer.age = 27;\ndrummer.instrument = "Drums";\nconsole.log("年龄:  " + drummer.age);\nconsole.log("喜欢的乐器:  " + drummer.instrument);\n输出结果为：\n\n年龄:  27\n喜欢的乐器:  Drums\n多继承实例\nTypeScript\ninterface IParent1 { \n    v1:number \n} \n \ninterface IParent2 { \n    v2:number \n} \n \ninterface Child extends IParent1, IParent2 { } \nvar Iobj:Child = { v1:12, v2:23} \nconsole.log("value 1: "+Iobj.v1+" value 2: "+Iobj.v2)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar Iobj = { v1: 12, v2: 23 };\nconsole.log("value 1: " + Iobj.v1 + " value 2: " + Iobj.v2);\n输出结果为：\n\nvalue 1: 12 value 2: 23\n')])])]),a("h2",{attrs:{id:"typescript-类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-类"}},[n._v("#")]),n._v(" TypeScript 类")]),n._v(" "),a("p",[n._v("TypeScript 是面向对象的 JavaScript。")]),n._v(" "),a("p",[n._v("类描述了所创建的对象共同的属性和方法。")]),n._v(" "),a("p",[n._v("TypeScript 支持面向对象的所有特性，比如 类、接口等。")]),n._v(" "),a("p",[n._v("TypeScript 类定义方式如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class class_name { \n    // 类作用域\n}\n定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：\n\n字段 − 字段是类里面声明的变量。字段表示对象的有关数据。\n\n构造函数 − 类实例化时调用，可以为类的对象分配内存。\n\n方法 − 方法为对象要执行的操作。\n\n实例\n创建一个 Person 类：\n\nTypeScript\nclass Person {\n}\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar Person = /** @class */ (function () {\n    function Person() {\n    }\n    return Person;\n}());\n")])])]),a("p",[a("strong",[n._v("创建类的数据成员")])]),n._v(" "),a("p",[n._v("以下实例我们声明了类 Car，包含字段为 engine，构造函数在类实例化后初始化字段 engine。")]),n._v(" "),a("p",[n._v("this 关键字表示当前类实例化的对象。注意构造函数的参数名与字段名相同，this.engine 表示类的字段。")]),n._v(" "),a("p",[n._v("此外我们也在类中定义了一个方法 disp()。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nclass Car { \n    // 字段 \n    engine:string; \n \n    // 构造函数 \n    constructor(engine:string) { \n        this.engine = engine \n    }  \n \n    // 方法 \n    disp():void { \n        console.log("发动机为 :   "+this.engine) \n    } \n}\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar Car = /** @class */ (function () {\n    // 构造函数 \n    function Car(engine) {\n        this.engine = engine;\n    }\n    // 方法 \n    Car.prototype.disp = function () {\n        console.log("发动机为 :   " + this.engine);\n    };\n    return Car;\n}());\n')])])]),a("p",[a("strong",[n._v("创建实例化对象")])]),n._v(" "),a("p",[n._v("我们使用 new 关键字来实例化类的对象，语法格式如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var object_name = new class_name([ arguments ])\n类实例化时会调用构造函数，例如：\n\nvar obj = new Car("Engine 1")\n类中的字段属性和方法可以使用 . 号来访问：\n\n// 访问属性\nobj.field_name \n\n// 访问方法\nobj.function_name()\n完整实例\n以下实例创建来一个 Car 类，然后通过关键字 new 来创建一个对象并访问属性和方法：\n\nTypeScript\nclass Car { \n   // 字段\n   engine:string; \n   \n   // 构造函数\n   constructor(engine:string) { \n      this.engine = engine \n   }  \n   \n   // 方法\n   disp():void { \n      console.log("函数中显示发动机型号  :   "+this.engine) \n   } \n} \n \n// 创建一个对象\nvar obj = new Car("XXSY1")\n \n// 访问字段\nconsole.log("读取发动机型号 :  "+obj.engine)  \n \n// 访问方法\nobj.disp()\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar Car = /** @class */ (function () {\n    // 构造函数\n    function Car(engine) {\n        this.engine = engine;\n    }\n    // 方法\n    Car.prototype.disp = function () {\n        console.log("函数中显示发动机型号  :   " + this.engine);\n    };\n    return Car;\n}());\n// 创建一个对象\nvar obj = new Car("XXSY1");\n// 访问字段\nconsole.log("读取发动机型号 :  " + obj.engine);\n// 访问方法\nobj.disp();\n输出结果为：\n\n读取发动机型号 :  XXSY1\n函数中显示发动机型号  :   XXSY1\n')])])]),a("p",[a("strong",[n._v("类的继承")])]),n._v(" "),a("p",[n._v("TypeScript 支持继承类，即我们可以在创建类的时候继承一个已存在的类，这个已存在的类称为父类，继承它的类称为子类。")]),n._v(" "),a("p",[n._v("类继承使用关键字 extends，子类除了不能继承父类的私有成员(方法和属性)和构造函数，其他的都可以继承。")]),n._v(" "),a("p",[n._v("TypeScript 一次只能继承一个类，不支持继承多个类，但 TypeScript 支持多重继承（A 继承 B，B 继承 C）。")]),n._v(" "),a("p",[n._v("语法格式如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('class child_class_name extends parent_class_name\n类的继承：实例中创建了 Shape 类，Circle 类继承了 Shape 类，Circle 类可以直接使用 Area 属性：\n\nTypeScript\nclass Shape { \n   Area:number \n   \n   constructor(a:number) { \n      this.Area = a \n   } \n} \n \nclass Circle extends Shape { \n   disp():void { \n      console.log("圆的面积:  "+this.Area) \n   } \n}\n  \nvar obj = new Circle(223); \nobj.disp()\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Shape = /** @class */ (function () {\n    function Shape(a) {\n        this.Area = a;\n    }\n    return Shape;\n}());\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    function Circle() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Circle.prototype.disp = function () {\n        console.log("圆的面积:  " + this.Area);\n    };\n    return Circle;\n}(Shape));\nvar obj = new Circle(223);\nobj.disp();\n输出结果为：\n\n圆的面积:  223\n需要注意的是子类只能继承一个父类，TypeScript 不支持继承多个类，但支持多重继承，如下实例：\n\nTypeScript\nclass Root { \n   str:string; \n} \n \nclass Child extends Root {} \nclass Leaf extends Child {} // 多重继承，继承了 Child 和 Root 类\n \nvar obj = new Leaf(); \nobj.str ="hello" \nconsole.log(obj.str)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Root = /** @class */ (function () {\n    function Root() {\n    }\n    return Root;\n}());\nvar Child = /** @class */ (function (_super) {\n    __extends(Child, _super);\n    function Child() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Child;\n}(Root));\nvar Leaf = /** @class */ (function (_super) {\n    __extends(Leaf, _super);\n    function Leaf() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return Leaf;\n}(Child)); // 多重继承，继承了 Child 和 Root 类\nvar obj = new Leaf();\nobj.str = "hello";\nconsole.log(obj.str);\n输出结果为：\n\nhello\n')])])]),a("p",[a("strong",[n._v("继承类的方法重写")])]),n._v(" "),a("p",[n._v("类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。")]),n._v(" "),a("p",[n._v("其中 super 关键字是对父类的直接引用，该关键字可以引用父类的属性和方法。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nclass PrinterClass { \n   doPrint():void {\n      console.log("父类的 doPrint() 方法。") \n   } \n} \n \nclass StringPrinter extends PrinterClass { \n   doPrint():void { \n      super.doPrint() // 调用父类的函数\n      console.log("子类的 doPrint()方法。")\n   } \n}\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar obj = new StringPrinter() \nobj.doPrint()\n \nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar PrinterClass = /** @class */ (function () {\n    function PrinterClass() {\n    }\n    PrinterClass.prototype.doPrint = function () {\n        console.log("父类的 doPrint() 方法。");\n    };\n    return PrinterClass;\n}());\nvar StringPrinter = /** @class */ (function (_super) {\n    __extends(StringPrinter, _super);\n    function StringPrinter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    StringPrinter.prototype.doPrint = function () {\n        _super.prototype.doPrint.call(this); // 调用父类的函数\n        console.log("子类的 doPrint()方法。");\n    };\n    return StringPrinter;\n}(PrinterClass));\nvar obj = new StringPrinter();\nobj.doPrint();\n输出结果为：\n\n父类的 doPrint() 方法。\n子类的 doPrint()方法。\n')])])]),a("p",[a("strong",[n._v("static 关键字")])]),n._v(" "),a("p",[n._v("static 关键字用于定义类的数据成员（属性和方法）为静态的，静态成员可以直接通过类名调用。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('TypeScript\nclass StaticMem {  \n   static num:number; \n   \n   static disp():void { \n      console.log("num 值为 "+ StaticMem.num) \n   } \n} \n \nStaticMem.num = 12     // 初始化静态变量\nStaticMem.disp()       // 调用静态方法\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar StaticMem = /** @class */ (function () {\n    function StaticMem() {\n    }\n    StaticMem.disp = function () {\n        console.log("num 值为 " + StaticMem.num);\n    };\n    return StaticMem;\n}());\nStaticMem.num = 12; // 初始化静态变量\nStaticMem.disp(); // 调用静态方法\n输出结果为：\n\nnum 值为 12\ninstanceof 运算符\ninstanceof 运算符用于判断对象是否是指定的类型，如果是返回 true，否则返回 false。\n\nTypeScript\nclass Person{ } \nvar obj = new Person() \nvar isPerson = obj instanceof Person; \nconsole.log("obj 对象是 Person 类实例化来的吗？ " + isPerson);\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar Person = /** @class */ (function () {\n    function Person() {\n    }\n    return Person;\n}());\nvar obj = new Person();\nvar isPerson = obj instanceof Person;\nconsole.log(" obj 对象是 Person 类实例化来的吗？ " + isPerson);\n输出结果为：\n\nobj 对象是 Person 类实例化来的吗？ true\n访问控制修饰符\nTypeScript 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。TypeScript 支持 3 种不同的访问权限。\n\npublic（默认） : 公有，可以在任何地方被访问。\n\nprotected : 受保护，可以被其自身以及其子类和父类访问。\n\nprivate : 私有，只能被其定义所在的类访问。\n\n以下实例定义了两个变量 str1 和 str2，str1 为 public，str2 为 private，实例化后可以访问 str1，如果要访问 str2 则会编译错误。\n\nTypeScript\nclass Encapsulate { \n   str1:string = "hello" \n   private str2:string = "world" \n}\n \nvar obj = new Encapsulate() \nconsole.log(obj.str1)     // 可访问 \nconsole.log(obj.str2)   // 编译错误， str2 是私有的\n类和接口\n类可以实现接口，使用关键字 implements，并将 interest 字段作为类的属性使用。\n\n以下实例红 AgriLoan 类实现了 ILoan 接口：\n\nTypeScript\ninterface ILoan { \n   interest:number \n} \n \nclass AgriLoan implements ILoan { \n   interest:number \n   rebate:number \n   \n   constructor(interest:number,rebate:number) { \n      this.interest = interest \n      this.rebate = rebate \n   } \n} \n \nvar obj = new AgriLoan(10,1) \nconsole.log("利润为 : "+obj.interest+"，抽成为 : "+obj.rebate )\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar AgriLoan = /** @class */ (function () {\n    function AgriLoan(interest, rebate) {\n        this.interest = interest;\n        this.rebate = rebate;\n    }\n    return AgriLoan;\n}());\nvar obj = new AgriLoan(10, 1);\nconsole.log("利润为 : " + obj.interest + "，抽成为 : " + obj.rebate);\n输出结果为：\n\n利润为 : 10，抽成为 : 1\n')])])]),a("h2",{attrs:{id:"typescript-对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-对象"}},[n._v("#")]),n._v(" TypeScript 对象")]),n._v(" "),a("p",[n._v("对象是包含一组键值对的实例。 值可以是标量、函数、数组、对象等，如下实例：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var object_name = { \n    key1: "value1", // 标量\n    key2: "value",  \n    key3: function() {\n        // 函数\n    }, \n    key4:["content1", "content2"] //集合\n}\n以上对象包含了标量，函数，集合(数组或元组)。\n\n对象实例\nTypeScript\nvar sites = { \n   site1:"Runoob", \n   site2:"Google" \n}; \n// 访问对象的值\nconsole.log(sites.site1) \nconsole.log(sites.site2)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar sites = { \n   site1:"Runoob", \n   site2:"Google" \n}; \n// 访问对象的值\nconsole.log(sites.site1) \nconsole.log(sites.site2)\ninvokesites(sites);\n输出结果为：\n\nRunoob\nGoogle\n')])])]),a("p",[a("strong",[n._v("TypeScript 类型模板")])]),n._v(" "),a("p",[n._v("假如我们在 JavaScript 定义了一个对象：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var sites = { \n   site1:"Runoob", \n   site2:"Google" \n};\n这时如果我们想在对象中添加方法，可以做以下修改：\n\nsites.sayHello = function(){ return "hello";}\n如果在 TypeScript 中使用以上方式则会出现编译错误，因为Typescript 中的对象必须是特定类型的实例。\n\nTypeScript\nvar sites = {\n    site1: "Runoob",\n    site2: "Google",\n    sayHello: function () { } // 类型模板\n};\nsites.sayHello = function () {\n    console.log("hello " + sites.site1);\n};\nsites.sayHello();\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar sites = {\n    site1: "Runoob",\n    site2: "Google",\n    sayHello: function () { } // 类型模板\n};\nsites.sayHello = function () {\n    console.log("hello " + sites.site1);\n};\nsites.sayHello();\n输出结果为：\n\nhello Runoob\n此外对象也可以作为一个参数传递给函数，如下实例：\n\nTypeScript\nvar sites = { \n    site1:"Runoob", \n    site2:"Google",\n}; \nvar invokesites = function(obj: { site1:string, site2 :string }) { \n    console.log("site1 :"+obj.site1) \n    console.log("site2 :"+obj.site2) \n} \ninvokesites(sites)\n编译以上代码，得到以下 JavaScript 代码：\n\nJavaScript\nvar sites = {\n    site1: "Runoob",\n    site2: "Google"\n};\nvar invokesites = function (obj) {\n    console.log("site1 :" + obj.site1);\n    console.log("site2 :" + obj.site2);\n};\ninvokesites(sites);\n输出结果为：\n\nsite1 :Runoob\nsite2 :Google\n')])])]),a("p",[a("strong",[n._v("鸭子类型(Duck Typing)")])]),n._v(" "),a("p",[n._v("鸭子类型（英语：duck typing）是动态类型的一种风格，是多态(polymorphism)的一种形式。")]),n._v(" "),a("p",[n._v('在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由"当前方法和属性的集合"决定。')]),n._v(" "),a("p",[n._v("可以这样表述：")]),n._v(" "),a("p",[n._v('"当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。"')]),n._v(" "),a("p",[n._v('在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为"鸭子"的对象，并调用它的"走"和"叫"方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的"走"和"叫"方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的"走"和"叫"方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。')]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("interface IPoint { \n    x:number \n    y:number \n} \nfunction addPoints(p1:IPoint,p2:IPoint):IPoint { \n    var x = p1.x + p2.x \n    var y = p1.y + p2.y \n    return {x:x,y:y} \n} \n \n// 正确\nvar newPoint = addPoints({x:3,y:4},{x:5,y:1})  \n \n// 错误 \nvar newPoint2 = addPoints({x:1},{x:4,y:3})\n")])])]),a("h2",{attrs:{id:"typescript-命名空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-命名空间"}},[n._v("#")]),n._v(" TypeScript 命名空间")]),n._v(" "),a("p",[n._v("命名空间一个最明确的目的就是解决重名问题。")]),n._v(" "),a("p",[n._v("假设这样一种情况，当一个班上有两个名叫小明的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的姓（王小明，李小明），或者他们父母的名字等等。")]),n._v(" "),a("p",[n._v("命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的。这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中。")]),n._v(" "),a("p",[n._v("TypeScript 中命名空间使用 namespace 来定义，语法格式如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('namespace SomeNameSpaceName { \n   export interface ISomeInterfaceName {      }  \n   export class SomeClassName {      }  \n}\n以上定义了一个命名空间 SomeNameSpaceName，如果我们需要在外部可以调用 SomeNameSpaceName 中的类和接口，则需要在类和接口添加 export 关键字。\n\n要在另外一个命名空间调用语法格式为：\n\nSomeNameSpaceName.SomeClassName;\n如果一个命名空间在一个单独的 TypeScript 文件中，则应使用三斜杠 /// 引用它，语法格式如下：\n\n/// <reference path = "SomeFileName.ts" />\n以下实例演示了命名空间的使用，定义在不同文件中：\n\nIShape.ts 文件代码：\nnamespace Drawing { \n    export interface IShape { \n        draw(); \n    }\n}\nCircle.ts 文件代码：\n/// <reference path = "IShape.ts" /> \nnamespace Drawing { \n    export class Circle implements IShape { \n        public draw() { \n            console.log("Circle is drawn"); \n        }  \n    }\n}\nTriangle.ts 文件代码：\n/// <reference path = "IShape.ts" /> \nnamespace Drawing { \n    export class Triangle implements IShape { \n        public draw() { \n            console.log("Triangle is drawn"); \n        } \n    } \n}\nTestShape.ts 文件代码：\n/// <reference path = "IShape.ts" />   \n/// <reference path = "Circle.ts" /> \n/// <reference path = "Triangle.ts" />  \nfunction drawAllShapes(shape:Drawing.IShape) { \n    shape.draw(); \n} \ndrawAllShapes(new Drawing.Circle());\ndrawAllShapes(new Drawing.Triangle());\n使用 tsc 命令编译以上代码：\n\ntsc --out app.js TestShape.ts  \n得到以下 JavaScript 代码：\n\nJavaScript\n/// <reference path = "IShape.ts" /> \nvar Drawing;\n(function (Drawing) {\n    var Circle = /** @class */ (function () {\n        function Circle() {\n        }\n        Circle.prototype.draw = function () {\n            console.log("Circle is drawn");\n        };\n        return Circle;\n    }());\n    Drawing.Circle = Circle;\n})(Drawing || (Drawing = {}));\n/// <reference path = "IShape.ts" /> \nvar Drawing;\n(function (Drawing) {\n    var Triangle = /** @class */ (function () {\n        function Triangle() {\n        }\n        Triangle.prototype.draw = function () {\n            console.log("Triangle is drawn");\n        };\n        return Triangle;\n    }());\n    Drawing.Triangle = Triangle;\n})(Drawing || (Drawing = {}));\n/// <reference path = "IShape.ts" />   \n/// <reference path = "Circle.ts" /> \n/// <reference path = "Triangle.ts" />  \nfunction drawAllShapes(shape) {\n    shape.draw();\n}\ndrawAllShapes(new Drawing.Circle());\ndrawAllShapes(new Drawing.Triangle());\n使用 node 命令查看输出结果为：\n\n$ node app.js\nCircle is drawn\nTriangle is drawn\n')])])]),a("p",[a("strong",[n._v("嵌套命名空间")])]),n._v(" "),a("p",[n._v("命名空间支持嵌套，即你可以将命名空间定义在另外一个命名空间里头。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('namespace namespace_name1 { \n    export namespace namespace_name2 {\n        export class class_name {    } \n    } \n}\n成员的访问使用点号 . 来实现，如下实例：\n\nInvoice.ts 文件代码：\nnamespace Runoob { \n   export namespace invoiceApp { \n      export class Invoice { \n         public calculateDiscount(price: number) { \n            return price * .40; \n         } \n      } \n   } \n}\nInvoiceTest.ts 文件代码：\n/// <reference path = "Invoice.ts" />\nvar invoice = new Runoob.invoiceApp.Invoice(); \nconsole.log(invoice.calculateDiscount(500));\n使用 tsc 命令编译以上代码：\n\ntsc --out app.js InvoiceTest.ts\n得到以下 JavaScript 代码：\n\nJavaScript\nvar Runoob;\n(function (Runoob) {\n    var invoiceApp;\n    (function (invoiceApp) {\n        var Invoice = /** @class */ (function () {\n            function Invoice() {\n            }\n            Invoice.prototype.calculateDiscount = function (price) {\n                return price * .40;\n            };\n            return Invoice;\n        }());\n        invoiceApp.Invoice = Invoice;\n    })(invoiceApp = Runoob.invoiceApp || (Runoob.invoiceApp = {}));\n})(Runoob || (Runoob = {}));\n/// <reference path = "Invoice.ts" />\nvar invoice = new Runoob.invoiceApp.Invoice();\nconsole.log(invoice.calculateDiscount(500));\n使用 node 命令查看输出结果为：\n\n$ node app.js\n200\n')])])]),a("h2",{attrs:{id:"typescript-模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-模块"}},[n._v("#")]),n._v(" TypeScript 模块")]),n._v(" "),a("p",[n._v("TypeScript 模块的设计理念是可以更换的组织代码。")]),n._v(" "),a("p",[n._v("模块是在其自身的作用域里执行，并不是在全局作用域，这意味着定义在模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。")]),n._v(" "),a("p",[n._v("两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。")]),n._v(" "),a("p",[n._v("模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 大家最熟知的JavaScript模块加载器是服务于 Node.js 的 CommonJS 和服务于 Web 应用的 Require.js。")]),n._v(" "),a("p",[n._v("此外还有有 SystemJs 和 Webpack。")]),n._v(" "),a("p",[n._v("模块导出使用关键字 export 关键字，语法格式如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 文件名 : SomeInterface.ts \nexport interface SomeInterface { \n   // 代码部分\n}\n要在另外一个文件使用该模块就需要使用 import 关键字来导入:\n\nimport someInterfaceRef = require("./SomeInterface");\n实例\nIShape.ts 文件代码：\n/// <reference path = "IShape.ts" /> \nexport interface IShape { \n   draw(); \n}\nCircle.ts 文件代码：\nimport shape = require("./IShape"); \nexport class Circle implements shape.IShape { \n   public draw() { \n      console.log("Cirlce is drawn (external module)"); \n   } \n}\nTriangle.ts 文件代码：\nimport shape = require("./IShape"); \nexport class Triangle implements shape.IShape { \n   public draw() { \n      console.log("Triangle is drawn (external module)"); \n   } \n}\nTestShape.ts 文件代码：\nimport shape = require("./IShape"); \nimport circle = require("./Circle"); \nimport triangle = require("./Triangle");  \n \nfunction drawAllShapes(shapeToDraw: shape.IShape) {\n   shapeToDraw.draw(); \n} \n \ndrawAllShapes(new circle.Circle()); \ndrawAllShapes(new triangle.Triangle());\n使用 tsc 命令编译以上代码（AMD）：\n\ntsc --module amd TestShape.ts \n得到以下 JavaScript 代码：\n\nIShape.js 文件代码：\ndefine(["require", "exports"], function (require, exports) {\n});\nCircle.js 文件代码：\ndefine(["require", "exports"], function (require, exports) {\n   var Circle = (function () {\n      function Circle() {\n      }\n      Circle.prototype.draw = function () {\n         console.log("Cirlce is drawn (external module)");\n      };\n      return Circle;\n   })();\n   exports.Circle = Circle;\n});\nTriangle.js 文件代码：\ndefine(["require", "exports"], function (require, exports) {\n   var Triangle = (function () {\n      function Triangle() {\n      }\n      Triangle.prototype.draw = function () {\n         console.log("Triangle is drawn (external module)");\n      };\n      return Triangle;\n   })();\n   exports.Triangle = Triangle;\n});\nTestShape.js 文件代码：\ndefine(["require", "exports", "./Circle", "./Triangle"], \n   function (require, exports, circle, triangle) {\n   \n   function drawAllShapes(shapeToDraw) {\n      shapeToDraw.draw();\n   }\n   drawAllShapes(new circle.Circle());\n   drawAllShapes(new triangle.Triangle());\n});\n使用 tsc 命令编译以上代码（Commonjs）：\n\ntsc --module commonjs TestShape.ts\n得到以下 JavaScript 代码：\n\nCircle.js 文件代码：\nvar Circle = (function () {\n   function Circle() {\n   }\n   Circle.prototype.draw = function () {\n      console.log("Cirlce is drawn");\n   };\n   return Circle;\n})();\n \nexports.Circle = Circle;\nTriangle.js 文件代码：\nvar Triangle = (function () {\n   function Triangle() {\n   }\n   Triangle.prototype.draw = function () {\n      console.log("Triangle is drawn (external module)");\n   };\n   return Triangle;\n})();\nexports.Triangle = Triangle;\nTestShape.js 文件代码：\nvar circle = require("./Circle");\nvar triangle = require("./Triangle");\n \nfunction drawAllShapes(shapeToDraw) {\n   shapeToDraw.draw();\n}\ndrawAllShapes(new circle.Circle());\ndrawAllShapes(new triangle.Triangle());\n输出结果为：\n\nCirlce is drawn (external module)\nTriangle is drawn (external module)\n')])])]),a("h2",{attrs:{id:"typescript-声明文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript-声明文件"}},[n._v("#")]),n._v(" TypeScript 声明文件")]),n._v(" "),a("p",[n._v("TypeScript 作为 JavaScript 的超集，在开发过程中不可避免要引用其他第三方的 JavaScript 的库。虽然通过直接引用可以调用库的类和方法，但是却无法使用TypeScript 诸如类型检查等特性功能。为了解决这个问题，需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述 JavaScript 库和模块信息的声明文件。通过引用这个声明文件，就可以借用 TypeScript 的各种特性来使用库文件了。")]),n._v(" "),a("p",[n._v("假如我们想使用第三方库，比如 jQuery，我们通常这样获取一个 id 是 foo 的元素：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('$(\'#foo\');\n// 或\njQuery(\'#foo\');\n但是在 TypeScript 中，我们并不知道 $ 或 jQuery 是什么东西：\n\njQuery(\'#foo\');\n\n// index.ts(1,1): error TS2304: Cannot find name \'jQuery\'.\n这时，我们需要使用 declare 关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型对不对：\n\ndeclare var jQuery: (selector: string) => any;\n\njQuery(\'#foo\');\ndeclare 定义的类型只会用于编译时的检查，编译结果中会被删除。\n\n上例的编译结果是：\n\njQuery(\'#foo\');\n声明文件\n声明文件以 .d.ts 为后缀，例如：\n\nrunoob.d.ts\n声明文件或模块的语法格式如下：\n\ndeclare module Module_Name {\n}\nTypeScript 引入声明文件语法格式：\n\n/// <reference path = " runoob.d.ts" />\n当然，很多流行的第三方库的声明文件不需要我们定义了，比如 jQuery 已经有人帮我们定义好了：jQuery in DefinitelyTyped。\n\n以下定义一个第三方库来演示：\n\nCalcThirdPartyJsLib.js 文件代码：\nvar Runoob;  \n(function(Runoob) {\n    var Calc = (function () { \n        function Calc() { \n        } \n    })\n    Calc.prototype.doSum = function (limit) {\n        var sum = 0; \n \n        for (var i = 0; i <= limit; i++) { \n            sum = sum + i; \n        }\n        return sum; \n    }\n    Runoob.Calc = Calc; \n    return Calc; \n})(Runoob || (Runoob = {})); \nvar test = new Runoob.Calc();\n如果我们想在 TypeScript 中引用上面的代码，则需要设置声明文件 Calc.d.ts，代码如下：\n\nCalc.d.ts 文件代码：\ndeclare module Runoob { \n   export class Calc { \n      doSum(limit:number) : number; \n   }\n}\n声明文件不包含实现，它只是类型声明，把声明文件加入到 TypeScript 中：\n\nCalcTest.ts 文件代码：\n/// <reference path = "Calc.d.ts" /> \nvar obj = new Runoob.Calc(); \n// obj.doSum("Hello"); // 编译错误\nconsole.log(obj.doSum(10));\n下面这行导致编译错误，因为我们需要传入数字参数：\n\nobj.doSum("Hello");\n使用 tsc 命令来编译以上代码文件：\n\ntsc CalcTest.ts\n生成的 JavaScript 代码如下：\n\nCalcTest.js 文件代码：\n/// <reference path = "Calc.d.ts" /> \nvar obj = new Runoob.Calc();\n//obj.doSum("Hello"); // 编译错误\nconsole.log(obj.doSum(10));\n最后我们编写一个 runoob.html 文件，引入 CalcTest.js 文件及第三方库 CalcThirdPartyJsLib.js：\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset="utf-8">\n<title>菜鸟教程(runoob.com)</title>\n<script src = "CalcThirdPartyJsLib.js"><\/script> \n<script src = "CalcTest.js"><\/script> \n</head>\n<body>\n    <h1>声明文件测试</h1>\n    <p>菜鸟测试一下。</p>\n</body>\n</html>\n')])])])],1)}),[],!1,null,null,null);e.default=r.exports}}]);